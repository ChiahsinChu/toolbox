{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Toolbox","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Some python codes used for my project. Please feel free to reach me via email: jiaxinzhu@stu.xmu.edu.cn .</p>"},{"location":"#to-do-list","title":"To-do list","text":"<ul> <li> MultiFrameCp2kOutput</li> <li> Unit Testing</li> <li> write class for workflow plotting</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>git clone --recursive https://github.com/ChiahsinChu/toolbox.git\ncd toolbox\npip install .\n</code></pre> <p>If you don't use <code>--recursive</code>, you will miss the submodule(s). You can, alternatively, download the submodule(s) in two steps:</p> <pre><code>git clone https://github.com/ChiahsinChu/toolbox.git\ncd toolbox\ngit submodule update --init --recursive\n</code></pre> <p>You can check if the installation succeeds by running:</p> <pre><code>python -c \"import toolbox; toolbox.test()\"\n</code></pre>"},{"location":"#users-guide","title":"User's guide","text":""},{"location":"#pre-post-processing-in-commonly-used-packages","title":"pre-/post-processing in commonly used packages","text":"<ul> <li>CP2K</li> <li>LAMMPS</li> <li>Deep Potential</li> </ul>"},{"location":"#routines-in-projects","title":"routines in projects","text":"<ul> <li>do calculation in python scripts</li> <li>make plots</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>This section contains the auto-generated API documentation for the toolbox package, created from the numpy-style docstrings in the source code.</p>"},{"location":"api/#calculator-module","title":"Calculator Module","text":""},{"location":"api/#bash-calculator","title":"Bash Calculator","text":""},{"location":"api/#toolbox.calculator.bash","title":"<code>toolbox.calculator.bash</code>","text":"<p>Bash calculator for running external commands.</p> <p>This module provides a calculator interface for running bash commands and external programs with proper error handling and logging.</p>"},{"location":"api/#toolbox.calculator.bash.BashCalculator","title":"<code>BashCalculator</code>","text":"<p>A calculator for running bash commands in a specified working directory.</p> <p>This class provides functionality to execute shell commands with proper directory management and logging.</p> Source code in <code>toolbox/calculator/bash.py</code> <pre><code>class BashCalculator:\n    \"\"\"A calculator for running bash commands in a specified working directory.\n\n    This class provides functionality to execute shell commands with proper\n    directory management and logging.\n    \"\"\"\n\n    def __init__(self, work_dir) -&gt; None:\n        \"\"\"Initialize the BashCalculator.\n\n        Parameters\n        ----------\n        work_dir : str\n            The working directory where commands will be executed\n        \"\"\"\n        self.work_dir = work_dir\n\n    def run(\n        self,\n        command: str = None,\n        stdin: str = None,\n        stdout: str = \"job.stdout\",\n        stderr: str = \"job.stderr\",\n        mpi_command: str = \"mpiexec.hydra\",\n        ignore_finished_tag: bool = False,\n    ):\n        \"\"\"Execute a command in the working directory.\n\n        Parameters\n        ----------\n        command : str, optional\n            Command to execute, by default None\n        stdin : str, optional\n            Standard input file, by default None\n        stdout : str, optional\n            Standard output file, by default \"job.stdout\"\n        stderr : str, optional\n            Standard error file, by default \"job.stderr\"\n        mpi_command : str, optional\n            MPI command to use, by default \"mpiexec.hydra\"\n        ignore_finished_tag : bool, optional\n            Whether to ignore existing finished tag, by default False\n        \"\"\"\n        if (ignore_finished_tag) or (\n            not os.path.exists(os.path.join(self.work_dir, \"finished_tag\"))\n        ):\n            if mpi_command is not None:\n                command = f\"{mpi_command} {command}\"\n\n            root_dir = os.getcwd()\n            os.chdir(self.work_dir)\n            logging.info(\"{:=^50}\".format(\" Start calculation \"))\n\n            logging.info(f\"Path: {os.getcwd()}\")\n            if stdin is not None:\n                command += f\" {stdin} \"\n            if stdout is not None:\n                command += f\" 1&gt; {stdout} \"\n            if stderr is not None:\n                command += f\" 2&gt; {stderr} \"\n            os.system(command=command)\n\n            self._make_finished_tag(stdout)\n\n            logging.info(\"{:=^50}\".format(\" End calculation \"))\n            os.chdir(root_dir)\n\n    @staticmethod\n    def _make_finished_tag(stdout):\n        \"\"\"Create a finished tag file after successful execution.\n\n        Parameters\n        ----------\n        stdout : str\n            Name of the standard output file to check\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/#toolbox.calculator.bash.BashCalculator.__init__","title":"<code>__init__(work_dir)</code>","text":"<p>Initialize the BashCalculator.</p> <p>Parameters:</p> Name Type Description Default <code>work_dir</code> <code>str</code> <p>The working directory where commands will be executed</p> required Source code in <code>toolbox/calculator/bash.py</code> <pre><code>def __init__(self, work_dir) -&gt; None:\n    \"\"\"Initialize the BashCalculator.\n\n    Parameters\n    ----------\n    work_dir : str\n        The working directory where commands will be executed\n    \"\"\"\n    self.work_dir = work_dir\n</code></pre>"},{"location":"api/#toolbox.calculator.bash.BashCalculator.run","title":"<code>run(command=None, stdin=None, stdout='job.stdout', stderr='job.stderr', mpi_command='mpiexec.hydra', ignore_finished_tag=False)</code>","text":"<p>Execute a command in the working directory.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Command to execute, by default None</p> <code>None</code> <code>stdin</code> <code>str</code> <p>Standard input file, by default None</p> <code>None</code> <code>stdout</code> <code>str</code> <p>Standard output file, by default \"job.stdout\"</p> <code>'job.stdout'</code> <code>stderr</code> <code>str</code> <p>Standard error file, by default \"job.stderr\"</p> <code>'job.stderr'</code> <code>mpi_command</code> <code>str</code> <p>MPI command to use, by default \"mpiexec.hydra\"</p> <code>'mpiexec.hydra'</code> <code>ignore_finished_tag</code> <code>bool</code> <p>Whether to ignore existing finished tag, by default False</p> <code>False</code> Source code in <code>toolbox/calculator/bash.py</code> <pre><code>def run(\n    self,\n    command: str = None,\n    stdin: str = None,\n    stdout: str = \"job.stdout\",\n    stderr: str = \"job.stderr\",\n    mpi_command: str = \"mpiexec.hydra\",\n    ignore_finished_tag: bool = False,\n):\n    \"\"\"Execute a command in the working directory.\n\n    Parameters\n    ----------\n    command : str, optional\n        Command to execute, by default None\n    stdin : str, optional\n        Standard input file, by default None\n    stdout : str, optional\n        Standard output file, by default \"job.stdout\"\n    stderr : str, optional\n        Standard error file, by default \"job.stderr\"\n    mpi_command : str, optional\n        MPI command to use, by default \"mpiexec.hydra\"\n    ignore_finished_tag : bool, optional\n        Whether to ignore existing finished tag, by default False\n    \"\"\"\n    if (ignore_finished_tag) or (\n        not os.path.exists(os.path.join(self.work_dir, \"finished_tag\"))\n    ):\n        if mpi_command is not None:\n            command = f\"{mpi_command} {command}\"\n\n        root_dir = os.getcwd()\n        os.chdir(self.work_dir)\n        logging.info(\"{:=^50}\".format(\" Start calculation \"))\n\n        logging.info(f\"Path: {os.getcwd()}\")\n        if stdin is not None:\n            command += f\" {stdin} \"\n        if stdout is not None:\n            command += f\" 1&gt; {stdout} \"\n        if stderr is not None:\n            command += f\" 2&gt; {stderr} \"\n        os.system(command=command)\n\n        self._make_finished_tag(stdout)\n\n        logging.info(\"{:=^50}\".format(\" End calculation \"))\n        os.chdir(root_dir)\n</code></pre>"},{"location":"api/#coulomb-calculator","title":"Coulomb Calculator","text":""},{"location":"api/#toolbox.calculator.coulomb","title":"<code>toolbox.calculator.coulomb</code>","text":"<p>Coulomb interaction calculators for molecular simulations.</p> <p>This module provides calculators for: - Coulomb cutoff interactions - Ewald summation methods - Particle Mesh Ewald (PME) calculations - D3 dispersion corrections</p> <p>These calculators are used for computing electrostatic interactions in molecular dynamics simulations.</p>"},{"location":"api/#toolbox.calculator.coulomb.CoulCutCalculator","title":"<code>CoulCutCalculator</code>","text":"<p>Calculator for Coulomb interactions with cutoff.</p> <p>This calculator computes Coulomb interactions between atoms using a simple cutoff scheme.</p> Source code in <code>toolbox/calculator/coulomb.py</code> <pre><code>class CoulCutCalculator:\n    \"\"\"Calculator for Coulomb interactions with cutoff.\n\n    This calculator computes Coulomb interactions between atoms\n    using a simple cutoff scheme.\n    \"\"\"\n\n    def __init__(self, cutoff=5.0) -&gt; None:\n        \"\"\"Initialize CoulCutCalculator.\n\n        Parameters\n        ----------\n        cutoff : float, optional\n            Cutoff distance in Angstroms, by default 5.0\n        \"\"\"\n        self.cutoff = cutoff\n\n    def calculate(self, atoms):\n        \"\"\"Calculate Coulomb energy and forces.\n\n        Parameters\n        ----------\n        atoms : ase.Atoms\n            ASE Atoms object with positions and charges\n\n        Returns\n        -------\n        tuple\n            Tuple of (energy, forces) where energy is in eV\n            and forces is an array in eV/A\n        \"\"\"\n        cellpar = atoms.cell.cellpar()\n        coords = atoms.get_positions()\n        charges = atoms.get_initial_charges()\n        dist_mat = distance_array(coords, coords, box=cellpar)\n        nat = len(atoms)\n        forces = np.zeros((nat, 3))\n        energy = 0.0\n        for ii in range(nat):\n            force_mask = (dist_mat[ii] &lt; self.cutoff) &amp; (np.arange(nat) &gt; ii)\n            sel_ids = np.where(force_mask)[0]\n            forcecoul = qqrd2e * charges[ii] * charges[sel_ids] / dist_mat[ii][sel_ids]\n            fpair = forcecoul / dist_mat[ii][sel_ids] ** 2\n            delta_x = minimize_vectors(\n                coords[ii].reshape(1, 3) - coords[sel_ids], box=cellpar\n            )\n            forces[ii] += np.sum(delta_x * fpair.reshape(-1, 1), axis=0)\n            forces[sel_ids] -= delta_x * fpair.reshape(-1, 1)\n            energy += np.sum(forcecoul)\n        return energy, forces\n</code></pre>"},{"location":"api/#toolbox.calculator.coulomb.CoulCutCalculator.__init__","title":"<code>__init__(cutoff=5.0)</code>","text":"<p>Initialize CoulCutCalculator.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>Cutoff distance in Angstroms, by default 5.0</p> <code>5.0</code> Source code in <code>toolbox/calculator/coulomb.py</code> <pre><code>def __init__(self, cutoff=5.0) -&gt; None:\n    \"\"\"Initialize CoulCutCalculator.\n\n    Parameters\n    ----------\n    cutoff : float, optional\n        Cutoff distance in Angstroms, by default 5.0\n    \"\"\"\n    self.cutoff = cutoff\n</code></pre>"},{"location":"api/#toolbox.calculator.coulomb.CoulCutCalculator.calculate","title":"<code>calculate(atoms)</code>","text":"<p>Calculate Coulomb energy and forces.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object with positions and charges</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (energy, forces) where energy is in eV and forces is an array in eV/A</p> Source code in <code>toolbox/calculator/coulomb.py</code> <pre><code>def calculate(self, atoms):\n    \"\"\"Calculate Coulomb energy and forces.\n\n    Parameters\n    ----------\n    atoms : ase.Atoms\n        ASE Atoms object with positions and charges\n\n    Returns\n    -------\n    tuple\n        Tuple of (energy, forces) where energy is in eV\n        and forces is an array in eV/A\n    \"\"\"\n    cellpar = atoms.cell.cellpar()\n    coords = atoms.get_positions()\n    charges = atoms.get_initial_charges()\n    dist_mat = distance_array(coords, coords, box=cellpar)\n    nat = len(atoms)\n    forces = np.zeros((nat, 3))\n    energy = 0.0\n    for ii in range(nat):\n        force_mask = (dist_mat[ii] &lt; self.cutoff) &amp; (np.arange(nat) &gt; ii)\n        sel_ids = np.where(force_mask)[0]\n        forcecoul = qqrd2e * charges[ii] * charges[sel_ids] / dist_mat[ii][sel_ids]\n        fpair = forcecoul / dist_mat[ii][sel_ids] ** 2\n        delta_x = minimize_vectors(\n            coords[ii].reshape(1, 3) - coords[sel_ids], box=cellpar\n        )\n        forces[ii] += np.sum(delta_x * fpair.reshape(-1, 1), axis=0)\n        forces[sel_ids] -= delta_x * fpair.reshape(-1, 1)\n        energy += np.sum(forcecoul)\n    return energy, forces\n</code></pre>"},{"location":"api/#toolbox.calculator.coulomb.CoulLongCalculator","title":"<code>CoulLongCalculator</code>","text":"<p>Calculator for long-range Coulomb interactions with Ewald summation.</p> <p>This calculator computes Coulomb interactions using Ewald summation with complementary error function screening.</p> Source code in <code>toolbox/calculator/coulomb.py</code> <pre><code>class CoulLongCalculator:\n    \"\"\"Calculator for long-range Coulomb interactions with Ewald summation.\n\n    This calculator computes Coulomb interactions using Ewald summation\n    with complementary error function screening.\n    \"\"\"\n\n    def __init__(self, gewald, cutoff=5.0) -&gt; None:\n        \"\"\"Initialize CoulLongCalculator.\n\n        Parameters\n        ----------\n        gewald : float\n            Ewald screening parameter\n        cutoff : float, optional\n            Real-space cutoff distance in Angstroms, by default 5.0\n        \"\"\"\n        self.cutoff = cutoff\n        self.gewald = gewald\n\n    def calculate(self, atoms):\n        \"\"\"Calculate Coulomb energy and forces with Ewald summation.\n\n        Parameters\n        ----------\n        atoms : ase.Atoms\n            ASE Atoms object with positions and charges\n\n        Returns\n        -------\n        tuple\n            Tuple of (energy, forces) where energy is in eV\n            and forces is an array in eV/A\n        \"\"\"\n        cellpar = atoms.cell.cellpar()\n        coords = atoms.get_positions()\n        charges = atoms.get_initial_charges()\n        dist_mat = distance_array(coords, coords, box=cellpar)\n        nat = len(atoms)\n        forces = np.zeros((nat, 3))\n        energy = 0.0\n        for ii in range(nat):\n            force_mask = (dist_mat[ii] &lt; self.cutoff) &amp; (np.arange(nat) &gt; ii)\n            sel_ids = np.where(force_mask)[0]\n            prefactor = qqrd2e * charges[ii] * charges[sel_ids] / dist_mat[ii][sel_ids]\n            grij = self.gewald * dist_mat[ii][sel_ids]\n            expm2 = np.exp(-grij * grij)\n            t = 1.0 / (1.0 + EWALD_P * grij)\n            erfc = t * (A1 + t * (A2 + t * (A3 + t * (A4 + t * A5)))) * expm2\n            forcecoul = prefactor * (erfc + EWALD_F * grij * expm2)\n            fpair = forcecoul / dist_mat[ii][sel_ids] ** 2\n            delta_x = minimize_vectors(\n                coords[ii].reshape(1, 3) - coords[sel_ids], box=cellpar\n            )\n            forces[ii] += np.sum(delta_x * fpair.reshape(-1, 1), axis=0)\n            forces[sel_ids] -= delta_x * fpair.reshape(-1, 1)\n            energy += np.sum(prefactor * erfc)\n        return energy, forces\n</code></pre>"},{"location":"api/#toolbox.calculator.coulomb.CoulLongCalculator.__init__","title":"<code>__init__(gewald, cutoff=5.0)</code>","text":"<p>Initialize CoulLongCalculator.</p> <p>Parameters:</p> Name Type Description Default <code>gewald</code> <code>float</code> <p>Ewald screening parameter</p> required <code>cutoff</code> <code>float</code> <p>Real-space cutoff distance in Angstroms, by default 5.0</p> <code>5.0</code> Source code in <code>toolbox/calculator/coulomb.py</code> <pre><code>def __init__(self, gewald, cutoff=5.0) -&gt; None:\n    \"\"\"Initialize CoulLongCalculator.\n\n    Parameters\n    ----------\n    gewald : float\n        Ewald screening parameter\n    cutoff : float, optional\n        Real-space cutoff distance in Angstroms, by default 5.0\n    \"\"\"\n    self.cutoff = cutoff\n    self.gewald = gewald\n</code></pre>"},{"location":"api/#toolbox.calculator.coulomb.CoulLongCalculator.calculate","title":"<code>calculate(atoms)</code>","text":"<p>Calculate Coulomb energy and forces with Ewald summation.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object with positions and charges</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (energy, forces) where energy is in eV and forces is an array in eV/A</p> Source code in <code>toolbox/calculator/coulomb.py</code> <pre><code>def calculate(self, atoms):\n    \"\"\"Calculate Coulomb energy and forces with Ewald summation.\n\n    Parameters\n    ----------\n    atoms : ase.Atoms\n        ASE Atoms object with positions and charges\n\n    Returns\n    -------\n    tuple\n        Tuple of (energy, forces) where energy is in eV\n        and forces is an array in eV/A\n    \"\"\"\n    cellpar = atoms.cell.cellpar()\n    coords = atoms.get_positions()\n    charges = atoms.get_initial_charges()\n    dist_mat = distance_array(coords, coords, box=cellpar)\n    nat = len(atoms)\n    forces = np.zeros((nat, 3))\n    energy = 0.0\n    for ii in range(nat):\n        force_mask = (dist_mat[ii] &lt; self.cutoff) &amp; (np.arange(nat) &gt; ii)\n        sel_ids = np.where(force_mask)[0]\n        prefactor = qqrd2e * charges[ii] * charges[sel_ids] / dist_mat[ii][sel_ids]\n        grij = self.gewald * dist_mat[ii][sel_ids]\n        expm2 = np.exp(-grij * grij)\n        t = 1.0 / (1.0 + EWALD_P * grij)\n        erfc = t * (A1 + t * (A2 + t * (A3 + t * (A4 + t * A5)))) * expm2\n        forcecoul = prefactor * (erfc + EWALD_F * grij * expm2)\n        fpair = forcecoul / dist_mat[ii][sel_ids] ** 2\n        delta_x = minimize_vectors(\n            coords[ii].reshape(1, 3) - coords[sel_ids], box=cellpar\n        )\n        forces[ii] += np.sum(delta_x * fpair.reshape(-1, 1), axis=0)\n        forces[sel_ids] -= delta_x * fpair.reshape(-1, 1)\n        energy += np.sum(prefactor * erfc)\n    return energy, forces\n</code></pre>"},{"location":"api/#toolbox.calculator.coulomb.DMFFPMECalculator","title":"<code>DMFFPMECalculator</code>","text":"<p>Calculator for Coulomb interactions using Particle Mesh Ewald (PME).</p> <p>This calculator uses the DMFF library to compute Coulomb interactions with PME for efficient long-range electrostatics.</p> Source code in <code>toolbox/calculator/coulomb.py</code> <pre><code>class DMFFPMECalculator:\n    \"\"\"Calculator for Coulomb interactions using Particle Mesh Ewald (PME).\n\n    This calculator uses the DMFF library to compute Coulomb interactions\n    with PME for efficient long-range electrostatics.\n    \"\"\"\n\n    def __init__(self, cutoff=6.0) -&gt; None:\n        \"\"\"Initialize DMFFPMECalculator.\n\n        Parameters\n        ----------\n        cutoff : float, optional\n            Real-space cutoff distance in Angstroms, by default 6.0\n        \"\"\"\n        self.cutoff = cutoff\n\n    def calculate(self, atoms, ethresh=1e-6) -&gt; float:\n        \"\"\"Calculate Coulomb energy using PME.\n\n        Parameters\n        ----------\n        atoms : ase.Atoms\n            ASE Atoms object with positions and charges\n        ethresh : float, optional\n            Ewald threshold, by default 1e-6\n\n        Returns\n        -------\n        float\n            Coulomb energy in eV/particle\n        \"\"\"\n        positions = atoms.get_positions()\n        box = atoms.get_cell()\n        charges = atoms.get_initial_charges()\n        pairs = calculate_pairs(atoms, self.cutoff)\n\n        box = torch.tensor(box, dtype=torch.double, requires_grad=False, device=DEVICE)\n        positions = torch.tensor(\n            positions, dtype=torch.double, requires_grad=True, device=DEVICE\n        )\n        charges = torch.tensor(\n            charges, dtype=torch.double, requires_grad=False, device=DEVICE\n        )\n        pairs = torch.tensor(\n            pairs, dtype=torch.int32, requires_grad=False, device=DEVICE\n        )\n\n        mscales = torch.tensor([0.0, 0.0, 1.0, 1.0, 1.0, 1.0], device=DEVICE)\n        kappa, K = self.setup_ewald(box, ethresh)\n        K1, K2, K3 = K\n        pme_recip_fn = generate_pme_recip(\n            Ck_fn=Ck_1,\n            kappa=kappa,\n            gamma=False,\n            pme_order=6,\n            K1=K1,\n            K2=K2,\n            K3=K3,\n            lmax=0,\n        )\n        charges = torch.reshape(charges, (-1, 1))\n        energy = energy_pme(\n            positions,\n            box,\n            pairs,\n            charges,\n            None,\n            None,\n            None,\n            mscales,\n            None,\n            None,\n            None,\n            pme_recip_fn,\n            kappa,\n            K1,\n            K2,\n            K3,\n            0,\n            False,\n            True,\n        )[0]\n        # from kJ/mol to eV/particle\n        return (energy * ENERGY_COEFF).item()\n\n    def setup_ewald(self, box, ethresh):\n        \"\"\"Set up Ewald parameters for PME calculation.\n\n        Parameters\n        ----------\n        box : array_like\n            Simulation box vectors\n        ethresh : float\n            Ewald threshold\n\n        Returns\n        -------\n        tuple\n            Tuple of (kappa, K) where kappa is the screening parameter\n            and K is the grid dimensions\n        \"\"\"\n        kappa, K1, K2, K3 = setup_ewald_parameters(\n            torch.tensor(self.cutoff), torch.tensor(ethresh), box, 0.01, \"openmm\"\n        )\n        K = (K1, K2, K3)\n        return kappa, K\n</code></pre>"},{"location":"api/#toolbox.calculator.coulomb.DMFFPMECalculator.__init__","title":"<code>__init__(cutoff=6.0)</code>","text":"<p>Initialize DMFFPMECalculator.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>Real-space cutoff distance in Angstroms, by default 6.0</p> <code>6.0</code> Source code in <code>toolbox/calculator/coulomb.py</code> <pre><code>def __init__(self, cutoff=6.0) -&gt; None:\n    \"\"\"Initialize DMFFPMECalculator.\n\n    Parameters\n    ----------\n    cutoff : float, optional\n        Real-space cutoff distance in Angstroms, by default 6.0\n    \"\"\"\n    self.cutoff = cutoff\n</code></pre>"},{"location":"api/#toolbox.calculator.coulomb.DMFFPMECalculator.calculate","title":"<code>calculate(atoms, ethresh=1e-06)</code>","text":"<p>Calculate Coulomb energy using PME.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object with positions and charges</p> required <code>ethresh</code> <code>float</code> <p>Ewald threshold, by default 1e-6</p> <code>1e-06</code> <p>Returns:</p> Type Description <code>float</code> <p>Coulomb energy in eV/particle</p> Source code in <code>toolbox/calculator/coulomb.py</code> <pre><code>def calculate(self, atoms, ethresh=1e-6) -&gt; float:\n    \"\"\"Calculate Coulomb energy using PME.\n\n    Parameters\n    ----------\n    atoms : ase.Atoms\n        ASE Atoms object with positions and charges\n    ethresh : float, optional\n        Ewald threshold, by default 1e-6\n\n    Returns\n    -------\n    float\n        Coulomb energy in eV/particle\n    \"\"\"\n    positions = atoms.get_positions()\n    box = atoms.get_cell()\n    charges = atoms.get_initial_charges()\n    pairs = calculate_pairs(atoms, self.cutoff)\n\n    box = torch.tensor(box, dtype=torch.double, requires_grad=False, device=DEVICE)\n    positions = torch.tensor(\n        positions, dtype=torch.double, requires_grad=True, device=DEVICE\n    )\n    charges = torch.tensor(\n        charges, dtype=torch.double, requires_grad=False, device=DEVICE\n    )\n    pairs = torch.tensor(\n        pairs, dtype=torch.int32, requires_grad=False, device=DEVICE\n    )\n\n    mscales = torch.tensor([0.0, 0.0, 1.0, 1.0, 1.0, 1.0], device=DEVICE)\n    kappa, K = self.setup_ewald(box, ethresh)\n    K1, K2, K3 = K\n    pme_recip_fn = generate_pme_recip(\n        Ck_fn=Ck_1,\n        kappa=kappa,\n        gamma=False,\n        pme_order=6,\n        K1=K1,\n        K2=K2,\n        K3=K3,\n        lmax=0,\n    )\n    charges = torch.reshape(charges, (-1, 1))\n    energy = energy_pme(\n        positions,\n        box,\n        pairs,\n        charges,\n        None,\n        None,\n        None,\n        mscales,\n        None,\n        None,\n        None,\n        pme_recip_fn,\n        kappa,\n        K1,\n        K2,\n        K3,\n        0,\n        False,\n        True,\n    )[0]\n    # from kJ/mol to eV/particle\n    return (energy * ENERGY_COEFF).item()\n</code></pre>"},{"location":"api/#toolbox.calculator.coulomb.DMFFPMECalculator.setup_ewald","title":"<code>setup_ewald(box, ethresh)</code>","text":"<p>Set up Ewald parameters for PME calculation.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>array_like</code> <p>Simulation box vectors</p> required <code>ethresh</code> <code>float</code> <p>Ewald threshold</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (kappa, K) where kappa is the screening parameter and K is the grid dimensions</p> Source code in <code>toolbox/calculator/coulomb.py</code> <pre><code>def setup_ewald(self, box, ethresh):\n    \"\"\"Set up Ewald parameters for PME calculation.\n\n    Parameters\n    ----------\n    box : array_like\n        Simulation box vectors\n    ethresh : float\n        Ewald threshold\n\n    Returns\n    -------\n    tuple\n        Tuple of (kappa, K) where kappa is the screening parameter\n        and K is the grid dimensions\n    \"\"\"\n    kappa, K1, K2, K3 = setup_ewald_parameters(\n        torch.tensor(self.cutoff), torch.tensor(ethresh), box, 0.01, \"openmm\"\n    )\n    K = (K1, K2, K3)\n    return kappa, K\n</code></pre>"},{"location":"api/#toolbox.calculator.coulomb.calculate_pairs","title":"<code>calculate_pairs(atoms, rcut)</code>","text":"<p>Calculate atom pairs within cutoff distance.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object</p> required <code>rcut</code> <code>float</code> <p>Cutoff distance in Angstroms</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of atom pairs within cutoff, each as [i, j, 0]</p> Source code in <code>toolbox/calculator/coulomb.py</code> <pre><code>def calculate_pairs(atoms, rcut):\n    \"\"\"Calculate atom pairs within cutoff distance.\n\n    Parameters\n    ----------\n    atoms : ase.Atoms\n        ASE Atoms object\n    rcut : float\n        Cutoff distance in Angstroms\n\n    Returns\n    -------\n    list\n        List of atom pairs within cutoff, each as [i, j, 0]\n    \"\"\"\n    cellpar = atoms.cell.cellpar()\n    positions = atoms.get_positions()\n\n    pairs = []\n    dist_mat = distance_array(positions, positions, box=cellpar)\n    for ii, dist_vec in enumerate(dist_mat):\n        mask = dist_vec &lt; rcut\n        jjs = np.where(mask)[0]\n        mask = jjs &gt; ii\n        jjs = jjs[mask]\n        for jj in jjs:\n            pairs.append([ii, jj, 0])\n    return pairs\n</code></pre>"},{"location":"api/#toolbox.calculator.coulomb.coul","title":"<code>coul(qi, qj, rij)</code>","text":"<p>Calculate Coulomb energy between two point charges.</p> <p>Parameters:</p> Name Type Description Default <code>qi</code> <code>float</code> <p>First charge in elementary charge units (e)</p> required <code>qj</code> <code>float</code> <p>Second charge in elementary charge units (e)</p> required <code>rij</code> <code>float</code> <p>Distance between charges in Angstroms (A)</p> required <p>Returns:</p> Type Description <code>float</code> <p>Coulomb energy in electron volts (eV)</p> Source code in <code>toolbox/calculator/coulomb.py</code> <pre><code>def coul(qi, qj, rij):\n    \"\"\"Calculate Coulomb energy between two point charges.\n\n    Parameters\n    ----------\n    qi : float\n        First charge in elementary charge units (e)\n    qj : float\n        Second charge in elementary charge units (e)\n    rij : float\n        Distance between charges in Angstroms (A)\n\n    Returns\n    -------\n    float\n        Coulomb energy in electron volts (eV)\n    \"\"\"\n    e = qqrd2e * qi * qj / rij\n    return e\n</code></pre>"},{"location":"api/#toolbox.calculator.coulomb.real_coul","title":"<code>real_coul(qi, qj, xi, xj, gewald, force=False)</code>","text":"<p>Calculate real-space Coulomb energy with Ewald summation.</p> <p>Parameters:</p> Name Type Description Default <code>qi</code> <code>float</code> <p>First charge in elementary charge units (e)</p> required <code>qj</code> <code>float</code> <p>Second charge in elementary charge units (e)</p> required <code>xi</code> <code>array_like</code> <p>Position of first charge</p> required <code>xj</code> <code>array_like</code> <p>Position of second charge</p> required <code>gewald</code> <code>float</code> <p>Ewald screening parameter</p> required <code>force</code> <code>bool</code> <p>Whether to calculate forces, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>float or tuple</code> <p>If force=False, returns Coulomb energy in eV If force=True, returns tuple of (energy, force)</p> Source code in <code>toolbox/calculator/coulomb.py</code> <pre><code>def real_coul(qi, qj, xi, xj, gewald, force=False):\n    \"\"\"Calculate real-space Coulomb energy with Ewald summation.\n\n    Parameters\n    ----------\n    qi : float\n        First charge in elementary charge units (e)\n    qj : float\n        Second charge in elementary charge units (e)\n    xi : array_like\n        Position of first charge\n    xj : array_like\n        Position of second charge\n    gewald : float\n        Ewald screening parameter\n    force : bool, optional\n        Whether to calculate forces, by default False\n\n    Returns\n    -------\n    float or tuple\n        If force=False, returns Coulomb energy in eV\n        If force=True, returns tuple of (energy, force)\n    \"\"\"\n    rij = np.linalg.norm(xi - xj)\n    prefactor = qqrd2e * qi * qj / rij\n    if force:\n        grij = gewald * rij\n        expm2 = np.exp(-grij * grij)\n        t = 1.0 / (1.0 + EWALD_P * grij)\n        erfc = t * (A1 + t * (A2 + t * (A3 + t * (A4 + t * A5)))) * expm2\n        forcecoul = prefactor * (erfc + EWALD_F * grij * expm2)\n        fpair = forcecoul / rij**2\n        f = (xi - xj) * fpair\n        e = prefactor * erfc\n        return e, f\n    else:\n        e = prefactor * special.erfc(rij * gewald)\n        return e\n</code></pre>"},{"location":"api/#cp2k-calculator","title":"CP2K Calculator","text":""},{"location":"api/#toolbox.calculator.cp2k","title":"<code>toolbox.calculator.cp2k</code>","text":"<p>CP2K quantum chemistry calculator interface.</p> <p>This module provides a calculator interface for running CP2K quantum chemistry calculations with proper error handling and output checking.</p>"},{"location":"api/#toolbox.calculator.cp2k.Cp2kCalculator","title":"<code>Cp2kCalculator</code>","text":"<p>               Bases: <code>BashCalculator</code></p> <p>A calculator for running CP2K quantum chemistry calculations.</p> <p>This class extends BashCalculator to provide specific functionality for CP2K calculations, including error handling and output checking.</p> Source code in <code>toolbox/calculator/cp2k.py</code> <pre><code>class Cp2kCalculator(BashCalculator):\n    \"\"\"A calculator for running CP2K quantum chemistry calculations.\n\n    This class extends BashCalculator to provide specific functionality for\n    CP2K calculations, including error handling and output checking.\n    \"\"\"\n\n    def __init__(self, work_dir) -&gt; None:\n        \"\"\"Initialize the Cp2kCalculator.\n\n        Parameters\n        ----------\n        work_dir : str\n            The working directory where CP2K calculations will be executed\n        \"\"\"\n        super().__init__(work_dir)\n\n    def run(\n        self,\n        command=\"cp2k.popt\",\n        stdin=\"input.inp\",\n        stdout=\"output.out\",\n        stderr=\"cp2k.stderr\",\n        mpi_command: str = \"mpiexec.hydra\",\n        ignore_finished_tag: bool = False,\n        ignore_err: bool = True,\n    ):\n        \"\"\"Run a CP2K calculation.\n\n        Parameters\n        ----------\n        command : str, optional\n            CP2K executable command, by default \"cp2k.popt\"\n        stdin : str, optional\n            Input file name, by default \"input.inp\"\n        stdout : str, optional\n            Standard output file name, by default \"output.out\"\n        stderr : str, optional\n            Standard error file name, by default \"cp2k.stderr\"\n        mpi_command : str, optional\n            MPI command to use, by default \"mpiexec.hydra\"\n        ignore_finished_tag : bool, optional\n            Whether to ignore existing finished tag, by default False\n        ignore_err : bool, optional\n            Whether to ignore calculation errors, by default True\n        \"\"\"\n        self.ignore_err = ignore_err\n        super().run(command, stdin, stdout, stderr, mpi_command, ignore_finished_tag)\n\n    def _make_finished_tag(self, stdout):\n        \"\"\"Create a finished tag after successful CP2K calculation.\n\n        Parameters\n        ----------\n        stdout : str\n            Name of the CP2K output file to check for completion\n\n        Raises\n        ------\n        SystemExit\n            If CP2K calculation did not finish and ignore_err is False\n        \"\"\"\n        try:\n            Cp2kOutput(stdout)\n            open(os.path.join(\"finished_tag\"), \"w\").close()\n        except Exception:\n            warning_msg = \"CP2K calculation does not finish!\"\n            if self.ignore_err:\n                logging.warning(warning_msg)\n            else:\n                sys.exit(warning_msg)\n</code></pre>"},{"location":"api/#toolbox.calculator.cp2k.Cp2kCalculator.__init__","title":"<code>__init__(work_dir)</code>","text":"<p>Initialize the Cp2kCalculator.</p> <p>Parameters:</p> Name Type Description Default <code>work_dir</code> <code>str</code> <p>The working directory where CP2K calculations will be executed</p> required Source code in <code>toolbox/calculator/cp2k.py</code> <pre><code>def __init__(self, work_dir) -&gt; None:\n    \"\"\"Initialize the Cp2kCalculator.\n\n    Parameters\n    ----------\n    work_dir : str\n        The working directory where CP2K calculations will be executed\n    \"\"\"\n    super().__init__(work_dir)\n</code></pre>"},{"location":"api/#toolbox.calculator.cp2k.Cp2kCalculator.run","title":"<code>run(command='cp2k.popt', stdin='input.inp', stdout='output.out', stderr='cp2k.stderr', mpi_command='mpiexec.hydra', ignore_finished_tag=False, ignore_err=True)</code>","text":"<p>Run a CP2K calculation.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>CP2K executable command, by default \"cp2k.popt\"</p> <code>'cp2k.popt'</code> <code>stdin</code> <code>str</code> <p>Input file name, by default \"input.inp\"</p> <code>'input.inp'</code> <code>stdout</code> <code>str</code> <p>Standard output file name, by default \"output.out\"</p> <code>'output.out'</code> <code>stderr</code> <code>str</code> <p>Standard error file name, by default \"cp2k.stderr\"</p> <code>'cp2k.stderr'</code> <code>mpi_command</code> <code>str</code> <p>MPI command to use, by default \"mpiexec.hydra\"</p> <code>'mpiexec.hydra'</code> <code>ignore_finished_tag</code> <code>bool</code> <p>Whether to ignore existing finished tag, by default False</p> <code>False</code> <code>ignore_err</code> <code>bool</code> <p>Whether to ignore calculation errors, by default True</p> <code>True</code> Source code in <code>toolbox/calculator/cp2k.py</code> <pre><code>def run(\n    self,\n    command=\"cp2k.popt\",\n    stdin=\"input.inp\",\n    stdout=\"output.out\",\n    stderr=\"cp2k.stderr\",\n    mpi_command: str = \"mpiexec.hydra\",\n    ignore_finished_tag: bool = False,\n    ignore_err: bool = True,\n):\n    \"\"\"Run a CP2K calculation.\n\n    Parameters\n    ----------\n    command : str, optional\n        CP2K executable command, by default \"cp2k.popt\"\n    stdin : str, optional\n        Input file name, by default \"input.inp\"\n    stdout : str, optional\n        Standard output file name, by default \"output.out\"\n    stderr : str, optional\n        Standard error file name, by default \"cp2k.stderr\"\n    mpi_command : str, optional\n        MPI command to use, by default \"mpiexec.hydra\"\n    ignore_finished_tag : bool, optional\n        Whether to ignore existing finished tag, by default False\n    ignore_err : bool, optional\n        Whether to ignore calculation errors, by default True\n    \"\"\"\n    self.ignore_err = ignore_err\n    super().run(command, stdin, stdout, stderr, mpi_command, ignore_finished_tag)\n</code></pre>"},{"location":"api/#d3-calculator","title":"D3 Calculator","text":""},{"location":"api/#toolbox.calculator.d3","title":"<code>toolbox.calculator.d3</code>","text":"<p>D3 dispersion correction calculator.</p> <p>This module provides a calculator for Grimme's D3 dispersion corrections using the tad_dftd3 library.</p>"},{"location":"api/#toolbox.calculator.d3.D3Calculator","title":"<code>D3Calculator</code>","text":"<p>Calculator for D3 dispersion corrections.</p> <p>This calculator computes Grimme's D3 dispersion corrections using the tad_dftd3 library.</p> Source code in <code>toolbox/calculator/d3.py</code> <pre><code>class D3Calculator:\n    \"\"\"Calculator for D3 dispersion corrections.\n\n    This calculator computes Grimme's D3 dispersion corrections\n    using the tad_dftd3 library.\n    \"\"\"\n\n    def __init__(self, params: Optional[dict] = None) -&gt; None:\n        \"\"\"Initialize D3Calculator.\n\n        Parameters\n        ----------\n        params : Optional[Dict], optional\n            D3 parameters dictionary, by default None.\n            If None, uses r\u00b2SCAN-D3(BJ) parameters.\n        \"\"\"\n        self.ref = d3.reference.Reference()\n        if params is None:\n            # r\u00b2SCAN-D3(BJ)\n            self.params = dict(\n                a1=torch.tensor(0.49484001),\n                s8=torch.tensor(0.78981345),\n                a2=torch.tensor(5.73083694),\n            )\n        else:\n            self.params = params\n\n    def run(self, atoms: Atoms):\n        \"\"\"Calculate D3 dispersion energy.\n\n        Parameters\n        ----------\n        atoms : ase.Atoms\n            ASE Atoms object with atomic numbers and positions\n\n        Returns\n        -------\n        torch.Tensor\n            D3 dispersion energy\n        \"\"\"\n        # nframes * natoms\n        numbers = atoms.get_atomic_numbers().reshape(-1, len(atoms))\n        numbers = torch.tensor(numbers, dtype=torch.int64)\n        # nframes * 3 * natoms\n        positions = atoms.get_positions().reshape(-1, len(atoms), 3)\n        positions = torch.tensor(positions)\n\n        cn = d3.ncoord.cn_d3(numbers, positions)\n        weights = d3.model.weight_references(numbers, cn, self.ref)\n        c6 = d3.model.atomic_c6(numbers, weights, self.ref)\n        energy = d3.disp.dispersion(numbers, positions, self.params, c6)\n        return energy.sum()\n</code></pre>"},{"location":"api/#toolbox.calculator.d3.D3Calculator.__init__","title":"<code>__init__(params=None)</code>","text":"<p>Initialize D3Calculator.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Optional[Dict]</code> <p>D3 parameters dictionary, by default None. If None, uses r\u00b2SCAN-D3(BJ) parameters.</p> <code>None</code> Source code in <code>toolbox/calculator/d3.py</code> <pre><code>def __init__(self, params: Optional[dict] = None) -&gt; None:\n    \"\"\"Initialize D3Calculator.\n\n    Parameters\n    ----------\n    params : Optional[Dict], optional\n        D3 parameters dictionary, by default None.\n        If None, uses r\u00b2SCAN-D3(BJ) parameters.\n    \"\"\"\n    self.ref = d3.reference.Reference()\n    if params is None:\n        # r\u00b2SCAN-D3(BJ)\n        self.params = dict(\n            a1=torch.tensor(0.49484001),\n            s8=torch.tensor(0.78981345),\n            a2=torch.tensor(5.73083694),\n        )\n    else:\n        self.params = params\n</code></pre>"},{"location":"api/#toolbox.calculator.d3.D3Calculator.run","title":"<code>run(atoms)</code>","text":"<p>Calculate D3 dispersion energy.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object with atomic numbers and positions</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>D3 dispersion energy</p> Source code in <code>toolbox/calculator/d3.py</code> <pre><code>def run(self, atoms: Atoms):\n    \"\"\"Calculate D3 dispersion energy.\n\n    Parameters\n    ----------\n    atoms : ase.Atoms\n        ASE Atoms object with atomic numbers and positions\n\n    Returns\n    -------\n    torch.Tensor\n        D3 dispersion energy\n    \"\"\"\n    # nframes * natoms\n    numbers = atoms.get_atomic_numbers().reshape(-1, len(atoms))\n    numbers = torch.tensor(numbers, dtype=torch.int64)\n    # nframes * 3 * natoms\n    positions = atoms.get_positions().reshape(-1, len(atoms), 3)\n    positions = torch.tensor(positions)\n\n    cn = d3.ncoord.cn_d3(numbers, positions)\n    weights = d3.model.weight_references(numbers, cn, self.ref)\n    c6 = d3.model.atomic_c6(numbers, weights, self.ref)\n    energy = d3.disp.dispersion(numbers, positions, self.params, c6)\n    return energy.sum()\n</code></pre>"},{"location":"api/#deep-potential-calculator","title":"Deep Potential Calculator","text":""},{"location":"api/#toolbox.calculator.dp","title":"<code>toolbox.calculator.dp</code>","text":"<p>Deep Potential dispatcher module.</p> <p>This module provides classes for dispatching Deep Potential calculations to HPC systems using dpdispatcher.</p>"},{"location":"api/#toolbox.calculator.dp.CP2KDPDispatcher","title":"<code>CP2KDPDispatcher</code>","text":"<p>               Bases: <code>DPDispatcher</code></p> <p>Dispatcher for running CP2K calculations with Deep Potential.</p> <p>This class extends DPDispatcher to provide specific functionality for CP2K calculations with version-specific configurations.</p> Source code in <code>toolbox/calculator/dp.py</code> <pre><code>class CP2KDPDispatcher(DPDispatcher):\n    \"\"\"Dispatcher for running CP2K calculations with Deep Potential.\n\n    This class extends DPDispatcher to provide specific functionality\n    for CP2K calculations with version-specific configurations.\n    \"\"\"\n\n    def __init__(self, work_dir=\".\", v9: bool = False) -&gt; None:\n        \"\"\"Initialize CP2KDPDispatcher.\n\n        Parameters\n        ----------\n        work_dir : str, optional\n            Working directory for calculations, by default \".\"\n        v9 : bool, optional\n            Whether to use CP2K v9 configuration, by default False\n        \"\"\"\n        super().__init__(work_dir)\n        self.v9 = v9\n\n    def _setup(self, machine_setup=None, resources_setup=None):\n        \"\"\"Set up CP2K-specific machine and resources configuration.\n\n        Parameters\n        ----------\n        machine_setup : dict, optional\n            Machine configuration overrides, by default {}\n        resources_setup : dict, optional\n            Resources configuration overrides, by default {}\n        \"\"\"\n        if resources_setup is None:\n            resources_setup = {}\n        if machine_setup is None:\n            machine_setup = {}\n        if self.v9:\n            _resources_setup = {\n                \"custom_flags\": [\"#SBATCH -J cp2k\"],\n                \"module_list\": [\"mkl/latest\", \"mpi/latest\", \"gcc/9.3.0\", \"cp2k/9.1\"],\n            }\n        else:\n            _resources_setup = {\n                \"custom_flags\": [\"#SBATCH -J cp2k\"],\n                \"module_list\": [\n                    \"mpi/intel/2017.5.239\",\n                    \"intel/17.5.239\",\n                    \"gcc/7.4.0\",\n                    \"cp2k/7.1\",\n                ],\n            }\n        _resources_setup.update(resources_setup)\n        super()._setup(machine_setup, _resources_setup)\n\n    def run(self, dnames, machine_setup=None, resources_setup=None, task_setup=None):\n        \"\"\"Run CP2K calculations on specified directories.\n\n        Parameters\n        ----------\n        dnames : list\n            List of directory names to run calculations in\n        machine_setup : dict, optional\n            Machine configuration overrides, by default {}\n        resources_setup : dict, optional\n            Resources configuration overrides, by default {}\n        task_setup : dict, optional\n            Task configuration overrides, by default {}\n        \"\"\"\n        if task_setup is None:\n            task_setup = {}\n        if resources_setup is None:\n            resources_setup = {}\n        if machine_setup is None:\n            machine_setup = {}\n        _task_setup = {\n            \"command\": \"mpiexec.hydra cp2k.popt input.inp\",\n            \"forward_files\": [\"input.inp\", \"coord.xyz\"],\n            \"backward_files\": [\n                \"output\",\n                \"cp2k-v_hartree-1_0.cube\",\n                \"cp2k-ELECTRON_DENSITY-1_0.cube\",\n                \"cp2k-TOTAL_DENSITY-1_0.cube\",\n                \"cp2k-RESTART.wfn\",\n            ],\n            \"outlog\": \"output\",\n        }\n        _task_setup.update(task_setup)\n        super().run(dnames, machine_setup, resources_setup, _task_setup)\n</code></pre>"},{"location":"api/#toolbox.calculator.dp.CP2KDPDispatcher.__init__","title":"<code>__init__(work_dir='.', v9=False)</code>","text":"<p>Initialize CP2KDPDispatcher.</p> <p>Parameters:</p> Name Type Description Default <code>work_dir</code> <code>str</code> <p>Working directory for calculations, by default \".\"</p> <code>'.'</code> <code>v9</code> <code>bool</code> <p>Whether to use CP2K v9 configuration, by default False</p> <code>False</code> Source code in <code>toolbox/calculator/dp.py</code> <pre><code>def __init__(self, work_dir=\".\", v9: bool = False) -&gt; None:\n    \"\"\"Initialize CP2KDPDispatcher.\n\n    Parameters\n    ----------\n    work_dir : str, optional\n        Working directory for calculations, by default \".\"\n    v9 : bool, optional\n        Whether to use CP2K v9 configuration, by default False\n    \"\"\"\n    super().__init__(work_dir)\n    self.v9 = v9\n</code></pre>"},{"location":"api/#toolbox.calculator.dp.CP2KDPDispatcher.run","title":"<code>run(dnames, machine_setup=None, resources_setup=None, task_setup=None)</code>","text":"<p>Run CP2K calculations on specified directories.</p> <p>Parameters:</p> Name Type Description Default <code>dnames</code> <code>list</code> <p>List of directory names to run calculations in</p> required <code>machine_setup</code> <code>dict</code> <p>Machine configuration overrides, by default {}</p> <code>None</code> <code>resources_setup</code> <code>dict</code> <p>Resources configuration overrides, by default {}</p> <code>None</code> <code>task_setup</code> <code>dict</code> <p>Task configuration overrides, by default {}</p> <code>None</code> Source code in <code>toolbox/calculator/dp.py</code> <pre><code>def run(self, dnames, machine_setup=None, resources_setup=None, task_setup=None):\n    \"\"\"Run CP2K calculations on specified directories.\n\n    Parameters\n    ----------\n    dnames : list\n        List of directory names to run calculations in\n    machine_setup : dict, optional\n        Machine configuration overrides, by default {}\n    resources_setup : dict, optional\n        Resources configuration overrides, by default {}\n    task_setup : dict, optional\n        Task configuration overrides, by default {}\n    \"\"\"\n    if task_setup is None:\n        task_setup = {}\n    if resources_setup is None:\n        resources_setup = {}\n    if machine_setup is None:\n        machine_setup = {}\n    _task_setup = {\n        \"command\": \"mpiexec.hydra cp2k.popt input.inp\",\n        \"forward_files\": [\"input.inp\", \"coord.xyz\"],\n        \"backward_files\": [\n            \"output\",\n            \"cp2k-v_hartree-1_0.cube\",\n            \"cp2k-ELECTRON_DENSITY-1_0.cube\",\n            \"cp2k-TOTAL_DENSITY-1_0.cube\",\n            \"cp2k-RESTART.wfn\",\n        ],\n        \"outlog\": \"output\",\n    }\n    _task_setup.update(task_setup)\n    super().run(dnames, machine_setup, resources_setup, _task_setup)\n</code></pre>"},{"location":"api/#toolbox.calculator.dp.DPDispatcher","title":"<code>DPDispatcher</code>","text":"<p>Dispatcher for running Deep Potential calculations.</p> <p>This class provides functionality to dispatch Deep Potential calculations to HPC systems using dpdispatcher.</p> Source code in <code>toolbox/calculator/dp.py</code> <pre><code>class DPDispatcher:\n    \"\"\"Dispatcher for running Deep Potential calculations.\n\n    This class provides functionality to dispatch Deep Potential\n    calculations to HPC systems using dpdispatcher.\n    \"\"\"\n\n    def __init__(self, work_dir=\".\") -&gt; None:\n        \"\"\"Initialize DPDispatcher.\n\n        Parameters\n        ----------\n        work_dir : str, optional\n            Working directory for calculations, by default \".\"\n        \"\"\"\n        self.work_dir = work_dir\n\n    def _setup(self, machine_setup=None, resources_setup=None):\n        \"\"\"Set up machine and resources configuration.\n\n        Parameters\n        ----------\n        machine_setup : dict, optional\n            Machine configuration overrides, by default {}\n        resources_setup : dict, optional\n            Resources configuration overrides, by default {}\n        \"\"\"\n        if resources_setup is None:\n            resources_setup = {}\n        if machine_setup is None:\n            machine_setup = {}\n        _machine_setup = {\n            \"batch_type\": \"Slurm\",\n            \"context_type\": \"LocalContext\",\n            \"local_root\": \"./\",\n            \"remote_root\": \"/data/jxzhu/nnp/dp_workdir\",\n        }\n        _machine_setup.update(machine_setup)\n        _resources_setup = {\n            \"number_node\": 1,\n            \"cpu_per_node\": 24,\n            \"gpu_per_node\": 0,\n            \"kwargs\": {\"gpu_usage\": False},\n            \"queue_name\": \"c51-large\",\n            \"group_size\": 80,\n            \"module_purge\": True,\n        }\n        _resources_setup.update(resources_setup)\n        self._check_node(_resources_setup)\n\n        self.machine = Machine(**_machine_setup)\n        self.resources = Resources(**_resources_setup)\n\n    def run(self, dnames, machine_setup=None, resources_setup=None, task_setup=None):\n        \"\"\"Run calculations on specified directories.\n\n        Parameters\n        ----------\n        dnames : list\n            List of directory names to run calculations in\n        machine_setup : dict, optional\n            Machine configuration overrides, by default {}\n        resources_setup : dict, optional\n            Resources configuration overrides, by default {}\n        task_setup : dict, optional\n            Task configuration overrides, by default {}\n        \"\"\"\n        if task_setup is None:\n            task_setup = {}\n        if resources_setup is None:\n            resources_setup = {}\n        if machine_setup is None:\n            machine_setup = {}\n        self._setup(machine_setup, resources_setup)\n\n        task_list = []\n        for dname in dnames:\n            task = Task(task_work_path=dname, **task_setup)\n            task_list.append(task)\n\n        submission = Submission(\n            work_base=self.work_dir,\n            machine=self.machine,\n            resources=self.resources,\n            task_list=task_list,\n        )\n        submission.run_submission()\n\n    @staticmethod\n    def _check_node(resources_setup):\n        \"\"\"Check and adjust resources based on queue name.\n\n        Parameters\n        ----------\n        resources_setup : dict\n            Resources configuration to check and modify\n\n        Raises\n        ------\n        AttributeError\n            If queue name is unknown\n        \"\"\"\n        queue = resources_setup[\"queue_name\"]\n\n        if \"c51\" in queue:\n            resources_setup[\"cpu_per_node\"] = 24\n        elif \"c52\" in queue:\n            resources_setup[\"cpu_per_node\"] = 28\n        elif \"c53\" in queue:\n            resources_setup[\"cpu_per_node\"] = 32\n        elif queue == \"cpu\":\n            # add queue in ikkem\n            cpu_per_node = resources_setup.get(\"cpu_per_node\", 64)\n            resources_setup[\"cpu_per_node\"] = cpu_per_node\n        else:\n            raise AttributeError(f\"Unknown queue: {queue}\")\n</code></pre>"},{"location":"api/#toolbox.calculator.dp.DPDispatcher.__init__","title":"<code>__init__(work_dir='.')</code>","text":"<p>Initialize DPDispatcher.</p> <p>Parameters:</p> Name Type Description Default <code>work_dir</code> <code>str</code> <p>Working directory for calculations, by default \".\"</p> <code>'.'</code> Source code in <code>toolbox/calculator/dp.py</code> <pre><code>def __init__(self, work_dir=\".\") -&gt; None:\n    \"\"\"Initialize DPDispatcher.\n\n    Parameters\n    ----------\n    work_dir : str, optional\n        Working directory for calculations, by default \".\"\n    \"\"\"\n    self.work_dir = work_dir\n</code></pre>"},{"location":"api/#toolbox.calculator.dp.DPDispatcher.run","title":"<code>run(dnames, machine_setup=None, resources_setup=None, task_setup=None)</code>","text":"<p>Run calculations on specified directories.</p> <p>Parameters:</p> Name Type Description Default <code>dnames</code> <code>list</code> <p>List of directory names to run calculations in</p> required <code>machine_setup</code> <code>dict</code> <p>Machine configuration overrides, by default {}</p> <code>None</code> <code>resources_setup</code> <code>dict</code> <p>Resources configuration overrides, by default {}</p> <code>None</code> <code>task_setup</code> <code>dict</code> <p>Task configuration overrides, by default {}</p> <code>None</code> Source code in <code>toolbox/calculator/dp.py</code> <pre><code>def run(self, dnames, machine_setup=None, resources_setup=None, task_setup=None):\n    \"\"\"Run calculations on specified directories.\n\n    Parameters\n    ----------\n    dnames : list\n        List of directory names to run calculations in\n    machine_setup : dict, optional\n        Machine configuration overrides, by default {}\n    resources_setup : dict, optional\n        Resources configuration overrides, by default {}\n    task_setup : dict, optional\n        Task configuration overrides, by default {}\n    \"\"\"\n    if task_setup is None:\n        task_setup = {}\n    if resources_setup is None:\n        resources_setup = {}\n    if machine_setup is None:\n        machine_setup = {}\n    self._setup(machine_setup, resources_setup)\n\n    task_list = []\n    for dname in dnames:\n        task = Task(task_work_path=dname, **task_setup)\n        task_list.append(task)\n\n    submission = Submission(\n        work_base=self.work_dir,\n        machine=self.machine,\n        resources=self.resources,\n        task_list=task_list,\n    )\n    submission.run_submission()\n</code></pre>"},{"location":"api/#electric-potential-calculator","title":"Electric Potential Calculator","text":""},{"location":"api/#toolbox.calculator.elecpot","title":"<code>toolbox.calculator.elecpot</code>","text":"<p>Electrostatic potential calculator module.</p> <p>This module provides classes for calculating electrostatic potential from charge density using various boundary conditions.</p> <p>Reference: - https://altafang.com/2020/10/13/calculating-1d-electrostatic-potential-profile-from-md-simulations/ - Code from Justina Moss (Leiden University, Email: j.h.moss@lic.leidenuniv.nl) - https://github.com/SINGROUP/Potential_solver.</p>"},{"location":"api/#toolbox.calculator.elecpot.ElecPotentialCalculator","title":"<code>ElecPotentialCalculator</code>","text":"<p>Calculator for 1D electrostatic potential from charge density.</p> <p>This calculator computes electrostatic potential from charge density using various boundary conditions.</p> <p>Parameters:</p> Name Type Description Default <code>charge</code> <code>array_like</code> <p>Charge density in e/\u00c5\u00b3</p> required <code>grid</code> <code>array_like</code> <p>Grid points in \u00c5</p> required <p>Returns:</p> Type Description <code>Electrostatic potential in eV</code> <p>(different from Hartree potential with a negative sign!)</p> Source code in <code>toolbox/calculator/elecpot.py</code> <pre><code>class ElecPotentialCalculator:\n    \"\"\"Calculator for 1D electrostatic potential from charge density.\n\n    This calculator computes electrostatic potential from charge density\n    using various boundary conditions.\n\n    Parameters\n    ----------\n    charge : array_like\n        Charge density in e/\u00c5\u00b3\n    grid : array_like\n        Grid points in \u00c5\n\n    Returns\n    -------\n    Electrostatic potential in eV\n        (different from Hartree potential with a negative sign!)\n    \"\"\"\n\n    def __init__(self, charge, grid) -&gt; None:\n        \"\"\"Initialize ElecPotentialCalculator.\n\n        Parameters\n        ----------\n        charge : array_like\n            Charge density in e/\u00c5\u00b3\n        grid : array_like\n            Grid points in \u00c5\n        \"\"\"\n        if len(grid) != len(charge):\n            raise AttributeError(\"Grid and charge should have the same dimension.\")\n        self.grid = grid\n        self.charge = charge\n\n    def calculate(self, bc=\"periodic\", **kwargs):\n        \"\"\"Calculate electrostatic potential.\n\n        Parameters\n        ----------\n        bc : str, optional\n            Boundary condition, by default \"periodic\"\n            Options: \"periodic\", \"open\", \"dirichlet\", \"neumann\", \"dip_cor\"\n        **kwargs\n            Additional keyword arguments for specific boundary conditions\n\n        Returns\n        -------\n        array_like\n            Electrostatic potential in V\n\n        Raises\n        ------\n        AttributeError\n            If boundary condition is not supported\n        \"\"\"\n        if (not hasattr(self, \"int1\")) or (not hasattr(self, \"int2\")):\n            self._integrate()\n        self.bc = bc\n        try:\n            self.potential = getattr(self, f\"_calculate_{bc}\")(**kwargs)\n            return self.potential\n        except AttributeError as e:\n            raise AttributeError(f\"Unsupported boundary condition {bc}\") from e\n\n    def _integrate(self):\n        \"\"\"Perform double integration of charge density.\"\"\"\n        self.int1 = integrate.cumulative_trapezoid(self.charge, self.grid, initial=0)\n        self.int2 = (\n            -integrate.cumulative_trapezoid(self.int1, self.grid, initial=0) / EPSILON\n        )\n\n    def _calculate_periodic(self, l_box):\n        \"\"\"Calculate potential with periodic boundary conditions.\n\n        Parameters\n        ----------\n        l_box : float\n            Box length in \u00c5\n        \"\"\"\n        phi = self.solve_fft_poisson(l_box)\n        return phi\n\n    def _calculate_open(self):\n        \"\"\"Calculate potential with open boundary conditions.\"\"\"\n        return self.int2\n\n    def _calculate_dirichlet(self):\n        \"\"\"Calculate potential with Dirichlet boundary conditions.\n\n        Raises\n        ------\n        NotImplementedError\n            This method is not implemented\n        \"\"\"\n        raise NotImplementedError\n\n    def _calculate_neumann(self):\n        \"\"\"Calculate potential with Neumann boundary conditions.\n\n        Raises\n        ------\n        NotImplementedError\n            This method is not implemented\n        \"\"\"\n        raise NotImplementedError\n\n    def _calculate_dip_cor(self, cell):\n        \"\"\"Calculate potential with dipole correction.\n\n        Parameters\n        ----------\n        cell : array_like\n            Unit cell vectors or parameters\n\n        Returns\n        -------\n        array_like\n            Potential with dipole correction applied\n        \"\"\"\n        if np.shape(cell) == (3,):\n            cell = np.diag(cell)\n        elif np.shape(cell) == (6,):\n            cell = cellpar_to_cell(cell)\n        elif np.shape(cell) == (3, 3):\n            pass\n        else:\n            raise AttributeError(\"\")\n\n        z_max = cell[2][2]\n        phi = self._calculate_periodic(z_max)\n        cross_area = np.linalg.norm(np.cross(cell[0], cell[1]))\n        surf_pol = np.sum(self.grid * self.charge) / cross_area\n        v_cor = surf_pol / EPSILON * (self.grid / z_max - 0.5)\n        return phi + v_cor\n\n    def solve_fft_poisson(self, l_box):\n        \"\"\"Solve Poisson equation using FFT.\n\n        Parameters\n        ----------\n        l_box : float\n            Box length in \u00c5\n\n        Returns\n        -------\n        array_like\n            Electrostatic potential\n        \"\"\"\n        n_grid = len(self.grid)\n        grid_spacing = l_box / n_grid\n\n        start = time.process_time()\n        charge_k_space = np.fft.fft(self.charge)\n        end = time.process_time()\n        print(f\"| | FFT took {end - start} s\")\n\n        start = time.process_time()\n        pot_k_space = np.zeros(n_grid, dtype=complex)\n        k = np.fft.fftfreq(n_grid, grid_spacing)\n        k_squared = k**2\n        pot_k_space[1:] = charge_k_space[1:] / k_squared[1:]\n        pot_k_space = pot_k_space / (4.0 * np.pi * np.pi * EPSILON)\n        end = time.process_time()\n        print(f\"| | k-space arithmetics took {end - start} s\")\n\n        start = time.process_time()\n        pot_grid = np.fft.ifftn(pot_k_space).real\n        end = time.process_time()\n        print(f\"| | Inverse FFT took {end - start} s\")\n        return pot_grid\n</code></pre>"},{"location":"api/#toolbox.calculator.elecpot.ElecPotentialCalculator.__init__","title":"<code>__init__(charge, grid)</code>","text":"<p>Initialize ElecPotentialCalculator.</p> <p>Parameters:</p> Name Type Description Default <code>charge</code> <code>array_like</code> <p>Charge density in e/\u00c5\u00b3</p> required <code>grid</code> <code>array_like</code> <p>Grid points in \u00c5</p> required Source code in <code>toolbox/calculator/elecpot.py</code> <pre><code>def __init__(self, charge, grid) -&gt; None:\n    \"\"\"Initialize ElecPotentialCalculator.\n\n    Parameters\n    ----------\n    charge : array_like\n        Charge density in e/\u00c5\u00b3\n    grid : array_like\n        Grid points in \u00c5\n    \"\"\"\n    if len(grid) != len(charge):\n        raise AttributeError(\"Grid and charge should have the same dimension.\")\n    self.grid = grid\n    self.charge = charge\n</code></pre>"},{"location":"api/#toolbox.calculator.elecpot.ElecPotentialCalculator.calculate","title":"<code>calculate(bc='periodic', **kwargs)</code>","text":"<p>Calculate electrostatic potential.</p> <p>Parameters:</p> Name Type Description Default <code>bc</code> <code>str</code> <p>Boundary condition, by default \"periodic\" Options: \"periodic\", \"open\", \"dirichlet\", \"neumann\", \"dip_cor\"</p> <code>'periodic'</code> <code>**kwargs</code> <p>Additional keyword arguments for specific boundary conditions</p> <code>{}</code> <p>Returns:</p> Type Description <code>array_like</code> <p>Electrostatic potential in V</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If boundary condition is not supported</p> Source code in <code>toolbox/calculator/elecpot.py</code> <pre><code>def calculate(self, bc=\"periodic\", **kwargs):\n    \"\"\"Calculate electrostatic potential.\n\n    Parameters\n    ----------\n    bc : str, optional\n        Boundary condition, by default \"periodic\"\n        Options: \"periodic\", \"open\", \"dirichlet\", \"neumann\", \"dip_cor\"\n    **kwargs\n        Additional keyword arguments for specific boundary conditions\n\n    Returns\n    -------\n    array_like\n        Electrostatic potential in V\n\n    Raises\n    ------\n    AttributeError\n        If boundary condition is not supported\n    \"\"\"\n    if (not hasattr(self, \"int1\")) or (not hasattr(self, \"int2\")):\n        self._integrate()\n    self.bc = bc\n    try:\n        self.potential = getattr(self, f\"_calculate_{bc}\")(**kwargs)\n        return self.potential\n    except AttributeError as e:\n        raise AttributeError(f\"Unsupported boundary condition {bc}\") from e\n</code></pre>"},{"location":"api/#toolbox.calculator.elecpot.ElecPotentialCalculator.solve_fft_poisson","title":"<code>solve_fft_poisson(l_box)</code>","text":"<p>Solve Poisson equation using FFT.</p> <p>Parameters:</p> Name Type Description Default <code>l_box</code> <code>float</code> <p>Box length in \u00c5</p> required <p>Returns:</p> Type Description <code>array_like</code> <p>Electrostatic potential</p> Source code in <code>toolbox/calculator/elecpot.py</code> <pre><code>def solve_fft_poisson(self, l_box):\n    \"\"\"Solve Poisson equation using FFT.\n\n    Parameters\n    ----------\n    l_box : float\n        Box length in \u00c5\n\n    Returns\n    -------\n    array_like\n        Electrostatic potential\n    \"\"\"\n    n_grid = len(self.grid)\n    grid_spacing = l_box / n_grid\n\n    start = time.process_time()\n    charge_k_space = np.fft.fft(self.charge)\n    end = time.process_time()\n    print(f\"| | FFT took {end - start} s\")\n\n    start = time.process_time()\n    pot_k_space = np.zeros(n_grid, dtype=complex)\n    k = np.fft.fftfreq(n_grid, grid_spacing)\n    k_squared = k**2\n    pot_k_space[1:] = charge_k_space[1:] / k_squared[1:]\n    pot_k_space = pot_k_space / (4.0 * np.pi * np.pi * EPSILON)\n    end = time.process_time()\n    print(f\"| | k-space arithmetics took {end - start} s\")\n\n    start = time.process_time()\n    pot_grid = np.fft.ifftn(pot_k_space).real\n    end = time.process_time()\n    print(f\"| | Inverse FFT took {end - start} s\")\n    return pot_grid\n</code></pre>"},{"location":"api/#toolbox.calculator.elecpot.GaussianElecPotentialCalculator","title":"<code>GaussianElecPotentialCalculator</code>","text":"<p>Calculator for electrostatic potential from Gaussian charge distributions.</p> <p>This calculator computes electrostatic potential from atoms represented as Gaussian charge distributions.</p> Source code in <code>toolbox/calculator/elecpot.py</code> <pre><code>class GaussianElecPotentialCalculator:\n    \"\"\"Calculator for electrostatic potential from Gaussian charge distributions.\n\n    This calculator computes electrostatic potential from atoms\n    represented as Gaussian charge distributions.\n    \"\"\"\n\n    def __init__(\n        self,\n        grids: np.ndarray,\n        l_box: float,\n        cross_area: float,\n        spread_dict: Optional[dict[str, float]] = None,\n        charge_dict: Optional[dict[str, float]] = None,\n    ) -&gt; None:\n        \"\"\"Initialize GaussianElecPotentialCalculator.\n\n        Parameters\n        ----------\n        grids : np.ndarray\n            Grid points in \u00c5\n        l_box : float\n            Box length in \u00c5\n        cross_area : float\n            Cross-sectional area in \u00c5\u00b2\n        spread_dict : Optional[Dict[str, float]], optional\n            Dictionary of Gaussian spreads for each element, by default None\n        charge_dict : Optional[Dict[str, float]], optional\n            Dictionary of charges for each element, by default None\n        \"\"\"\n        # setup grid\n        self.l_box = l_box\n        self.grids = grids\n        self.grid_edges = np.linspace(0.0, self.l_box, len(self.grids) + 1)\n        dx = np.diff(self.grid_edges)[0]\n        self.grid_volume = cross_area * dx\n\n        self.spread_dict = spread_dict\n        self.charge_dict = charge_dict\n\n    def calc_rho(\n        self,\n        mu: np.ndarray,\n        spread: np.ndarray,\n        charge: np.ndarray,\n    ):\n        \"\"\"Calculate charge density from Gaussian distributions.\n\n        Parameters\n        ----------\n        mu : np.ndarray\n            Centers of Gaussian distributions\n        spread : np.ndarray\n            Spreads of Gaussian distributions\n        charge : np.ndarray\n            Charges of Gaussian distributions\n\n        Returns\n        -------\n        np.ndarray\n            Charge density on the grid\n        \"\"\"\n        grid_edges = np.reshape(self.grid_edges, (1, -1))\n        spread = np.reshape(spread, [-1, 1])\n        mu = np.reshape(mu, [-1, 1])\n        charge = np.reshape(charge, [-1, 1])\n\n        # nat * ngrid\n        out = gaussian_int(grid_edges[:, 1:], mu, spread) - gaussian_int(\n            grid_edges[:, :-1], mu, spread\n        )\n        out = np.sum(out * charge, axis=0)\n        # deal with periodic boundary\n        # left image\n        l_out = gaussian_int(grid_edges[:, 1:] - self.l_box, mu, spread) - gaussian_int(\n            grid_edges[:, :-1] - self.l_box, mu, spread\n        )\n        l_out = np.sum(l_out * charge, axis=0)\n        out += l_out\n        # right image\n        r_out = gaussian_int(grid_edges[:, 1:] + self.l_box, mu, spread) - gaussian_int(\n            grid_edges[:, :-1] + self.l_box, mu, spread\n        )\n        r_out = np.sum(r_out * charge, axis=0)\n        out += r_out\n\n        np.testing.assert_almost_equal(out.sum(), charge.sum())\n\n        rho = out / self.grid_volume\n        return rho\n\n    def run(\n        self,\n        mu: Optional[np.ndarray] = None,\n        spread: Optional[np.ndarray] = None,\n        charge: Optional[np.ndarray] = None,\n        atoms: Optional[Atoms] = None,\n    ):\n        \"\"\"Calculate electrostatic potential from Gaussian charge distributions.\n\n        Parameters\n        ----------\n        mu : Optional[np.ndarray], optional\n            Centers of Gaussian distributions, by default None\n        spread : Optional[np.ndarray], optional\n            Spreads of Gaussian distributions, by default None\n        charge : Optional[np.ndarray], optional\n            Charges of Gaussian distributions, by default None\n        atoms : Optional[Atoms], optional\n            ASE Atoms object, by default None\n\n        Returns\n        -------\n        np.ndarray\n            Electrostatic potential\n        \"\"\"\n        if mu is None:\n            mu = atoms.get_positions()[:, 2]\n        if spread is None:\n            assert self.spread_dict is not None, \"spread_dict is not set\"\n            spread = np.array([self.spread_dict[s] for s in atoms.symbols])\n        if charge is None:\n            if self.charge_dict is not None:\n                charge = np.array([self.charge_dict[s] for s in atoms.symbols])\n            else:\n                charge = atoms.get_initial_charges()\n\n        rho = self.calc_rho(mu, spread, charge)\n        calculator = ElecPotentialCalculator(rho, self.grids)\n        phi = calculator.calculate(l_box=self.l_box)\n        return phi\n</code></pre>"},{"location":"api/#toolbox.calculator.elecpot.GaussianElecPotentialCalculator.__init__","title":"<code>__init__(grids, l_box, cross_area, spread_dict=None, charge_dict=None)</code>","text":"<p>Initialize GaussianElecPotentialCalculator.</p> <p>Parameters:</p> Name Type Description Default <code>grids</code> <code>ndarray</code> <p>Grid points in \u00c5</p> required <code>l_box</code> <code>float</code> <p>Box length in \u00c5</p> required <code>cross_area</code> <code>float</code> <p>Cross-sectional area in \u00c5\u00b2</p> required <code>spread_dict</code> <code>Optional[Dict[str, float]]</code> <p>Dictionary of Gaussian spreads for each element, by default None</p> <code>None</code> <code>charge_dict</code> <code>Optional[Dict[str, float]]</code> <p>Dictionary of charges for each element, by default None</p> <code>None</code> Source code in <code>toolbox/calculator/elecpot.py</code> <pre><code>def __init__(\n    self,\n    grids: np.ndarray,\n    l_box: float,\n    cross_area: float,\n    spread_dict: Optional[dict[str, float]] = None,\n    charge_dict: Optional[dict[str, float]] = None,\n) -&gt; None:\n    \"\"\"Initialize GaussianElecPotentialCalculator.\n\n    Parameters\n    ----------\n    grids : np.ndarray\n        Grid points in \u00c5\n    l_box : float\n        Box length in \u00c5\n    cross_area : float\n        Cross-sectional area in \u00c5\u00b2\n    spread_dict : Optional[Dict[str, float]], optional\n        Dictionary of Gaussian spreads for each element, by default None\n    charge_dict : Optional[Dict[str, float]], optional\n        Dictionary of charges for each element, by default None\n    \"\"\"\n    # setup grid\n    self.l_box = l_box\n    self.grids = grids\n    self.grid_edges = np.linspace(0.0, self.l_box, len(self.grids) + 1)\n    dx = np.diff(self.grid_edges)[0]\n    self.grid_volume = cross_area * dx\n\n    self.spread_dict = spread_dict\n    self.charge_dict = charge_dict\n</code></pre>"},{"location":"api/#toolbox.calculator.elecpot.GaussianElecPotentialCalculator.calc_rho","title":"<code>calc_rho(mu, spread, charge)</code>","text":"<p>Calculate charge density from Gaussian distributions.</p> <p>Parameters:</p> Name Type Description Default <code>mu</code> <code>ndarray</code> <p>Centers of Gaussian distributions</p> required <code>spread</code> <code>ndarray</code> <p>Spreads of Gaussian distributions</p> required <code>charge</code> <code>ndarray</code> <p>Charges of Gaussian distributions</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Charge density on the grid</p> Source code in <code>toolbox/calculator/elecpot.py</code> <pre><code>def calc_rho(\n    self,\n    mu: np.ndarray,\n    spread: np.ndarray,\n    charge: np.ndarray,\n):\n    \"\"\"Calculate charge density from Gaussian distributions.\n\n    Parameters\n    ----------\n    mu : np.ndarray\n        Centers of Gaussian distributions\n    spread : np.ndarray\n        Spreads of Gaussian distributions\n    charge : np.ndarray\n        Charges of Gaussian distributions\n\n    Returns\n    -------\n    np.ndarray\n        Charge density on the grid\n    \"\"\"\n    grid_edges = np.reshape(self.grid_edges, (1, -1))\n    spread = np.reshape(spread, [-1, 1])\n    mu = np.reshape(mu, [-1, 1])\n    charge = np.reshape(charge, [-1, 1])\n\n    # nat * ngrid\n    out = gaussian_int(grid_edges[:, 1:], mu, spread) - gaussian_int(\n        grid_edges[:, :-1], mu, spread\n    )\n    out = np.sum(out * charge, axis=0)\n    # deal with periodic boundary\n    # left image\n    l_out = gaussian_int(grid_edges[:, 1:] - self.l_box, mu, spread) - gaussian_int(\n        grid_edges[:, :-1] - self.l_box, mu, spread\n    )\n    l_out = np.sum(l_out * charge, axis=0)\n    out += l_out\n    # right image\n    r_out = gaussian_int(grid_edges[:, 1:] + self.l_box, mu, spread) - gaussian_int(\n        grid_edges[:, :-1] + self.l_box, mu, spread\n    )\n    r_out = np.sum(r_out * charge, axis=0)\n    out += r_out\n\n    np.testing.assert_almost_equal(out.sum(), charge.sum())\n\n    rho = out / self.grid_volume\n    return rho\n</code></pre>"},{"location":"api/#toolbox.calculator.elecpot.GaussianElecPotentialCalculator.run","title":"<code>run(mu=None, spread=None, charge=None, atoms=None)</code>","text":"<p>Calculate electrostatic potential from Gaussian charge distributions.</p> <p>Parameters:</p> Name Type Description Default <code>mu</code> <code>Optional[ndarray]</code> <p>Centers of Gaussian distributions, by default None</p> <code>None</code> <code>spread</code> <code>Optional[ndarray]</code> <p>Spreads of Gaussian distributions, by default None</p> <code>None</code> <code>charge</code> <code>Optional[ndarray]</code> <p>Charges of Gaussian distributions, by default None</p> <code>None</code> <code>atoms</code> <code>Optional[Atoms]</code> <p>ASE Atoms object, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Electrostatic potential</p> Source code in <code>toolbox/calculator/elecpot.py</code> <pre><code>def run(\n    self,\n    mu: Optional[np.ndarray] = None,\n    spread: Optional[np.ndarray] = None,\n    charge: Optional[np.ndarray] = None,\n    atoms: Optional[Atoms] = None,\n):\n    \"\"\"Calculate electrostatic potential from Gaussian charge distributions.\n\n    Parameters\n    ----------\n    mu : Optional[np.ndarray], optional\n        Centers of Gaussian distributions, by default None\n    spread : Optional[np.ndarray], optional\n        Spreads of Gaussian distributions, by default None\n    charge : Optional[np.ndarray], optional\n        Charges of Gaussian distributions, by default None\n    atoms : Optional[Atoms], optional\n        ASE Atoms object, by default None\n\n    Returns\n    -------\n    np.ndarray\n        Electrostatic potential\n    \"\"\"\n    if mu is None:\n        mu = atoms.get_positions()[:, 2]\n    if spread is None:\n        assert self.spread_dict is not None, \"spread_dict is not set\"\n        spread = np.array([self.spread_dict[s] for s in atoms.symbols])\n    if charge is None:\n        if self.charge_dict is not None:\n            charge = np.array([self.charge_dict[s] for s in atoms.symbols])\n        else:\n            charge = atoms.get_initial_charges()\n\n    rho = self.calc_rho(mu, spread, charge)\n    calculator = ElecPotentialCalculator(rho, self.grids)\n    phi = calculator.calculate(l_box=self.l_box)\n    return phi\n</code></pre>"},{"location":"api/#toolbox.calculator.elecpot.WannierHartreePotentialCalculator","title":"<code>WannierHartreePotentialCalculator</code>","text":"<p>               Bases: <code>GaussianElecPotentialCalculator</code></p> <p>Calculator for Hartree potential from Wannier functions.</p> <p>This calculator extends GaussianElecPotentialCalculator to compute Hartree potential from Wannier functions.</p> Source code in <code>toolbox/calculator/elecpot.py</code> <pre><code>class WannierHartreePotentialCalculator(GaussianElecPotentialCalculator):\n    \"\"\"Calculator for Hartree potential from Wannier functions.\n\n    This calculator extends GaussianElecPotentialCalculator to\n    compute Hartree potential from Wannier functions.\n    \"\"\"\n\n    def __init__(\n        self,\n        grids: np.ndarray,\n        l_box: float,\n        cross_area: float,\n        spread_dict: Optional[dict[str, float]] = None,\n        charge_dict: Optional[dict[str, float]] = None,\n    ) -&gt; None:\n        \"\"\"Initialize WannierHartreePotentialCalculator.\n\n        Parameters\n        ----------\n        grids : np.ndarray\n            Grid points in \u00c5\n        l_box : float\n            Box length in \u00c5\n        cross_area : float\n            Cross-sectional area in \u00c5\u00b2\n        spread_dict : Optional[Dict[str, float]], optional\n            Dictionary of Gaussian spreads for each element, by default None\n        charge_dict : Optional[Dict[str, float]], optional\n            Dictionary of charges for each element, by default None\n        \"\"\"\n        super().__init__(grids, l_box, cross_area, spread_dict, charge_dict)\n\n    def run(\n        self,\n        mu: Optional[np.ndarray] = None,\n        spread: Optional[np.ndarray] = None,\n        charge: Optional[np.ndarray] = None,\n        atoms: Optional[Atoms] = None,\n        dname: Optional[str] = None,\n        fname_coord: Optional[str] = \"coord.xyz\",\n        fname_wannier: Optional[str] = \"wannier.xyz\",\n    ):\n        \"\"\"Calculate Hartree potential from Wannier functions.\n\n        Parameters\n        ----------\n        mu : Optional[np.ndarray], optional\n            Centers of Gaussian distributions, by default None\n        spread : Optional[np.ndarray], optional\n            Spreads of Gaussian distributions, by default None\n        charge : Optional[np.ndarray], optional\n            Charges of Gaussian distributions, by default None\n        atoms : Optional[Atoms], optional\n            ASE Atoms object, by default None\n        dname : Optional[str], optional\n            Directory name containing coordinate files, by default None\n        fname_coord : Optional[str], optional\n            Coordinate file name, by default \"coord.xyz\"\n        fname_wannier : Optional[str], optional\n            Wannier coordinate file name, by default \"wannier.xyz\"\n\n        Returns\n        -------\n        np.ndarray\n            Negative of the electrostatic potential (Hartree potential)\n        \"\"\"\n        if dname is not None:\n            _atoms = io.read(os.path.join(dname, fname_coord))\n            wannier_atoms = io.read(os.path.join(dname, fname_wannier))\n            atoms = _atoms + wannier_atoms\n            atoms.set_pbc(True)\n            atoms.wrap()\n\n        phi = super().run(mu, spread, charge, atoms)\n        return -phi\n</code></pre>"},{"location":"api/#toolbox.calculator.elecpot.WannierHartreePotentialCalculator.__init__","title":"<code>__init__(grids, l_box, cross_area, spread_dict=None, charge_dict=None)</code>","text":"<p>Initialize WannierHartreePotentialCalculator.</p> <p>Parameters:</p> Name Type Description Default <code>grids</code> <code>ndarray</code> <p>Grid points in \u00c5</p> required <code>l_box</code> <code>float</code> <p>Box length in \u00c5</p> required <code>cross_area</code> <code>float</code> <p>Cross-sectional area in \u00c5\u00b2</p> required <code>spread_dict</code> <code>Optional[Dict[str, float]]</code> <p>Dictionary of Gaussian spreads for each element, by default None</p> <code>None</code> <code>charge_dict</code> <code>Optional[Dict[str, float]]</code> <p>Dictionary of charges for each element, by default None</p> <code>None</code> Source code in <code>toolbox/calculator/elecpot.py</code> <pre><code>def __init__(\n    self,\n    grids: np.ndarray,\n    l_box: float,\n    cross_area: float,\n    spread_dict: Optional[dict[str, float]] = None,\n    charge_dict: Optional[dict[str, float]] = None,\n) -&gt; None:\n    \"\"\"Initialize WannierHartreePotentialCalculator.\n\n    Parameters\n    ----------\n    grids : np.ndarray\n        Grid points in \u00c5\n    l_box : float\n        Box length in \u00c5\n    cross_area : float\n        Cross-sectional area in \u00c5\u00b2\n    spread_dict : Optional[Dict[str, float]], optional\n        Dictionary of Gaussian spreads for each element, by default None\n    charge_dict : Optional[Dict[str, float]], optional\n        Dictionary of charges for each element, by default None\n    \"\"\"\n    super().__init__(grids, l_box, cross_area, spread_dict, charge_dict)\n</code></pre>"},{"location":"api/#toolbox.calculator.elecpot.WannierHartreePotentialCalculator.run","title":"<code>run(mu=None, spread=None, charge=None, atoms=None, dname=None, fname_coord='coord.xyz', fname_wannier='wannier.xyz')</code>","text":"<p>Calculate Hartree potential from Wannier functions.</p> <p>Parameters:</p> Name Type Description Default <code>mu</code> <code>Optional[ndarray]</code> <p>Centers of Gaussian distributions, by default None</p> <code>None</code> <code>spread</code> <code>Optional[ndarray]</code> <p>Spreads of Gaussian distributions, by default None</p> <code>None</code> <code>charge</code> <code>Optional[ndarray]</code> <p>Charges of Gaussian distributions, by default None</p> <code>None</code> <code>atoms</code> <code>Optional[Atoms]</code> <p>ASE Atoms object, by default None</p> <code>None</code> <code>dname</code> <code>Optional[str]</code> <p>Directory name containing coordinate files, by default None</p> <code>None</code> <code>fname_coord</code> <code>Optional[str]</code> <p>Coordinate file name, by default \"coord.xyz\"</p> <code>'coord.xyz'</code> <code>fname_wannier</code> <code>Optional[str]</code> <p>Wannier coordinate file name, by default \"wannier.xyz\"</p> <code>'wannier.xyz'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Negative of the electrostatic potential (Hartree potential)</p> Source code in <code>toolbox/calculator/elecpot.py</code> <pre><code>def run(\n    self,\n    mu: Optional[np.ndarray] = None,\n    spread: Optional[np.ndarray] = None,\n    charge: Optional[np.ndarray] = None,\n    atoms: Optional[Atoms] = None,\n    dname: Optional[str] = None,\n    fname_coord: Optional[str] = \"coord.xyz\",\n    fname_wannier: Optional[str] = \"wannier.xyz\",\n):\n    \"\"\"Calculate Hartree potential from Wannier functions.\n\n    Parameters\n    ----------\n    mu : Optional[np.ndarray], optional\n        Centers of Gaussian distributions, by default None\n    spread : Optional[np.ndarray], optional\n        Spreads of Gaussian distributions, by default None\n    charge : Optional[np.ndarray], optional\n        Charges of Gaussian distributions, by default None\n    atoms : Optional[Atoms], optional\n        ASE Atoms object, by default None\n    dname : Optional[str], optional\n        Directory name containing coordinate files, by default None\n    fname_coord : Optional[str], optional\n        Coordinate file name, by default \"coord.xyz\"\n    fname_wannier : Optional[str], optional\n        Wannier coordinate file name, by default \"wannier.xyz\"\n\n    Returns\n    -------\n    np.ndarray\n        Negative of the electrostatic potential (Hartree potential)\n    \"\"\"\n    if dname is not None:\n        _atoms = io.read(os.path.join(dname, fname_coord))\n        wannier_atoms = io.read(os.path.join(dname, fname_wannier))\n        atoms = _atoms + wannier_atoms\n        atoms.set_pbc(True)\n        atoms.wrap()\n\n    phi = super().run(mu, spread, charge, atoms)\n    return -phi\n</code></pre>"},{"location":"api/#lammps-calculator","title":"LAMMPS Calculator","text":""},{"location":"api/#toolbox.calculator.lammps","title":"<code>toolbox.calculator.lammps</code>","text":"<p>LAMMPS calculator module.</p> <p>This module provides a calculator for running LAMMPS molecular dynamics simulations, extending the BashCalculator class.</p>"},{"location":"api/#toolbox.calculator.lammps.LammpsCalculator","title":"<code>LammpsCalculator</code>","text":"<p>               Bases: <code>BashCalculator</code></p> <p>A calculator for running LAMMPS molecular dynamics simulations.</p> <p>This class extends BashCalculator to provide specific functionality for LAMMPS calculations, including completion checking.</p> Source code in <code>toolbox/calculator/lammps.py</code> <pre><code>class LammpsCalculator(BashCalculator):\n    \"\"\"A calculator for running LAMMPS molecular dynamics simulations.\n\n    This class extends BashCalculator to provide specific functionality for\n    LAMMPS calculations, including completion checking.\n    \"\"\"\n\n    def __init__(self, work_dir) -&gt; None:\n        \"\"\"Initialize LammpsCalculator.\n\n        Parameters\n        ----------\n        work_dir : str\n            The working directory where LAMMPS calculations will be executed\n        \"\"\"\n        super().__init__(work_dir)\n\n    def run(\n        self,\n        command: str = \"lmp\",\n        stdin: str = \"input.lmp\",\n        stdout: str = \"lammps.stdout\",\n        stderr: str = \"lammps.stderr\",\n        mpi_command: str = \"mpiexec.hydra\",\n        ignore_finished_tag=False,\n        modifier: str = None,\n    ):\n        \"\"\"Run a LAMMPS calculation.\n\n        Parameters\n        ----------\n        command : str, optional\n            LAMMPS executable command, by default \"lmp\"\n        stdin : str, optional\n            Input file name, by default \"input.lmp\"\n        stdout : str, optional\n            Standard output file name, by default \"lammps.stdout\"\n        stderr : str, optional\n            Standard error file name, by default \"lammps.stderr\"\n        mpi_command : str, optional\n            MPI command to use, by default \"mpiexec.hydra\"\n        ignore_finished_tag : bool, optional\n            Whether to ignore existing finished tag, by default False\n        modifier : str, optional\n            Additional command modifiers, by default None\n\n        Notes\n        -----\n        For more information on LAMMPS run options, see:\n        https://docs.lammps.org/Run_options.html\n        \"\"\"\n        stdin = \"-i \" + stdin\n        if modifier is not None:\n            stdin += f\" {modifier} \"\n        super().run(command, stdin, stdout, stderr, mpi_command, ignore_finished_tag)\n\n    @staticmethod\n    def _make_finished_tag(stdout):\n        \"\"\"Create a finished tag after successful LAMMPS calculation.\n\n        Parameters\n        ----------\n        stdout : str\n            Name of LAMMPS output file to check for completion\n        \"\"\"\n        with open(stdout, \"rb\") as f:\n            offset = -50\n            while True:\n                f.seek(offset, 2)\n                lines = f.readlines()\n                if len(lines) &gt;= 2:\n                    last_line = lines[-1]\n                    break\n                offset *= 2\n\n        pattern = re.compile(r\"Total wall time\")\n        if pattern.search(last_line.decode()) is not None:\n            with open(os.path.join(\"finished_tag\"), \"w\") as f:\n                pass\n        else:\n            warning_msg = \"LAMMPS calculation does not finish!\"\n            logging.warning(warning_msg)\n</code></pre>"},{"location":"api/#toolbox.calculator.lammps.LammpsCalculator.__init__","title":"<code>__init__(work_dir)</code>","text":"<p>Initialize LammpsCalculator.</p> <p>Parameters:</p> Name Type Description Default <code>work_dir</code> <code>str</code> <p>The working directory where LAMMPS calculations will be executed</p> required Source code in <code>toolbox/calculator/lammps.py</code> <pre><code>def __init__(self, work_dir) -&gt; None:\n    \"\"\"Initialize LammpsCalculator.\n\n    Parameters\n    ----------\n    work_dir : str\n        The working directory where LAMMPS calculations will be executed\n    \"\"\"\n    super().__init__(work_dir)\n</code></pre>"},{"location":"api/#toolbox.calculator.lammps.LammpsCalculator.run","title":"<code>run(command='lmp', stdin='input.lmp', stdout='lammps.stdout', stderr='lammps.stderr', mpi_command='mpiexec.hydra', ignore_finished_tag=False, modifier=None)</code>","text":"<p>Run a LAMMPS calculation.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>LAMMPS executable command, by default \"lmp\"</p> <code>'lmp'</code> <code>stdin</code> <code>str</code> <p>Input file name, by default \"input.lmp\"</p> <code>'input.lmp'</code> <code>stdout</code> <code>str</code> <p>Standard output file name, by default \"lammps.stdout\"</p> <code>'lammps.stdout'</code> <code>stderr</code> <code>str</code> <p>Standard error file name, by default \"lammps.stderr\"</p> <code>'lammps.stderr'</code> <code>mpi_command</code> <code>str</code> <p>MPI command to use, by default \"mpiexec.hydra\"</p> <code>'mpiexec.hydra'</code> <code>ignore_finished_tag</code> <code>bool</code> <p>Whether to ignore existing finished tag, by default False</p> <code>False</code> <code>modifier</code> <code>str</code> <p>Additional command modifiers, by default None</p> <code>None</code> Notes <p>For more information on LAMMPS run options, see: https://docs.lammps.org/Run_options.html</p> Source code in <code>toolbox/calculator/lammps.py</code> <pre><code>def run(\n    self,\n    command: str = \"lmp\",\n    stdin: str = \"input.lmp\",\n    stdout: str = \"lammps.stdout\",\n    stderr: str = \"lammps.stderr\",\n    mpi_command: str = \"mpiexec.hydra\",\n    ignore_finished_tag=False,\n    modifier: str = None,\n):\n    \"\"\"Run a LAMMPS calculation.\n\n    Parameters\n    ----------\n    command : str, optional\n        LAMMPS executable command, by default \"lmp\"\n    stdin : str, optional\n        Input file name, by default \"input.lmp\"\n    stdout : str, optional\n        Standard output file name, by default \"lammps.stdout\"\n    stderr : str, optional\n        Standard error file name, by default \"lammps.stderr\"\n    mpi_command : str, optional\n        MPI command to use, by default \"mpiexec.hydra\"\n    ignore_finished_tag : bool, optional\n        Whether to ignore existing finished tag, by default False\n    modifier : str, optional\n        Additional command modifiers, by default None\n\n    Notes\n    -----\n    For more information on LAMMPS run options, see:\n    https://docs.lammps.org/Run_options.html\n    \"\"\"\n    stdin = \"-i \" + stdin\n    if modifier is not None:\n        stdin += f\" {modifier} \"\n    super().run(command, stdin, stdout, stderr, mpi_command, ignore_finished_tag)\n</code></pre>"},{"location":"api/#io-module","title":"I/O Module","text":""},{"location":"api/#ase-logger","title":"ASE Logger","text":""},{"location":"api/#toolbox.io.ase_logger","title":"<code>toolbox.io.ase_logger</code>","text":"<p>ASE MD Logger module.</p> <p>This module provides an extended MDLogger class that can write trajectory files during molecular dynamics simulations.</p>"},{"location":"api/#toolbox.io.ase_logger.MDLogger","title":"<code>MDLogger</code>","text":"<p>               Bases: <code>MDLogger</code></p> <p>Extended MD Logger for ASE molecular dynamics.</p> <p>This class extends ASE's MDLogger to provide additional functionality for writing trajectory files during MD simulations.</p> Source code in <code>toolbox/io/ase_logger.py</code> <pre><code>class MDLogger(_MDLogger):\n    \"\"\"Extended MD Logger for ASE molecular dynamics.\n\n    This class extends ASE's MDLogger to provide additional functionality\n    for writing trajectory files during MD simulations.\n    \"\"\"\n\n    def __init__(\n        self,\n        dyn: Any,  # not fully annotated so far to avoid a circular import\n        atoms: Atoms,\n        logfile: Union[IO, str],\n        fname: str,\n        write_kwargs: Optional[Dict] = None,\n        **kwargs,\n    ):\n        if write_kwargs is None:\n            write_kwargs = {}\n        super().__init__(dyn, atoms, logfile, **kwargs)\n        self.fname = fname\n        self.write_kwargs = write_kwargs\n\n    def __call__(self):\n        \"\"\"Write trajectory data to file.\n\n        This method is called during MD simulation to write the current\n        atomic configuration to the specified file.\n        \"\"\"\n        super().__call__()\n        self.atoms.write(self.fname, append=True, **self.write_kwargs)\n</code></pre>"},{"location":"api/#toolbox.io.ase_logger.MDLogger.__call__","title":"<code>__call__()</code>","text":"<p>Write trajectory data to file.</p> <p>This method is called during MD simulation to write the current atomic configuration to the specified file.</p> Source code in <code>toolbox/io/ase_logger.py</code> <pre><code>def __call__(self):\n    \"\"\"Write trajectory data to file.\n\n    This method is called during MD simulation to write the current\n    atomic configuration to the specified file.\n    \"\"\"\n    super().__call__()\n    self.atoms.write(self.fname, append=True, **self.write_kwargs)\n</code></pre>"},{"location":"api/#bpnn-io","title":"BPNN I/O","text":""},{"location":"api/#toolbox.io.bpnn","title":"<code>toolbox.io.bpnn</code>","text":"<p>BPNN data reader module.</p> <p>This module provides functionality to read BPNN (Behler-Parrinello Neural Network) data files for machine learning potentials.</p>"},{"location":"api/#toolbox.io.bpnn.read_data","title":"<code>read_data(fname='input.data')</code>","text":"<p>Read BPNN data file.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Path to BPNN data file, by default \"input.data\"</p> <code>'input.data'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (box, coord, charge, symbol, energy, force) where: - box: array of box parameters with shape (n_frames, 9) - coord: array of coordinates with shape (n_frames, n_atoms*3) - charge: array of charges with shape (n_frames, n_atoms) - symbol: list of element symbols for each frame - energy: array of energies with shape (n_frames,) - force: array of forces with shape (n_frames, n_atoms*3)</p> Source code in <code>toolbox/io/bpnn.py</code> <pre><code>def read_data(fname=\"input.data\"):\n    \"\"\"Read BPNN data file.\n\n    Parameters\n    ----------\n    fname : str, optional\n        Path to BPNN data file, by default \"input.data\"\n\n    Returns\n    -------\n    tuple\n        Tuple of (box, coord, charge, symbol, energy, force) where:\n        - box: array of box parameters with shape (n_frames, 9)\n        - coord: array of coordinates with shape (n_frames, n_atoms*3)\n        - charge: array of charges with shape (n_frames, n_atoms)\n        - symbol: list of element symbols for each frame\n        - energy: array of energies with shape (n_frames,)\n        - force: array of forces with shape (n_frames, n_atoms*3)\n    \"\"\"\n    box = []\n    coord = []\n    charge = []\n    symbol = []\n    energy = []\n    force = []\n\n    flag = False\n    count = 0\n    _symbol = []\n    with open(fname, encoding=\"UTF-8\") as f:\n        lines = f.readlines()\n        for line in lines:\n            line = line.strip()\n            if line == \"begin\":\n                flag = True\n                count = count + 1\n            if line == \"end\":\n                flag = False\n                symbol.append(_symbol)\n                _symbol = []\n            if flag is False:\n                continue\n            line = line.split()\n            if line[0] == \"lattice\":\n                box.append(line[1:])\n            if line[0] == \"atom\":\n                coord.append(line[1:4])\n                charge.append(line[5])\n                force.append(line[7:10])\n                _symbol.append(line[4])\n            if line[0] == \"energy\":\n                energy.append(line[1])\n\n    box = np.array(box, dtype=np.float64)\n    if len(box) &gt; 0:\n        box = np.reshape(box, (count, 9)) * AU_TO_ANG\n    charge = np.array(charge, dtype=np.float64)\n    charge = np.reshape(charge, (count, -1))\n    coord = np.array(coord, dtype=np.float64)\n    coord = np.reshape(coord, (count, -1)) * AU_TO_ANG\n    energy = np.array(energy, dtype=np.float64) * AU_TO_EV\n    force = np.array(force, dtype=np.float64)\n    force = np.reshape(force, (count, -1)) * AU_TO_EV / AU_TO_ANG\n\n    return box, coord, charge, symbol, energy, force\n</code></pre>"},{"location":"api/#system-builder","title":"System Builder","text":""},{"location":"api/#toolbox.io.build","title":"<code>toolbox.io.build</code>","text":"<p>Molecular system building module.</p> <p>This module provides classes and functions for building molecular systems, including solution boxes, interfaces, and adding ions or molecules to existing systems.</p>"},{"location":"api/#toolbox.io.build.ElectrolyteBox","title":"<code>ElectrolyteBox</code>","text":"<p>               Bases: <code>WaterBox</code></p> <p>Class for electrolyte solution box configuration.</p> <p>This class extends WaterBox to handle uniform electrolyte solutions with specified solutes and concentrations.</p> <p>Parameters:</p> Name Type Description Default <code>boundary</code> <code>Union[List, ndarray]</code> <p>Box dimensions as [a, b, c] or [[a1, a2], [b1, b2], [c1, c2]]</p> required <code>solutes</code> <code>Dict[str, float]</code> <p>Dictionary mapping solute names to concentrations in mol/L</p> required Source code in <code>toolbox/io/build.py</code> <pre><code>class ElectrolyteBox(WaterBox):\n    \"\"\"Class for electrolyte solution box configuration.\n\n    This class extends WaterBox to handle uniform electrolyte\n    solutions with specified solutes and concentrations.\n\n    Parameters\n    ----------\n    boundary : Union[List, np.ndarray]\n        Box dimensions as [a, b, c] or [[a1, a2], [b1, b2], [c1, c2]]\n    solutes : Dict[str, float]\n        Dictionary mapping solute names to concentrations in mol/L\n    \"\"\"\n\n    def __init__(\n        self,\n        boundary: Union[List, np.ndarray],\n        solutes: dict[str, float],\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Initialize ElectrolyteBox.\n\n        Parameters\n        ----------\n        boundary : Union[List, np.ndarray]\n            Box dimensions\n        solutes : Dict[str, float]\n            Dictionary mapping solute names to concentrations in mol/L\n        **kwargs\n            Additional keyword arguments passed to parent class\n        \"\"\"\n        super().__init__(boundary, **kwargs)\n        self.solutes = solutes\n\n    def write(\n        self,\n        fname,\n        n_wat: Optional[int] = None,\n        seed: int = -1,\n        verbose=False,\n        **kwargs,\n    ):\n        \"\"\"Write electrolyte box configuration to file.\n\n        Parameters\n        ----------\n        fname : str\n            Output filename\n        n_wat : Optional[int], optional\n            Number of water molecules. If None, uses calculated value from density\n        seed : int, optional\n            Random seed for reproducible molecule placement. Use -1 for random behavior\n        verbose : bool, optional\n            If True, keeps temporary files, by default False\n        **kwargs\n            Additional keyword arguments passed to ase.io.write\n        \"\"\"\n        atoms = build.molecule(\"H2O\")\n        io.write(\"tmp.pdb\", atoms)\n        water = mda.Universe(\"tmp.pdb\")\n\n        if n_wat is None:\n            n_wat = self.n_wat\n\n        structures = [\n            mdapackmol.PackmolStructure(\n                water,\n                number=n_wat,\n                instructions=[f\"inside box {self.boundary_string}\", f\"seed {seed}\"],\n            )\n        ]\n        for k, v in self.solutes.items():\n            fnames = glob.glob(os.path.join(os.path.dirname(__file__), f\"ion_structure_lib/*/{k}.*\"))\n            if len(fnames) &gt; 0:\n                atoms = io.read(fnames[0])\n            else:\n                atoms = Atoms(k, positions=[[0, 0, 0]])\n            io.write(\"tmp.pdb\", atoms)\n            solute = mda.Universe(\"tmp.pdb\")\n            structures.append(\n                mdapackmol.PackmolStructure(\n                    solute,\n                    number=int(n_wat / 55.6 * v),\n                    instructions=[f\"inside box {self.boundary_string}\", f\"seed {seed}\"],\n                )\n            )\n\n        system = mdapackmol.packmol(structures)\n        system.atoms.write(fname, **kwargs)\n        if not verbose:\n            os.remove(\"tmp.pdb\")\n            os.remove(\"packmol.stdout\")\n</code></pre>"},{"location":"api/#toolbox.io.build.ElectrolyteBox.__init__","title":"<code>__init__(boundary, solutes, **kwargs)</code>","text":"<p>Initialize ElectrolyteBox.</p> <p>Parameters:</p> Name Type Description Default <code>boundary</code> <code>Union[List, ndarray]</code> <p>Box dimensions</p> required <code>solutes</code> <code>Dict[str, float]</code> <p>Dictionary mapping solute names to concentrations in mol/L</p> required <code>**kwargs</code> <p>Additional keyword arguments passed to parent class</p> <code>{}</code> Source code in <code>toolbox/io/build.py</code> <pre><code>def __init__(\n    self,\n    boundary: Union[List, np.ndarray],\n    solutes: dict[str, float],\n    **kwargs,\n) -&gt; None:\n    \"\"\"Initialize ElectrolyteBox.\n\n    Parameters\n    ----------\n    boundary : Union[List, np.ndarray]\n        Box dimensions\n    solutes : Dict[str, float]\n        Dictionary mapping solute names to concentrations in mol/L\n    **kwargs\n        Additional keyword arguments passed to parent class\n    \"\"\"\n    super().__init__(boundary, **kwargs)\n    self.solutes = solutes\n</code></pre>"},{"location":"api/#toolbox.io.build.ElectrolyteBox.write","title":"<code>write(fname, n_wat=None, seed=-1, verbose=False, **kwargs)</code>","text":"<p>Write electrolyte box configuration to file.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Output filename</p> required <code>n_wat</code> <code>Optional[int]</code> <p>Number of water molecules. If None, uses calculated value from density</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed for reproducible molecule placement. Use -1 for random behavior</p> <code>-1</code> <code>verbose</code> <code>bool</code> <p>If True, keeps temporary files, by default False</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments passed to ase.io.write</p> <code>{}</code> Source code in <code>toolbox/io/build.py</code> <pre><code>def write(\n    self,\n    fname,\n    n_wat: Optional[int] = None,\n    seed: int = -1,\n    verbose=False,\n    **kwargs,\n):\n    \"\"\"Write electrolyte box configuration to file.\n\n    Parameters\n    ----------\n    fname : str\n        Output filename\n    n_wat : Optional[int], optional\n        Number of water molecules. If None, uses calculated value from density\n    seed : int, optional\n        Random seed for reproducible molecule placement. Use -1 for random behavior\n    verbose : bool, optional\n        If True, keeps temporary files, by default False\n    **kwargs\n        Additional keyword arguments passed to ase.io.write\n    \"\"\"\n    atoms = build.molecule(\"H2O\")\n    io.write(\"tmp.pdb\", atoms)\n    water = mda.Universe(\"tmp.pdb\")\n\n    if n_wat is None:\n        n_wat = self.n_wat\n\n    structures = [\n        mdapackmol.PackmolStructure(\n            water,\n            number=n_wat,\n            instructions=[f\"inside box {self.boundary_string}\", f\"seed {seed}\"],\n        )\n    ]\n    for k, v in self.solutes.items():\n        fnames = glob.glob(os.path.join(os.path.dirname(__file__), f\"ion_structure_lib/*/{k}.*\"))\n        if len(fnames) &gt; 0:\n            atoms = io.read(fnames[0])\n        else:\n            atoms = Atoms(k, positions=[[0, 0, 0]])\n        io.write(\"tmp.pdb\", atoms)\n        solute = mda.Universe(\"tmp.pdb\")\n        structures.append(\n            mdapackmol.PackmolStructure(\n                solute,\n                number=int(n_wat / 55.6 * v),\n                instructions=[f\"inside box {self.boundary_string}\", f\"seed {seed}\"],\n            )\n        )\n\n    system = mdapackmol.packmol(structures)\n    system.atoms.write(fname, **kwargs)\n    if not verbose:\n        os.remove(\"tmp.pdb\")\n        os.remove(\"packmol.stdout\")\n</code></pre>"},{"location":"api/#toolbox.io.build.Interface","title":"<code>Interface</code>","text":"<p>Class for creating interface systems.</p> <p>This class creates interface systems between a slab and water box for electrochemical simulations.</p> Source code in <code>toolbox/io/build.py</code> <pre><code>class Interface:\n    \"\"\"Class for creating interface systems.\n\n    This class creates interface systems between a slab\n    and water box for electrochemical simulations.\n    \"\"\"\n\n    def __init__(\n        self,\n        slab: Atoms,\n        l_water: float = 30,\n    ) -&gt; None:\n        \"\"\"Initialize Interface.\n\n        Parameters\n        ----------\n        slab : ase.Atoms\n            Slab atoms object\n        l_water : float, optional\n            Length of water box in \u00c5, by default 30\n        \"\"\"\n        # shift half cell and wrap\n        coord = slab.get_positions()\n        z = coord[:, 2]\n        l_slab = z.max() - z.min()\n        a = slab.get_cell()[0][0]\n        b = slab.get_cell()[1][1]\n        c = l_slab + l_water\n        new_cell = [a, b, c]\n        shift_z = -z.min() - l_slab / 2\n        coord[:, 2] += shift_z\n        slab = Atoms(\n            slab.get_chemical_symbols(), positions=coord, cell=new_cell, pbc=True\n        )\n        slab.wrap()\n\n        self.slab = slab\n        self.boundary = [[0, a], [0, b], [l_slab / 2, l_slab / 2 + l_water]]\n\n    def run(\n        self,\n        rho: float = 1.0,\n        n_wat: Optional[int] = None,\n        seed: int = -1,\n        sol: Optional[SolutionBox] = None,\n        verbose=False,\n    ) -&gt; Atoms:\n        \"\"\"Create interface system.\n\n        Parameters\n        ----------\n        rho : float, optional\n            Water density in g/cm\u00b3, by default 1.0\n        n_wat : Optional[int], optional\n            Number of water molecules, by default None\n        seed : int, optional\n            Random seed, by default -1\n        sol : Optional[SolutionBox], optional\n            Solution box object, by default None\n        verbose : bool, optional\n            If True, keeps temporary files, by default False\n\n        Returns\n        -------\n        ase.Atoms\n            Combined interface system\n        \"\"\"\n        if sol is None:\n            sol = WaterBox(\n                rho=rho,\n                boundary=self.boundary,\n                slit=[1.0, 1.0, 2.5],\n            )\n        sol.write(\"waterbox.xyz\", n_wat=n_wat, verbose=verbose, seed=seed)\n        waterbox = io.read(\"waterbox.xyz\")\n        waterbox.set_cell(self.slab.get_cell())\n        waterbox.set_pbc(True)\n        waterbox.center(axis=2)\n\n        self.atoms = waterbox + self.slab\n        # self.atoms.set_cell(self.slab.get_cell())\n        self.atoms.set_pbc(True)\n        if not verbose:\n            os.remove(\"waterbox.xyz\")\n        return self.atoms\n</code></pre>"},{"location":"api/#toolbox.io.build.Interface.__init__","title":"<code>__init__(slab, l_water=30)</code>","text":"<p>Initialize Interface.</p> <p>Parameters:</p> Name Type Description Default <code>slab</code> <code>Atoms</code> <p>Slab atoms object</p> required <code>l_water</code> <code>float</code> <p>Length of water box in \u00c5, by default 30</p> <code>30</code> Source code in <code>toolbox/io/build.py</code> <pre><code>def __init__(\n    self,\n    slab: Atoms,\n    l_water: float = 30,\n) -&gt; None:\n    \"\"\"Initialize Interface.\n\n    Parameters\n    ----------\n    slab : ase.Atoms\n        Slab atoms object\n    l_water : float, optional\n        Length of water box in \u00c5, by default 30\n    \"\"\"\n    # shift half cell and wrap\n    coord = slab.get_positions()\n    z = coord[:, 2]\n    l_slab = z.max() - z.min()\n    a = slab.get_cell()[0][0]\n    b = slab.get_cell()[1][1]\n    c = l_slab + l_water\n    new_cell = [a, b, c]\n    shift_z = -z.min() - l_slab / 2\n    coord[:, 2] += shift_z\n    slab = Atoms(\n        slab.get_chemical_symbols(), positions=coord, cell=new_cell, pbc=True\n    )\n    slab.wrap()\n\n    self.slab = slab\n    self.boundary = [[0, a], [0, b], [l_slab / 2, l_slab / 2 + l_water]]\n</code></pre>"},{"location":"api/#toolbox.io.build.Interface.run","title":"<code>run(rho=1.0, n_wat=None, seed=-1, sol=None, verbose=False)</code>","text":"<p>Create interface system.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>float</code> <p>Water density in g/cm\u00b3, by default 1.0</p> <code>1.0</code> <code>n_wat</code> <code>Optional[int]</code> <p>Number of water molecules, by default None</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed, by default -1</p> <code>-1</code> <code>sol</code> <code>Optional[SolutionBox]</code> <p>Solution box object, by default None</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If True, keeps temporary files, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>Atoms</code> <p>Combined interface system</p> Source code in <code>toolbox/io/build.py</code> <pre><code>def run(\n    self,\n    rho: float = 1.0,\n    n_wat: Optional[int] = None,\n    seed: int = -1,\n    sol: Optional[SolutionBox] = None,\n    verbose=False,\n) -&gt; Atoms:\n    \"\"\"Create interface system.\n\n    Parameters\n    ----------\n    rho : float, optional\n        Water density in g/cm\u00b3, by default 1.0\n    n_wat : Optional[int], optional\n        Number of water molecules, by default None\n    seed : int, optional\n        Random seed, by default -1\n    sol : Optional[SolutionBox], optional\n        Solution box object, by default None\n    verbose : bool, optional\n        If True, keeps temporary files, by default False\n\n    Returns\n    -------\n    ase.Atoms\n        Combined interface system\n    \"\"\"\n    if sol is None:\n        sol = WaterBox(\n            rho=rho,\n            boundary=self.boundary,\n            slit=[1.0, 1.0, 2.5],\n        )\n    sol.write(\"waterbox.xyz\", n_wat=n_wat, verbose=verbose, seed=seed)\n    waterbox = io.read(\"waterbox.xyz\")\n    waterbox.set_cell(self.slab.get_cell())\n    waterbox.set_pbc(True)\n    waterbox.center(axis=2)\n\n    self.atoms = waterbox + self.slab\n    # self.atoms.set_cell(self.slab.get_cell())\n    self.atoms.set_pbc(True)\n    if not verbose:\n        os.remove(\"waterbox.xyz\")\n    return self.atoms\n</code></pre>"},{"location":"api/#toolbox.io.build.SolutionBox","title":"<code>SolutionBox</code>","text":"<p>Base class for solution box configuration.</p> <p>This class defines the boundary conditions for solution systems with optional slit geometry.</p> <p>Parameters:</p> Name Type Description Default <code>boundary</code> <code>Union[List, ndarray]</code> <p>Box dimensions as [a, b, c] or [[a1, a2], [b1, b2], [c1, c2]]</p> required <code>slit</code> <code>Union[float, List, ndarray]</code> <p>Slit distance or dimensions, by default 1.0</p> <code>1.0</code> Source code in <code>toolbox/io/build.py</code> <pre><code>class SolutionBox:\n    \"\"\"Base class for solution box configuration.\n\n    This class defines the boundary conditions for solution\n    systems with optional slit geometry.\n\n    Parameters\n    ----------\n    boundary : Union[List, np.ndarray]\n        Box dimensions as [a, b, c] or [[a1, a2], [b1, b2], [c1, c2]]\n    slit : Union[float, List, np.ndarray], optional\n        Slit distance or dimensions, by default 1.0\n    \"\"\"\n\n    def __init__(\n        self,\n        boundary: Union[List, np.ndarray],\n        slit: Union[float, List, np.ndarray] = 1.0,\n    ) -&gt; None:\n        \"\"\"Initialize SolutionBox.\n\n        Parameters\n        ----------\n        boundary : Union[List, np.ndarray]\n            Box dimensions\n        slit : Union[float, List, np.ndarray], optional\n            Slit distance or dimensions, by default 1.0\n        \"\"\"\n        boundary = np.array(boundary)\n        assert len(boundary) == 3\n        _boundary = np.reshape(boundary, (3, -1))\n        # [[a1, a2], [b1, b2], [c1, c2]]\n        if len(_boundary[0]) == 1:\n            self.boundary = np.concatenate([np.zeros((3, 1)), _boundary], axis=-1)\n        elif len(_boundary[0]) == 2:\n            self.boundary = _boundary\n        else:\n            raise AttributeError(\n                \"boundary must be [a, b, c] or [[a1, a2], [b1, b2], [c1, c2]]\"\n            )\n\n        slit = np.reshape(slit, (-1))\n        b = self.boundary.copy()\n        if (len(slit) == 1) or (len(slit) == 3):\n            b[:, 0] += slit\n            b[:, 1] -= slit\n        else:\n            raise AttributeError(\"\")\n        self.boundary_string = np.array2string(np.transpose(b).flatten())[1:-1]\n</code></pre>"},{"location":"api/#toolbox.io.build.SolutionBox.__init__","title":"<code>__init__(boundary, slit=1.0)</code>","text":"<p>Initialize SolutionBox.</p> <p>Parameters:</p> Name Type Description Default <code>boundary</code> <code>Union[List, ndarray]</code> <p>Box dimensions</p> required <code>slit</code> <code>Union[float, List, ndarray]</code> <p>Slit distance or dimensions, by default 1.0</p> <code>1.0</code> Source code in <code>toolbox/io/build.py</code> <pre><code>def __init__(\n    self,\n    boundary: Union[List, np.ndarray],\n    slit: Union[float, List, np.ndarray] = 1.0,\n) -&gt; None:\n    \"\"\"Initialize SolutionBox.\n\n    Parameters\n    ----------\n    boundary : Union[List, np.ndarray]\n        Box dimensions\n    slit : Union[float, List, np.ndarray], optional\n        Slit distance or dimensions, by default 1.0\n    \"\"\"\n    boundary = np.array(boundary)\n    assert len(boundary) == 3\n    _boundary = np.reshape(boundary, (3, -1))\n    # [[a1, a2], [b1, b2], [c1, c2]]\n    if len(_boundary[0]) == 1:\n        self.boundary = np.concatenate([np.zeros((3, 1)), _boundary], axis=-1)\n    elif len(_boundary[0]) == 2:\n        self.boundary = _boundary\n    else:\n        raise AttributeError(\n            \"boundary must be [a, b, c] or [[a1, a2], [b1, b2], [c1, c2]]\"\n        )\n\n    slit = np.reshape(slit, (-1))\n    b = self.boundary.copy()\n    if (len(slit) == 1) or (len(slit) == 3):\n        b[:, 0] += slit\n        b[:, 1] -= slit\n    else:\n        raise AttributeError(\"\")\n    self.boundary_string = np.array2string(np.transpose(b).flatten())[1:-1]\n</code></pre>"},{"location":"api/#toolbox.io.build.WaterBox","title":"<code>WaterBox</code>","text":"<p>               Bases: <code>SolutionBox</code></p> <p>Class for water box configuration.</p> <p>This class extends SolutionBox to specifically handle water molecules with density calculations.</p> <p>Parameters:</p> Name Type Description Default <code>boundary</code> <code>Union[List, ndarray]</code> <p>Box dimensions as [a, b, c] or [[a1, a2], [b1, b2], [c1, c2]]</p> required <code>slit</code> <code>Union[float, List, ndarray]</code> <p>Slit distance or dimensions, by default 1.0</p> <code>1.0</code> <code>rho</code> <code>float</code> <p>Water density in g/cm\u00b3</p> <code>1.0</code> Source code in <code>toolbox/io/build.py</code> <pre><code>class WaterBox(SolutionBox):\n    \"\"\"Class for water box configuration.\n\n    This class extends SolutionBox to specifically handle\n    water molecules with density calculations.\n\n    Parameters\n    ----------\n    boundary : Union[List, np.ndarray]\n        Box dimensions as [a, b, c] or [[a1, a2], [b1, b2], [c1, c2]]\n    slit : Union[float, List, np.ndarray], optional\n        Slit distance or dimensions, by default 1.0\n    rho : float\n        Water density in g/cm\u00b3\n    \"\"\"\n\n    def __init__(\n        self,\n        boundary: Union[List, np.ndarray],\n        slit: Union[float, List, np.ndarray] = 1.0,\n        rho: float = 1.0,\n    ) -&gt; None:\n        \"\"\"Initialize WaterBox.\n\n        Parameters\n        ----------\n        boundary : Union[List, np.ndarray]\n            Box dimensions\n        slit : Union[float, List, np.ndarray], optional\n            Slit distance or dimensions, by default 1.0\n        rho : float, optional\n            Water density in g/cm\u00b3, by default 1.0\n        \"\"\"\n        super().__init__(boundary, slit)\n\n        volume = np.prod(np.diff(self.boundary, axis=-1))\n        self.n_wat = calc_water_number(rho, volume)\n\n    def write(\n        self,\n        fname,\n        n_wat: Optional[int] = None,\n        seed: int = -1,\n        verbose: bool = False,\n        **kwargs,\n    ):\n        \"\"\"Write water box configuration to file.\n\n        Parameters\n        ----------\n        fname : str\n            Output filename\n        n_wat : Optional[int], optional\n            Number of water molecules. If None, uses calculated value from density\n        seed : int, optional\n            Random seed for reproducible molecule placement. Use -1 for random behavior\n        verbose : bool, optional\n            If True, keeps temporary files, by default False\n        **kwargs\n            Additional keyword arguments passed to ase.io.write\n        \"\"\"\n        atoms = build.molecule(\"H2O\")\n        io.write(\"water.pdb\", atoms)\n        water = mda.Universe(\"water.pdb\")\n\n        if n_wat is None:\n            n_wat = self.n_wat\n\n        system = mdapackmol.packmol(\n            [\n                mdapackmol.PackmolStructure(\n                    water,\n                    number=n_wat,\n                    instructions=[f\"inside box {self.boundary_string}\", f\"seed {seed}\"],\n                )\n            ]\n        )\n        system.atoms.write(fname, **kwargs)\n        if not verbose:\n            os.remove(\"water.pdb\")\n            os.remove(\"packmol.stdout\")\n</code></pre>"},{"location":"api/#toolbox.io.build.WaterBox.__init__","title":"<code>__init__(boundary, slit=1.0, rho=1.0)</code>","text":"<p>Initialize WaterBox.</p> <p>Parameters:</p> Name Type Description Default <code>boundary</code> <code>Union[List, ndarray]</code> <p>Box dimensions</p> required <code>slit</code> <code>Union[float, List, ndarray]</code> <p>Slit distance or dimensions, by default 1.0</p> <code>1.0</code> <code>rho</code> <code>float</code> <p>Water density in g/cm\u00b3, by default 1.0</p> <code>1.0</code> Source code in <code>toolbox/io/build.py</code> <pre><code>def __init__(\n    self,\n    boundary: Union[List, np.ndarray],\n    slit: Union[float, List, np.ndarray] = 1.0,\n    rho: float = 1.0,\n) -&gt; None:\n    \"\"\"Initialize WaterBox.\n\n    Parameters\n    ----------\n    boundary : Union[List, np.ndarray]\n        Box dimensions\n    slit : Union[float, List, np.ndarray], optional\n        Slit distance or dimensions, by default 1.0\n    rho : float, optional\n        Water density in g/cm\u00b3, by default 1.0\n    \"\"\"\n    super().__init__(boundary, slit)\n\n    volume = np.prod(np.diff(self.boundary, axis=-1))\n    self.n_wat = calc_water_number(rho, volume)\n</code></pre>"},{"location":"api/#toolbox.io.build.WaterBox.write","title":"<code>write(fname, n_wat=None, seed=-1, verbose=False, **kwargs)</code>","text":"<p>Write water box configuration to file.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Output filename</p> required <code>n_wat</code> <code>Optional[int]</code> <p>Number of water molecules. If None, uses calculated value from density</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed for reproducible molecule placement. Use -1 for random behavior</p> <code>-1</code> <code>verbose</code> <code>bool</code> <p>If True, keeps temporary files, by default False</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments passed to ase.io.write</p> <code>{}</code> Source code in <code>toolbox/io/build.py</code> <pre><code>def write(\n    self,\n    fname,\n    n_wat: Optional[int] = None,\n    seed: int = -1,\n    verbose: bool = False,\n    **kwargs,\n):\n    \"\"\"Write water box configuration to file.\n\n    Parameters\n    ----------\n    fname : str\n        Output filename\n    n_wat : Optional[int], optional\n        Number of water molecules. If None, uses calculated value from density\n    seed : int, optional\n        Random seed for reproducible molecule placement. Use -1 for random behavior\n    verbose : bool, optional\n        If True, keeps temporary files, by default False\n    **kwargs\n        Additional keyword arguments passed to ase.io.write\n    \"\"\"\n    atoms = build.molecule(\"H2O\")\n    io.write(\"water.pdb\", atoms)\n    water = mda.Universe(\"water.pdb\")\n\n    if n_wat is None:\n        n_wat = self.n_wat\n\n    system = mdapackmol.packmol(\n        [\n            mdapackmol.PackmolStructure(\n                water,\n                number=n_wat,\n                instructions=[f\"inside box {self.boundary_string}\", f\"seed {seed}\"],\n            )\n        ]\n    )\n    system.atoms.write(fname, **kwargs)\n    if not verbose:\n        os.remove(\"water.pdb\")\n        os.remove(\"packmol.stdout\")\n</code></pre>"},{"location":"api/#toolbox.io.build.add_ion","title":"<code>add_ion(atoms, ion, region, cutoff=2.0, max_trial=500)</code>","text":"<p>Add an ion to atoms system in specified region.</p> <p>This function attempts to place an ion in the specified region without overlapping with existing atoms.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>Existing atoms system</p> required <code>ion</code> <code>Atoms</code> <p>Ion to add (single atom)</p> required <code>region</code> <code>list</code> <p>Region boundaries as [x_min, x_max, y_min, y_max, z_min, z_max]</p> required <code>cutoff</code> <code>float</code> <p>Minimum distance from existing atoms, by default 2.0</p> <code>2.0</code> <code>max_trial</code> <code>int</code> <p>Maximum number of placement attempts, by default 500</p> <code>500</code> <p>Returns:</p> Type Description <code>Atoms or None</code> <p>New atoms system with ion added, or None if placement failed</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from ase import io\n&gt;&gt;&gt; atoms = io.read(\"coord.xyz\")\n&gt;&gt;&gt; ion = Atoms(\"K\")\n&gt;&gt;&gt; atoms = add_ion(atoms, ion, [8.0, 13.0])\n&gt;&gt;&gt; ion = io.read(\"ClO4.pdb\")\n&gt;&gt;&gt; atoms = add_ion(atoms, ion, [8.0, 13.0])\n&gt;&gt;&gt; print(atoms)\n</code></pre> Source code in <code>toolbox/io/build.py</code> <pre><code>def add_ion(atoms, ion, region, cutoff=2.0, max_trial=500):\n    \"\"\"Add an ion to atoms system in specified region.\n\n    This function attempts to place an ion in the specified region\n    without overlapping with existing atoms.\n\n    Parameters\n    ----------\n    atoms : ase.Atoms\n        Existing atoms system\n    ion : ase.Atoms\n        Ion to add (single atom)\n    region : list\n        Region boundaries as [x_min, x_max, y_min, y_max, z_min, z_max]\n    cutoff : float, optional\n        Minimum distance from existing atoms, by default 2.0\n    max_trial : int, optional\n        Maximum number of placement attempts, by default 500\n\n    Returns\n    -------\n    ase.Atoms or None\n        New atoms system with ion added, or None if placement failed\n\n    Examples\n    --------\n    &gt;&gt;&gt; from ase import io\n    &gt;&gt;&gt; atoms = io.read(\"coord.xyz\")\n    &gt;&gt;&gt; ion = Atoms(\"K\")\n    &gt;&gt;&gt; atoms = add_ion(atoms, ion, [8.0, 13.0])\n    &gt;&gt;&gt; ion = io.read(\"ClO4.pdb\")\n    &gt;&gt;&gt; atoms = add_ion(atoms, ion, [8.0, 13.0])\n    &gt;&gt;&gt; print(atoms)\n    \"\"\"\n    coords = ion.get_positions()\n    cog = np.mean(coords, axis=0)\n    coords -= cog.reshape(1, 3)\n    rotation_matrix = random_rotation_matrix()\n    coords = np.dot(coords, rotation_matrix)\n\n    flag = False\n    for _ in range(max_trial):\n        random_positions = get_region_random_location(atoms, region)\n        random_positions = coords + random_positions.reshape(1, 3)\n        ds = distance_array(\n            random_positions, atoms.get_positions(), box=atoms.cell.cellpar()\n        )\n        if ds.min() &gt; cutoff:\n            flag = True\n            break\n    if flag:\n        ion.set_positions(random_positions)\n        new_atoms = atoms.copy()\n        new_atoms.extend(ion)\n        return new_atoms\n    else:\n        raise Warning(\"Failed to add ion\")\n        return None\n</code></pre>"},{"location":"api/#toolbox.io.build.add_water","title":"<code>add_water(atoms, region, cutoff=2.0, max_trial=500)</code>","text":"<p>Add a water molecule to atoms system in specified region.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>Existing atoms system</p> required <code>region</code> <code>list</code> <p>Region boundaries as [x_min, x_max, y_min, y_max, z_min, z_max]</p> required <code>cutoff</code> <code>float</code> <p>Minimum distance from existing atoms, by default 2.0</p> <code>2.0</code> <code>max_trial</code> <code>int</code> <p>Maximum number of placement attempts, by default 500</p> <code>500</code> <p>Returns:</p> Type Description <code>Atoms or None</code> <p>New atoms system with water added, or None if placement failed</p> Source code in <code>toolbox/io/build.py</code> <pre><code>def add_water(atoms, region, cutoff=2.0, max_trial=500):\n    \"\"\"Add a water molecule to atoms system in specified region.\n\n    Parameters\n    ----------\n    atoms : ase.Atoms\n        Existing atoms system\n    region : list\n        Region boundaries as [x_min, x_max, y_min, y_max, z_min, z_max]\n    cutoff : float, optional\n        Minimum distance from existing atoms, by default 2.0\n    max_trial : int, optional\n        Maximum number of placement attempts, by default 500\n\n    Returns\n    -------\n    ase.Atoms or None\n        New atoms system with water added, or None if placement failed\n    \"\"\"\n    water = build.molecule(\"H2O\")\n    return add_ion(atoms, water, region, cutoff=cutoff, max_trial=max_trial)\n</code></pre>"},{"location":"api/#toolbox.io.build.get_region_random_location","title":"<code>get_region_random_location(atoms, region, extent=0.9)</code>","text":"<p>Generate random location within specified region.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>Atoms system for box dimensions</p> required <code>region</code> <code>list</code> <p>Region boundaries as [x_min, x_max, y_min, y_max, z_min, z_max]</p> required <code>extent</code> <code>float</code> <p>Fraction of box extent to use, by default 0.9</p> <code>0.9</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Random position [x, y, z] within region</p> Source code in <code>toolbox/io/build.py</code> <pre><code>def get_region_random_location(atoms, region, extent=0.9):\n    \"\"\"Generate random location within specified region.\n\n    Parameters\n    ----------\n    atoms : ase.Atoms\n        Atoms system for box dimensions\n    region : list\n        Region boundaries as [x_min, x_max, y_min, y_max, z_min, z_max]\n    extent : float, optional\n        Fraction of box extent to use, by default 0.9\n\n    Returns\n    -------\n    np.ndarray\n        Random position [x, y, z] within region\n    \"\"\"\n    x_region = [atoms.get_cell()[0][0] * (1 - extent), atoms.get_cell()[0][0] * extent]\n    y_region = [atoms.get_cell()[1][1] * (1 - extent), atoms.get_cell()[1][1] * extent]\n\n    location_x = np.random.uniform(x_region[0], x_region[1])\n    location_y = np.random.uniform(y_region[0], y_region[1])\n    location_z = np.random.uniform(region[0], region[1])\n\n    return np.array([location_x, location_y, location_z])\n</code></pre>"},{"location":"api/#toolbox.io.build.is_atom_overlap","title":"<code>is_atom_overlap(atoms, index, atom_num=1, r=1.5)</code>","text":"<p>Check if atoms overlap with existing atoms.</p> <p>This function checks if specified atoms in a molecule or ion overlap with existing atoms in the system.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>Existing atoms system</p> required <code>index</code> <code>int</code> <p>Index of first atom in the added molecule/ion</p> required <code>atom_num</code> <code>int</code> <p>Number of atoms in the added molecule/ion, by default 1</p> <code>1</code> <code>r</code> <code>float</code> <p>Minimum distance between atoms, recommended 1.0-1.8, by default 1.5</p> <code>1.5</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if atoms overlap, False otherwise</p> Source code in <code>toolbox/io/build.py</code> <pre><code>def is_atom_overlap(atoms, index, atom_num=1, r=1.5):\n    \"\"\"Check if atoms overlap with existing atoms.\n\n    This function checks if specified atoms in a molecule or ion\n    overlap with existing atoms in the system.\n\n    Parameters\n    ----------\n    atoms : ase.Atoms\n        Existing atoms system\n    index : int\n        Index of first atom in the added molecule/ion\n    atom_num : int, optional\n        Number of atoms in the added molecule/ion, by default 1\n    r : float, optional\n        Minimum distance between atoms, recommended 1.0-1.8, by default 1.5\n\n    Returns\n    -------\n    bool\n        True if atoms overlap, False otherwise\n    \"\"\"\n    distance = atoms.get_all_distances(mic=True)[index]\n    min_index = np.argsort(distance)[atom_num]\n\n    overlap = distance[min_index] &lt; r\n    return overlap\n</code></pre>"},{"location":"api/#toolbox.io.build.random_rotation_matrix","title":"<code>random_rotation_matrix()</code>","text":"<p>Generate a random 3D rotation matrix.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix</p> Source code in <code>toolbox/io/build.py</code> <pre><code>def random_rotation_matrix():\n    \"\"\"Generate a random 3D rotation matrix.\n\n    Returns\n    -------\n    np.ndarray\n        3x3 rotation matrix\n    \"\"\"\n    random_rotvec = np.random.randn(3)\n    random_rotvec /= np.linalg.norm(random_rotvec)\n    angle = np.random.rand() * 2 * np.pi\n    cos_theta = np.cos(angle)\n    sin_theta = np.sin(angle)\n    one_minus_cos_theta = 1 - cos_theta\n\n    rot_matrix = np.zeros((3, 3))\n    rot_matrix[0, 0] = cos_theta + random_rotvec[0] ** 2 * one_minus_cos_theta\n    rot_matrix[1, 1] = cos_theta + random_rotvec[1] ** 2 * one_minus_cos_theta\n    rot_matrix[2, 2] = cos_theta + random_rotvec[2] ** 2 * one_minus_cos_theta\n\n    rot_matrix[0, 1] = (\n        random_rotvec[0] * random_rotvec[1] * one_minus_cos_theta\n        - random_rotvec[2] * sin_theta\n    )\n    rot_matrix[1, 0] = (\n        random_rotvec[0] * random_rotvec[1] * one_minus_cos_theta\n        + random_rotvec[2] * sin_theta\n    )\n\n    rot_matrix[0, 2] = (\n        random_rotvec[0] * random_rotvec[2] * one_minus_cos_theta\n        + random_rotvec[1] * sin_theta\n    )\n    rot_matrix[2, 0] = (\n        random_rotvec[0] * random_rotvec[2] * one_minus_cos_theta\n        - random_rotvec[1] * sin_theta\n    )\n\n    rot_matrix[1, 2] = (\n        random_rotvec[1] * random_rotvec[2] * one_minus_cos_theta\n        - random_rotvec[0] * sin_theta\n    )\n    rot_matrix[2, 1] = (\n        random_rotvec[1] * random_rotvec[2] * one_minus_cos_theta\n        + random_rotvec[0] * sin_theta\n    )\n\n    return rot_matrix\n</code></pre>"},{"location":"api/#cp2k-io","title":"CP2K I/O","text":""},{"location":"api/#toolbox.io.cp2k","title":"<code>toolbox.io.cp2k</code>","text":"<p>CP2K input/output module.</p> <p>This module provides classes for generating CP2K input files and parsing CP2K output files, including energies, forces, and various properties.</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kCube","title":"<code>Cp2kCube</code>","text":"<p>Class for handling CP2K cube files.</p> <p>This class provides methods to read and analyze cube files generated by CP2K, including electron density, potential, and other volumetric data.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Path to cube file</p> required Source code in <code>toolbox/io/cp2k.py</code> <pre><code>class Cp2kCube:\n    \"\"\"\n    Class for handling CP2K cube files.\n\n    This class provides methods to read and analyze cube files generated by CP2K,\n    including electron density, potential, and other volumetric data.\n\n    Parameters\n    ----------\n    fname : str\n        Path to cube file\n    \"\"\"\n\n    def __init__(self, fname) -&gt; None:\n        self.cube_data, self.atoms = read_cube_data(fname)\n        self.n_grid = np.array(self.cube_data.shape)\n        # 3 * 3\n        self.cube_vectors = self.atoms.get_cell() / self.n_grid.reshape(3, 1)\n        # cube volume [A^3]\n        self.cube_volume = self.atoms.get_volume() / np.prod(self.n_grid)\n\n        # cell_params = self.atoms.cell.cellpar()\n        # try:\n        #     assert not (False in (90. == cell_params[-3:]))\n        #     self.cell_params = cell_params[:3]\n        # except:\n        #     raise ValueError(\"Cell is not orthogonal\")\n\n    # @property\n    # def cube_grids(self):\n    #     cube_grids = []\n    #     for ii in range(3):\n    #         cube_grids.append(\n    #             np.arange(\n    #                 0, self.cell_params[ii],\n    #                 self.cell_params[ii] / self.cube_data.shape[ii]\n    #             )[:self.cube_data.shape[ii]]\n    #         )\n    #     return cube_grids\n\n    @property\n    def mesh(self):\n        \"\"\"Mesh for cube data.\"\"\"\n        # generate mesh from self.cube_vectors\n        x = np.arange(self.n_grid[0])\n        y = np.arange(self.n_grid[1])\n        z = np.arange(self.n_grid[2])\n        coeff = np.meshgrid(x, y, z, indexing=\"ij\")\n        coeff_x = coeff[0].reshape(self.n_grid[0], self.n_grid[1], self.n_grid[2], 1)\n        coeff_y = coeff[1].reshape(self.n_grid[0], self.n_grid[1], self.n_grid[2], 1)\n        coeff_z = coeff[2].reshape(self.n_grid[0], self.n_grid[1], self.n_grid[2], 1)\n        unit_x = self.cube_vectors[0].reshape(1, 1, 1, 3)\n        unit_y = self.cube_vectors[1].reshape(1, 1, 1, 3)\n        unit_z = self.cube_vectors[2].reshape(1, 1, 1, 3)\n        # dimx * dimy * dimz * 3\n        mesh = coeff_x * unit_x + coeff_y * unit_y + coeff_z * unit_z\n        return mesh\n\n    @property\n    def dipole(self):\n        \"\"\"Dipole moment [e A].\"\"\"\n        # cube_data: charge density [e / bohr^3]\n        charge = self.cube_data * (self.cube_volume / AU_TO_ANG**3)\n        charge = np.reshape(charge, [self.n_grid[0], self.n_grid[1], self.n_grid[2], 1])\n        dipole = np.sum(self.mesh * charge, axis=(0, 1, 2))\n        # in cp2k, the electron density is positive\n        return -dipole\n\n    def get_ave_cube(self, axis=2, gaussian_sigma=0.0):\n        \"\"\"Get averaged cube data along specified axis.\n\n        Parameters\n        ----------\n        axis : int, optional\n            Axis along which to average (0=x, 1=y, 2=z), by default 2\n        gaussian_sigma : float, optional\n            Standard deviation for Gaussian smoothing, by default 0.0\n\n        Returns\n        -------\n        tuple\n            Tuple containing (grid, averaged_data, smoothed_data)\n        \"\"\"\n        if (\n            hasattr(self, \"axis\")\n            and self.axis == axis\n            and hasattr(self, \"ave_cube_data\")\n        ):\n            pass\n        else:\n            self.axis = axis\n            self.ave_grid = self.cube_vectors[self.axis][self.axis] * np.arange(\n                self.n_grid[self.axis]\n            )\n            ave_axis = tuple(np.delete(np.arange(3), self.axis).tolist())\n            self.ave_cube_data = np.mean(self.cube_data, axis=ave_axis)\n\n        if gaussian_sigma &gt; 0.0:\n            self.ave_cube_data_convolve = gaussian_convolve(\n                self.ave_grid, self.ave_cube_data, gaussian_sigma\n            )\n        else:\n            self.ave_cube_data_convolve = copy.deepcopy(self.ave_cube_data)\n\n        return (self.ave_grid, self.ave_cube_data, self.ave_cube_data_convolve)\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kCube.dipole","title":"<code>dipole</code>  <code>property</code>","text":"<p>Dipole moment [e A].</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kCube.mesh","title":"<code>mesh</code>  <code>property</code>","text":"<p>Mesh for cube data.</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kCube.get_ave_cube","title":"<code>get_ave_cube(axis=2, gaussian_sigma=0.0)</code>","text":"<p>Get averaged cube data along specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>int</code> <p>Axis along which to average (0=x, 1=y, 2=z), by default 2</p> <code>2</code> <code>gaussian_sigma</code> <code>float</code> <p>Standard deviation for Gaussian smoothing, by default 0.0</p> <code>0.0</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple containing (grid, averaged_data, smoothed_data)</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def get_ave_cube(self, axis=2, gaussian_sigma=0.0):\n    \"\"\"Get averaged cube data along specified axis.\n\n    Parameters\n    ----------\n    axis : int, optional\n        Axis along which to average (0=x, 1=y, 2=z), by default 2\n    gaussian_sigma : float, optional\n        Standard deviation for Gaussian smoothing, by default 0.0\n\n    Returns\n    -------\n    tuple\n        Tuple containing (grid, averaged_data, smoothed_data)\n    \"\"\"\n    if (\n        hasattr(self, \"axis\")\n        and self.axis == axis\n        and hasattr(self, \"ave_cube_data\")\n    ):\n        pass\n    else:\n        self.axis = axis\n        self.ave_grid = self.cube_vectors[self.axis][self.axis] * np.arange(\n            self.n_grid[self.axis]\n        )\n        ave_axis = tuple(np.delete(np.arange(3), self.axis).tolist())\n        self.ave_cube_data = np.mean(self.cube_data, axis=ave_axis)\n\n    if gaussian_sigma &gt; 0.0:\n        self.ave_cube_data_convolve = gaussian_convolve(\n            self.ave_grid, self.ave_cube_data, gaussian_sigma\n        )\n    else:\n        self.ave_cube_data_convolve = copy.deepcopy(self.ave_cube_data)\n\n    return (self.ave_grid, self.ave_cube_data, self.ave_cube_data_convolve)\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kHartreeCube","title":"<code>Cp2kHartreeCube</code>","text":"<p>               Bases: <code>Cp2kCube</code></p> <p>Class for handling CP2K Hartree potential cube files.</p> <p>This class extends Cp2kCube to specifically handle Hartree potential data, including methods to calculate potential drops and related properties.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Path to Hartree potential cube file</p> required <code>vac_region</code> <code>list</code> <p>Vacuum region boundaries [start, end], by default None</p> <code>None</code> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>class Cp2kHartreeCube(Cp2kCube):\n    \"\"\"\n    Class for handling CP2K Hartree potential cube files.\n\n    This class extends Cp2kCube to specifically handle Hartree potential data,\n    including methods to calculate potential drops and related properties.\n\n    Parameters\n    ----------\n    fname : str\n        Path to Hartree potential cube file\n    vac_region : list, optional\n        Vacuum region boundaries [start, end], by default None\n    \"\"\"\n\n    def __init__(\n        self,\n        fname,\n        vac_region: list = None,\n    ) -&gt; None:\n        super().__init__(fname)\n        if vac_region:\n            self.set_vac_region(vac_region)\n\n    def set_vac_region(self, vac_region):\n        \"\"\"Set vacuum region for potential drop calculation.\n\n        Parameters\n        ----------\n        vac_region : list\n            Vacuum region boundaries [start, end]\n        \"\"\"\n        assert len(vac_region) == 2\n        self.vac_region = vac_region\n\n    def get_ave_cube(self, axis=2, gaussian_sigma=0):\n        \"\"\"Get averaged Hartree potential cube data along specified axis.\n\n        Parameters\n        ----------\n        axis : int, optional\n            Axis along which to average (0=x, 1=y, 2=z), by default 2\n        gaussian_sigma : float, optional\n            Standard deviation for Gaussian smoothing, by default 0\n\n        Returns\n        -------\n        tuple\n            Tuple containing (grid, averaged_data, smoothed_data) in eV\n        \"\"\"\n        if (\n            hasattr(self, \"axis\")\n            and self.axis == axis\n            and hasattr(self, \"ave_cube_data\")\n        ):\n            pass\n        else:\n            # (self.ave_grid, self.ave_cube_data, self.ave_cube_data_convolve)\n            super().get_ave_cube(axis, gaussian_sigma)\n            self.ave_cube_data_convolve *= AU_TO_EV\n            self.ave_cube_data *= AU_TO_EV\n        return (self.ave_grid, self.ave_cube_data, self.ave_cube_data_convolve)\n\n    @property\n    def potdrop(self):\n        \"\"\"Calculate potential drop across the vacuum region.\n\n        Returns\n        -------\n        float\n            Potential drop in V\n        \"\"\"\n        start_id = np.argmin(np.abs(self.ave_grid - self.vac_region[0]))\n        end_id = np.argmin(np.abs(self.ave_grid - self.vac_region[1]))\n        if start_id &gt; end_id:\n            _data = np.append(\n                self.ave_cube_data[start_id:], self.ave_cube_data[:end_id]\n            )\n        else:\n            _data = np.array(self.ave_cube_data)[\n                self.vac_region[0] : self.vac_region[1]\n            ]\n        dev_data = np.diff(_data, axis=0)\n        p_jump = np.argmax(np.abs(dev_data))\n        return dev_data[p_jump]\n\n    @property\n    def dipole(self):\n        \"\"\"Calculate dipole moment from potential drop.\n\n        Returns\n        -------\n        float\n            Dipole moment in e\u00b7\u00c5\n        \"\"\"\n        d = -self.potdrop * self.cross_area * EPSILON\n        return d\n\n    def set_cross_area(self, cross_area):\n        \"\"\"Set cross-sectional area for dipole calculation.\n\n        Parameters\n        ----------\n        cross_area : float\n            Cross-sectional area in \u00c5\u00b2\n        \"\"\"\n        self.cross_area = cross_area\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kHartreeCube.dipole","title":"<code>dipole</code>  <code>property</code>","text":"<p>Calculate dipole moment from potential drop.</p> <p>Returns:</p> Type Description <code>float</code> <p>Dipole moment in e\u00b7\u00c5</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kHartreeCube.potdrop","title":"<code>potdrop</code>  <code>property</code>","text":"<p>Calculate potential drop across the vacuum region.</p> <p>Returns:</p> Type Description <code>float</code> <p>Potential drop in V</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kHartreeCube.get_ave_cube","title":"<code>get_ave_cube(axis=2, gaussian_sigma=0)</code>","text":"<p>Get averaged Hartree potential cube data along specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>int</code> <p>Axis along which to average (0=x, 1=y, 2=z), by default 2</p> <code>2</code> <code>gaussian_sigma</code> <code>float</code> <p>Standard deviation for Gaussian smoothing, by default 0</p> <code>0</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple containing (grid, averaged_data, smoothed_data) in eV</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def get_ave_cube(self, axis=2, gaussian_sigma=0):\n    \"\"\"Get averaged Hartree potential cube data along specified axis.\n\n    Parameters\n    ----------\n    axis : int, optional\n        Axis along which to average (0=x, 1=y, 2=z), by default 2\n    gaussian_sigma : float, optional\n        Standard deviation for Gaussian smoothing, by default 0\n\n    Returns\n    -------\n    tuple\n        Tuple containing (grid, averaged_data, smoothed_data) in eV\n    \"\"\"\n    if (\n        hasattr(self, \"axis\")\n        and self.axis == axis\n        and hasattr(self, \"ave_cube_data\")\n    ):\n        pass\n    else:\n        # (self.ave_grid, self.ave_cube_data, self.ave_cube_data_convolve)\n        super().get_ave_cube(axis, gaussian_sigma)\n        self.ave_cube_data_convolve *= AU_TO_EV\n        self.ave_cube_data *= AU_TO_EV\n    return (self.ave_grid, self.ave_cube_data, self.ave_cube_data_convolve)\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kHartreeCube.set_cross_area","title":"<code>set_cross_area(cross_area)</code>","text":"<p>Set cross-sectional area for dipole calculation.</p> <p>Parameters:</p> Name Type Description Default <code>cross_area</code> <code>float</code> <p>Cross-sectional area in \u00c5\u00b2</p> required Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_cross_area(self, cross_area):\n    \"\"\"Set cross-sectional area for dipole calculation.\n\n    Parameters\n    ----------\n    cross_area : float\n        Cross-sectional area in \u00c5\u00b2\n    \"\"\"\n    self.cross_area = cross_area\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kHartreeCube.set_vac_region","title":"<code>set_vac_region(vac_region)</code>","text":"<p>Set vacuum region for potential drop calculation.</p> <p>Parameters:</p> Name Type Description Default <code>vac_region</code> <code>list</code> <p>Vacuum region boundaries [start, end]</p> required Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_vac_region(self, vac_region):\n    \"\"\"Set vacuum region for potential drop calculation.\n\n    Parameters\n    ----------\n    vac_region : list\n        Vacuum region boundaries [start, end]\n    \"\"\"\n    assert len(vac_region) == 2\n    self.vac_region = vac_region\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput","title":"<code>Cp2kInput</code>","text":"<p>Class for CP2K input file generation (on the basis of templates).</p> <p>Attributes:</p> Name Type Description <code>atoms</code> <code>ASE Atoms object</code> <p>TBC</p> <code>input_type</code> <code>str</code> <p>TBC</p> <code>pp_dir</code> <code>str</code> <p>directory for basis set, peusudopotential, etc.</p> <code>wfn_restart</code> <code>str</code> <p>wfn file for restart, see ref:</p> <code>qm_charge</code> <code>float</code> <p>charge in QS</p> <code>multiplicity</code> <code>int</code> <p>ref:</p> <code>uks</code> <code>boolen</code> <p>ref:</p> <code>cutoff</code> <code>int</code> <p>ref:</p> <code>rel_cutoff</code> <code>int</code> <p>ref:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from ase import io\n&gt;&gt;&gt; from toolbox.io.cp2k import Cp2kInput\n&gt;&gt;&gt; atoms = io.read(\"POSCAR\")\n&gt;&gt;&gt; input = Cp2kInput(atoms,\n&gt;&gt;&gt;                   pp_dir=\"/data/basis\",\n&gt;&gt;&gt;                   hartree=True,\n&gt;&gt;&gt;                   eden=True)\n&gt;&gt;&gt; input.write()\n</code></pre> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>class Cp2kInput:\n    \"\"\"\n    Class for CP2K input file generation (on the basis of templates).\n\n    Attributes\n    ----------\n    atoms: ASE Atoms object\n        TBC\n    input_type: str\n        TBC\n    pp_dir: str\n        directory for basis set, peusudopotential, etc.\n    wfn_restart: str\n        wfn file for restart, see ref:\n    qm_charge: float\n        charge in QS\n    multiplicity: int\n        ref:\n    uks: boolen\n        ref:\n    cutoff: int\n        ref:\n    rel_cutoff: int\n        ref:\n\n    Examples\n    --------\n    &gt;&gt;&gt; from ase import io\n    &gt;&gt;&gt; from toolbox.io.cp2k import Cp2kInput\n    &gt;&gt;&gt; atoms = io.read(\"POSCAR\")\n    &gt;&gt;&gt; input = Cp2kInput(atoms,\n    &gt;&gt;&gt;                   pp_dir=\"/data/basis\",\n    &gt;&gt;&gt;                   hartree=True,\n    &gt;&gt;&gt;                   eden=True)\n    &gt;&gt;&gt; input.write()\n    \"\"\"\n\n    def __init__(self, atoms, input_type=\"energy\", **kwargs) -&gt; None:\n        self.atoms = atoms\n        self.input_dict = copy.deepcopy(cp2k_default_input[input_type])\n        # print(kwargs)\n        # read user setup in config file\n        try:\n            update_d = CONFIGS[\"io\"][\"cp2k\"][\"input\"]\n        except KeyError:\n            update_d = {}\n        update_dict(kwargs, update_d)\n        self.set_params(kwargs)\n\n    def set_params(self, kwargs):\n        \"\"\"Set parameters for CP2K input.\n\n        Parameters\n        ----------\n        kwargs : dict\n            Dictionary of parameters to set\n        \"\"\"\n        for kw, value in kwargs.items():\n            update_d = getattr(self, f\"set_{kw}\")(value)\n            update_dict(self.input_dict, update_d)\n\n    def write(self, output_dir=\".\", fp_params=None, save_dict=False):\n        \"\"\"\n        Generate coord.xyz and input.inp for CP2K calculation at output_dir.\n\n        Parameters\n        ----------\n        output_dir : str\n            directory to store coord.xyz and input.inp\n        fp_params : dict\n            dict for updated parameters\n        \"\"\"\n        if fp_params is None:\n            fp_params = {}\n        if not os.path.exists(output_dir):\n            os.makedirs(output_dir)\n\n        cell = self.atoms.get_cell()\n        cell_a = np.array2string(\n            cell[0], formatter={\"float_kind\": lambda x: f\"{x:.4f}\"}\n        )\n        cell_a = cell_a[1:-1]\n        cell_b = np.array2string(\n            cell[1], formatter={\"float_kind\": lambda x: f\"{x:.4f}\"}\n        )\n        cell_b = cell_b[1:-1]\n        cell_c = np.array2string(\n            cell[2], formatter={\"float_kind\": lambda x: f\"{x:.4f}\"}\n        )\n        cell_c = cell_c[1:-1]\n\n        user_config = fp_params\n        update_dict(self.input_dict, user_config)\n\n        if self.input_dict[\"FORCE_EVAL\"].get(\"QMMM\", None) is not None:\n            cell_config = {\n                \"FORCE_EVAL\": {\n                    \"SUBSYS\": {\"CELL\": {\"A\": cell_a, \"B\": cell_b, \"C\": cell_c}},\n                    \"QMMM\": {\n                        \"CELL\": {\n                            \"A\": cell_a,\n                            \"B\": cell_b,\n                            \"C\": cell_c,\n                            \"PERIODIC\": \"XYZ\",\n                        }\n                    },\n                }\n            }\n        else:\n            cell_config = {\n                \"FORCE_EVAL\": {\n                    \"SUBSYS\": {\"CELL\": {\"A\": cell_a, \"B\": cell_b, \"C\": cell_c}}\n                }\n            }\n\n        update_dict(self.input_dict, cell_config)\n        # output list\n        input_str = iterdict(self.input_dict, out_list=[\"\\n\"], loop_idx=0)\n        # del input_str[0]\n        # del input_str[-1]\n        # print(input_str)\n        str = \"\\n\".join(input_str)\n        str = str.strip(\"\\n\")\n\n        io.write(os.path.join(output_dir, \"coord.xyz\"), self.atoms)\n        with open(os.path.join(output_dir, \"input.inp\"), \"w\", encoding=\"utf-8\") as f:\n            f.write(str)\n\n        if save_dict:\n            save_dict_json(self.input_dict, os.path.join(output_dir, \"input.json\"))\n\n    def set_project(self, project_name: str):\n        \"\"\"Set project name for CP2K calculation.\n\n        Parameters\n        ----------\n        project_name : str\n            Project name for CP2K calculation\n\n        Returns\n        -------\n        dict\n            Update dictionary for project name\n        \"\"\"\n        update_d = {\"GLOBAL\": {\"PROJECT\": project_name}}\n        return update_d\n\n    def set_pp_dir(self, pp_dir):\n        \"\"\"Set pseudopotential directory.\n\n        Parameters\n        ----------\n        pp_dir : str\n            Directory containing basis sets and pseudopotentials\n\n        Returns\n        -------\n        dict\n            Update dictionary for pseudopotential directory\n        \"\"\"\n        pp_dir = os.path.abspath(pp_dir)\n        update_d = {\n            \"FORCE_EVAL\": {\n                \"DFT\": {\n                    \"BASIS_SET_FILE_NAME\": [\n                        os.path.join(pp_dir, \"BASIS_MOLOPT\"),\n                        os.path.join(pp_dir, \"BASIS_ADMM\"),\n                        os.path.join(pp_dir, \"BASIS_ADMM_MOLOPT\"),\n                        os.path.join(pp_dir, \"BASIS_MOLOPT-HSE06\"),\n                    ],\n                    \"POTENTIAL_FILE_NAME\": os.path.join(pp_dir, \"GTH_POTENTIALS\"),\n                    \"XC\": {\n                        \"vdW_POTENTIAL\": {\n                            \"PAIR_POTENTIAL\": {\n                                \"PARAMETER_FILE_NAME\": os.path.join(pp_dir, \"dftd3.dat\")\n                            }\n                        }\n                    },\n                }\n            }\n        }\n        return update_d\n\n    def set_wfn_restart(self, wfn_file):\n        \"\"\"Set wavefunction restart file.\n\n        Parameters\n        ----------\n        wfn_file : str or None\n            Path to wavefunction restart file\n\n        Returns\n        -------\n        dict\n            Update dictionary for wavefunction restart file\n        \"\"\"\n        update_d = {}\n        if wfn_file is not None:\n            update_d = {\n                \"FORCE_EVAL\": {\n                    \"DFT\": {\"WFN_RESTART_FILE_NAME\": os.path.abspath(wfn_file)}\n                }\n            }\n        return update_d\n\n    def set_qm_charge(self, charge):\n        \"\"\"Set quantum mechanical charge.\n\n        Parameters\n        ----------\n        charge : float\n            Total charge of the system\n\n        Returns\n        -------\n        dict\n            Update dictionary for charge\n        \"\"\"\n        update_d = {\"FORCE_EVAL\": {\"DFT\": {\"CHARGE\": charge}}}\n        return update_d\n\n    def set_multiplicity(self, multiplicity):\n        \"\"\"Set spin multiplicity.\n\n        Parameters\n        ----------\n        multiplicity : int\n            Spin multiplicity of the system\n\n        Returns\n        -------\n        dict\n            Update dictionary for multiplicity\n        \"\"\"\n        update_d = {\"FORCE_EVAL\": {\"DFT\": {\"MULTIPLICITY\": multiplicity}}}\n        return update_d\n\n    def set_uks(self, flag):\n        \"\"\"Set unrestricted Kohn-Sham calculation.\n\n        Parameters\n        ----------\n        flag : bool\n            Whether to use UKS calculation\n\n        Returns\n        -------\n        dict\n            Update dictionary for UKS\n        \"\"\"\n        if flag:\n            update_d = {\"FORCE_EVAL\": {\"DFT\": {\"UKS\": \".TRUE.\"}}}\n            return update_d\n        else:\n            return {}\n\n    def set_cutoff(self, cutoff):\n        \"\"\"Set plane wave cutoff.\n\n        Parameters\n        ----------\n        cutoff : float\n            Plane wave cutoff in Ry\n\n        Returns\n        -------\n        dict\n            Update dictionary for cutoff\n        \"\"\"\n        update_d = {\"FORCE_EVAL\": {\"DFT\": {\"MGRID\": {\"CUTOFF\": cutoff}}}}\n        return update_d\n\n    def set_rel_cutoff(self, rel_cutoff):\n        \"\"\"Set relative cutoff.\n\n        Parameters\n        ----------\n        rel_cutoff : float\n            Relative cutoff for multi-grid\n\n        Returns\n        -------\n        dict\n            Update dictionary for relative cutoff\n        \"\"\"\n        update_d = {\"FORCE_EVAL\": {\"DFT\": {\"MGRID\": {\"REL_CUTOFF\": rel_cutoff}}}}\n        return update_d\n\n    def set_kp(self, kp_mp):\n        \"\"\"Set k-points mesh.\n\n        Parameters\n        ----------\n        kp_mp : tuple\n            K-point mesh as (kx, ky, kz)\n\n        Returns\n        -------\n        dict\n            Update dictionary for k-points\n        \"\"\"\n        update_d = {\n            \"FORCE_EVAL\": {\n                \"DFT\": {\n                    \"KPOINTS\": {\n                        \"SCHEME MONKHORST-PACK\": f\"{kp_mp[0]:d} {kp_mp[1]:d} {kp_mp[2]:d}\",\n                        \"SYMMETRY\": \".TRUE.\",\n                        \"EPS_GEO\": 1.0e-8,\n                        \"FULL_GRID\": \".TRUE.\",\n                        \"PARALLEL_GROUP_SIZE\": 0,\n                    }\n                }\n            }\n        }\n        return update_d\n\n    def set_max_scf(self, max_scf: int):\n        \"\"\"Set maximum SCF iterations.\n\n        Parameters\n        ----------\n        max_scf : int\n            Maximum number of SCF iterations\n\n        Returns\n        -------\n        dict\n            Update dictionary for maximum SCF iterations\n        \"\"\"\n        update_d = {\"FORCE_EVAL\": {\"DFT\": {\"SCF\": {\"MAX_SCF\": max_scf}}}}\n        return update_d\n\n    def set_eps_scf(self, eps_scf: float):\n        \"\"\"Set SCF convergence threshold.\n\n        Parameters\n        ----------\n        eps_scf : float\n            SCF convergence threshold\n\n        Returns\n        -------\n        dict\n            Update dictionary for SCF convergence threshold\n        \"\"\"\n        update_d = {\"FORCE_EVAL\": {\"DFT\": {\"SCF\": {\"EPS_SCF\": eps_scf}}}}\n        return update_d\n\n    def set_dip_cor(self, flag):\n        \"\"\"Set surface dipole correction.\n\n        Parameters\n        ----------\n        flag : bool\n            Whether to apply surface dipole correction\n\n        Returns\n        -------\n        dict\n            Update dictionary for dipole correction\n        \"\"\"\n        if flag:\n            update_d = {\"FORCE_EVAL\": {\"DFT\": {\"SURFACE_DIPOLE_CORRECTION\": \".TRUE.\"}}}\n            return update_d\n        else:\n            return {}\n\n    def set_eden(self, flag):\n        \"\"\"Set electron density cube output.\n\n        Parameters\n        ----------\n        flag : bool\n            Whether to output electron density cube\n\n        Returns\n        -------\n        dict\n            Update dictionary for electron density output\n        \"\"\"\n        if flag:\n            update_d = {\n                \"FORCE_EVAL\": {\n                    \"DFT\": {\n                        \"PRINT\": {\n                            \"E_DENSITY_CUBE\": {\"ADD_LAST\": \"NUMERIC\", \"STRIDE\": \"8 8 1\"}\n                        }\n                    }\n                }\n            }\n            return update_d\n        else:\n            return {}\n\n    def set_mo(self, flag):\n        \"\"\"Set molecular orbital cube output.\n\n        Parameters\n        ----------\n        flag : bool\n            Whether to output molecular orbital cubes\n\n        Returns\n        -------\n        dict\n            Update dictionary for MO output\n        \"\"\"\n        if flag:\n            update_d = {\n                \"FORCE_EVAL\": {\"DFT\": {\"PRINT\": {\"MO_CUBES\": {\"ADD_LAST\": \"NUMERIC\"}}}}\n            }\n            return update_d\n        else:\n            return {}\n\n    def set_pdos(self, flag):\n        \"\"\"Set projected density of states output.\n\n        Parameters\n        ----------\n        flag : bool\n            Whether to output PDOS\n\n        Returns\n        -------\n        dict\n            Update dictionary for PDOS output\n        \"\"\"\n        if flag:\n            update_d = {\n                \"FORCE_EVAL\": {\n                    \"DFT\": {\n                        \"PRINT\": {\n                            \"PDOS\": {\n                                \"COMPONENTS\": \".TRUE.\",\n                                \"ADD_LAST\": \"NUMERIC\",\n                                \"NLUMO\": -1,\n                                \"COMMON_ITERATION_LEVELS\": 0,\n                            }\n                        }\n                    }\n                }\n            }\n            return update_d\n        else:\n            return {}\n\n    def set_hartree(self, flag):\n        \"\"\"Set Hartree potential cube output.\n\n        Parameters\n        ----------\n        flag : bool\n            Whether to output Hartree potential cube\n\n        Returns\n        -------\n        dict\n            Update dictionary for Hartree potential output\n        \"\"\"\n        if flag:\n            update_d = {\n                \"FORCE_EVAL\": {\n                    \"DFT\": {\n                        \"PRINT\": {\n                            \"V_HARTREE_CUBE\": {\"ADD_LAST\": \"NUMERIC\", \"STRIDE\": \"8 8 1\"}\n                        }\n                    }\n                }\n            }\n            return update_d\n        else:\n            return {}\n\n    def set_efield(self, flag):\n        \"\"\"Set electric field cube output.\n\n        Parameters\n        ----------\n        flag : bool\n            Whether to output electric field cube\n\n        Returns\n        -------\n        dict\n            Update dictionary for electric field output\n        \"\"\"\n        if flag:\n            update_d = {\n                \"FORCE_EVAL\": {\n                    \"DFT\": {\n                        \"PRINT\": {\n                            \"EFIELD_CUBE\": {\"ADD_LAST\": \"NUMERIC\", \"STRIDE\": \"8 8 1\"}\n                        }\n                    }\n                }\n            }\n            return update_d\n        else:\n            return {}\n\n    def set_totden(self, flag):\n        \"\"\"Set total density cube output.\n\n        Parameters\n        ----------\n        flag : bool\n            Whether to output total density cube\n\n        Returns\n        -------\n        dict\n            Update dictionary for total density output\n        \"\"\"\n        if flag:\n            update_d = {\n                \"FORCE_EVAL\": {\n                    \"DFT\": {\n                        \"PRINT\": {\n                            \"TOT_DENSITY_CUBE\": {\n                                \"ADD_LAST\": \"NUMERIC\",\n                                \"STRIDE\": \"1 1 1\",\n                            }\n                        }\n                    }\n                }\n            }\n            return update_d\n        else:\n            return {}\n\n    def set_extended_fft_lengths(self, flag):\n        \"\"\"Set extended FFT lengths.\n\n        Parameters\n        ----------\n        flag : bool\n            Whether to use extended FFT lengths\n\n        Returns\n        -------\n        dict\n            Update dictionary for extended FFT lengths\n        \"\"\"\n        if flag:\n            update_d = {\"GLOBAL\": {\"EXTENDED_FFT_LENGTHS\": \".TRUE.\"}}\n            return update_d\n        else:\n            return {}\n\n    def set_smear(self, flag):\n        \"\"\"Set smearing method for SCF calculation.\n\n        Parameters\n        ----------\n        flag : bool\n            Whether to enable smearing\n\n        Returns\n        -------\n        dict\n            Update dictionary for smearing settings\n        \"\"\"\n        if not flag:\n            update_d = {\n                \"FORCE_EVAL\": {\n                    \"DFT\": {\n                        \"SCF\": {\n                            \"ADDED_MOS\": 0,\n                            \"CHOLESKY\": \"RESTORE\",\n                            \"SMEAR\": {\"_\": \".FALSE.\"},\n                            \"DIAGONALIZATION\": {\"_\": \".FALSE.\"},\n                        }\n                    }\n                }\n            }\n            return update_d\n\n    def set_mlwf(self, flag):\n        \"\"\"Set maximally localized Wannier functions.\n\n        Parameters\n        ----------\n        flag : bool\n            Whether to enable MLWF calculation\n\n        Returns\n        -------\n        dict\n            Update dictionary for MLWF settings\n        \"\"\"\n        if flag:\n            update_d = {\n                \"FORCE_EVAL\": {\n                    \"DFT\": {\n                        \"LOCALIZE\": {\n                            \"METHOD\": \"CRAZY\",\n                            \"EPS_LOCALIZATION\": 1e-08,\n                            \"PRINT\": {\"WANNIER_CENTERS\": {\"IONS+CENTERS\": \".TRUE.\"}},\n                        }\n                    }\n                }\n            }\n            return update_d\n        else:\n            return {}\n\n    def set_kind(self, kind_dict: dict):\n        \"\"\"\n        Set atom kind parameters.\n\n        Parameters\n        ----------\n        kind_dict : dict\n            dict to update kind section, for example:\n            {\n                \"S\": {\n                    \"ELEMENT\": \"O\",\n                    \"BASIS_SET\": \"DZVP-MOLOPT-SR-GTH\",\n                    \"POTENTIAL\": \"GTH-PBE-q6\"\n                },\n                \"Li\": {\n                    \"ELEMENT\": \"H\",\n                    \"BASIS_SET\": \"DZVP-MOLOPT-SR-GTH\",\n                    \"POTENTIAL\": \"GTH-PBE-q1\"\n                }\n            }\n        \"\"\"\n        update_d = {\"FORCE_EVAL\": {\"SUBSYS\": {}}}\n        update_dict(self.input_dict, update_d)\n\n        old_kind_list = self.input_dict[\"FORCE_EVAL\"][\"SUBSYS\"].get(\"KIND\", [])\n        if len(old_kind_list) &gt; 0:\n            for k, v in kind_dict.items():\n                tmp_dict = copy.deepcopy(v)\n                tmp_dict.update({\"_\": k})\n                flag = False\n                for ii, item in enumerate(old_kind_list):\n                    if k == item[\"_\"]:\n                        # print(v)\n                        old_kind_list[ii] = tmp_dict\n                        flag = True\n                        break\n                if not flag:\n                    old_kind_list.append(tmp_dict)\n        return {}\n\n    def set_restart(self, flag):\n        \"\"\"Set restart file for CP2K calculation.\n\n        Parameters\n        ----------\n        flag : bool\n            Whether to use restart file\n\n        Returns\n        -------\n        dict\n            Update dictionary for restart settings\n        \"\"\"\n        if flag:\n            update_d = {\n                \"EXT_RESTART\": {\n                    \"RESTART_FILE_NAME\": \"{}-1.restart\".format(\n                        self.input_dict[\"GLOBAL\"][\"PROJECT\"]\n                    )\n                }\n            }\n            return update_d\n        else:\n            return {}\n\n    def set_md_step(self, md_step):\n        \"\"\"Set number of MD steps.\n\n        Parameters\n        ----------\n        md_step : int\n            Number of MD steps\n\n        Returns\n        -------\n        dict\n            Update dictionary for MD steps\n        \"\"\"\n        update_d = {\"MOTION\": {\"MD\": {\"STEPS\": md_step}}}\n        return update_d\n\n    def set_md_temp(self, md_temp):\n        \"\"\"Set MD temperature.\n\n        Parameters\n        ----------\n        md_temp : float\n            Temperature for MD simulation\n\n        Returns\n        -------\n        dict\n            Update dictionary for MD temperature\n        \"\"\"\n        update_d = {\"MOTION\": {\"MD\": {\"TEMPERATURE\": md_temp}}}\n        return update_d\n\n    def set_md_timestep(self, md_timestep):\n        \"\"\"Set MD timestep.\n\n        Parameters\n        ----------\n        md_timestep : float\n            Timestep for MD simulation\n\n        Returns\n        -------\n        dict\n            Update dictionary for MD timestep\n        \"\"\"\n        update_d = {\"MOTION\": {\"MD\": {\"TIMESTEP\": md_timestep}}}\n        return update_d\n\n    def update_dp(self, dp_model: str):\n        \"\"\"Update CP2K input with Deep Potential model.\n\n        Parameters\n        ----------\n        dp_model : str\n            Path to Deep Potential model file\n        \"\"\"\n        from deepmd.infer import DeepPot\n\n        dp = DeepPot(dp_model)\n        type_map = dp.tmap\n        for ii, atype in enumerate(type_map):\n            self.input_dict[\"FORCE_EVAL\"][\"MM\"][\"FORCEFIELD\"][\"CHARGE\"].append(\n                {\n                    \"ATOM\": atype,\n                    \"CHARGE\": 0.0,\n                }\n            )\n            self.input_dict[\"FORCE_EVAL\"][\"MM\"][\"FORCEFIELD\"][\"NONBONDED\"][\n                \"DEEPMD\"\n            ].append(\n                {\n                    \"ATOMS\": f\"{atype} {atype}\",\n                    \"POT_FILE_NAME\": dp_model,\n                    \"ATOM_DEEPMD_TYPE\": ii,\n                }\n            )\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_cutoff","title":"<code>set_cutoff(cutoff)</code>","text":"<p>Set plane wave cutoff.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>Plane wave cutoff in Ry</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for cutoff</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_cutoff(self, cutoff):\n    \"\"\"Set plane wave cutoff.\n\n    Parameters\n    ----------\n    cutoff : float\n        Plane wave cutoff in Ry\n\n    Returns\n    -------\n    dict\n        Update dictionary for cutoff\n    \"\"\"\n    update_d = {\"FORCE_EVAL\": {\"DFT\": {\"MGRID\": {\"CUTOFF\": cutoff}}}}\n    return update_d\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_dip_cor","title":"<code>set_dip_cor(flag)</code>","text":"<p>Set surface dipole correction.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>bool</code> <p>Whether to apply surface dipole correction</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for dipole correction</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_dip_cor(self, flag):\n    \"\"\"Set surface dipole correction.\n\n    Parameters\n    ----------\n    flag : bool\n        Whether to apply surface dipole correction\n\n    Returns\n    -------\n    dict\n        Update dictionary for dipole correction\n    \"\"\"\n    if flag:\n        update_d = {\"FORCE_EVAL\": {\"DFT\": {\"SURFACE_DIPOLE_CORRECTION\": \".TRUE.\"}}}\n        return update_d\n    else:\n        return {}\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_eden","title":"<code>set_eden(flag)</code>","text":"<p>Set electron density cube output.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>bool</code> <p>Whether to output electron density cube</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for electron density output</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_eden(self, flag):\n    \"\"\"Set electron density cube output.\n\n    Parameters\n    ----------\n    flag : bool\n        Whether to output electron density cube\n\n    Returns\n    -------\n    dict\n        Update dictionary for electron density output\n    \"\"\"\n    if flag:\n        update_d = {\n            \"FORCE_EVAL\": {\n                \"DFT\": {\n                    \"PRINT\": {\n                        \"E_DENSITY_CUBE\": {\"ADD_LAST\": \"NUMERIC\", \"STRIDE\": \"8 8 1\"}\n                    }\n                }\n            }\n        }\n        return update_d\n    else:\n        return {}\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_efield","title":"<code>set_efield(flag)</code>","text":"<p>Set electric field cube output.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>bool</code> <p>Whether to output electric field cube</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for electric field output</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_efield(self, flag):\n    \"\"\"Set electric field cube output.\n\n    Parameters\n    ----------\n    flag : bool\n        Whether to output electric field cube\n\n    Returns\n    -------\n    dict\n        Update dictionary for electric field output\n    \"\"\"\n    if flag:\n        update_d = {\n            \"FORCE_EVAL\": {\n                \"DFT\": {\n                    \"PRINT\": {\n                        \"EFIELD_CUBE\": {\"ADD_LAST\": \"NUMERIC\", \"STRIDE\": \"8 8 1\"}\n                    }\n                }\n            }\n        }\n        return update_d\n    else:\n        return {}\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_eps_scf","title":"<code>set_eps_scf(eps_scf)</code>","text":"<p>Set SCF convergence threshold.</p> <p>Parameters:</p> Name Type Description Default <code>eps_scf</code> <code>float</code> <p>SCF convergence threshold</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for SCF convergence threshold</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_eps_scf(self, eps_scf: float):\n    \"\"\"Set SCF convergence threshold.\n\n    Parameters\n    ----------\n    eps_scf : float\n        SCF convergence threshold\n\n    Returns\n    -------\n    dict\n        Update dictionary for SCF convergence threshold\n    \"\"\"\n    update_d = {\"FORCE_EVAL\": {\"DFT\": {\"SCF\": {\"EPS_SCF\": eps_scf}}}}\n    return update_d\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_extended_fft_lengths","title":"<code>set_extended_fft_lengths(flag)</code>","text":"<p>Set extended FFT lengths.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>bool</code> <p>Whether to use extended FFT lengths</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for extended FFT lengths</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_extended_fft_lengths(self, flag):\n    \"\"\"Set extended FFT lengths.\n\n    Parameters\n    ----------\n    flag : bool\n        Whether to use extended FFT lengths\n\n    Returns\n    -------\n    dict\n        Update dictionary for extended FFT lengths\n    \"\"\"\n    if flag:\n        update_d = {\"GLOBAL\": {\"EXTENDED_FFT_LENGTHS\": \".TRUE.\"}}\n        return update_d\n    else:\n        return {}\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_hartree","title":"<code>set_hartree(flag)</code>","text":"<p>Set Hartree potential cube output.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>bool</code> <p>Whether to output Hartree potential cube</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for Hartree potential output</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_hartree(self, flag):\n    \"\"\"Set Hartree potential cube output.\n\n    Parameters\n    ----------\n    flag : bool\n        Whether to output Hartree potential cube\n\n    Returns\n    -------\n    dict\n        Update dictionary for Hartree potential output\n    \"\"\"\n    if flag:\n        update_d = {\n            \"FORCE_EVAL\": {\n                \"DFT\": {\n                    \"PRINT\": {\n                        \"V_HARTREE_CUBE\": {\"ADD_LAST\": \"NUMERIC\", \"STRIDE\": \"8 8 1\"}\n                    }\n                }\n            }\n        }\n        return update_d\n    else:\n        return {}\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_kind","title":"<code>set_kind(kind_dict)</code>","text":"<p>Set atom kind parameters.</p> <p>Parameters:</p> Name Type Description Default <code>kind_dict</code> <code>dict</code> <p>dict to update kind section, for example: {     \"S\": {         \"ELEMENT\": \"O\",         \"BASIS_SET\": \"DZVP-MOLOPT-SR-GTH\",         \"POTENTIAL\": \"GTH-PBE-q6\"     },     \"Li\": {         \"ELEMENT\": \"H\",         \"BASIS_SET\": \"DZVP-MOLOPT-SR-GTH\",         \"POTENTIAL\": \"GTH-PBE-q1\"     } }</p> required Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_kind(self, kind_dict: dict):\n    \"\"\"\n    Set atom kind parameters.\n\n    Parameters\n    ----------\n    kind_dict : dict\n        dict to update kind section, for example:\n        {\n            \"S\": {\n                \"ELEMENT\": \"O\",\n                \"BASIS_SET\": \"DZVP-MOLOPT-SR-GTH\",\n                \"POTENTIAL\": \"GTH-PBE-q6\"\n            },\n            \"Li\": {\n                \"ELEMENT\": \"H\",\n                \"BASIS_SET\": \"DZVP-MOLOPT-SR-GTH\",\n                \"POTENTIAL\": \"GTH-PBE-q1\"\n            }\n        }\n    \"\"\"\n    update_d = {\"FORCE_EVAL\": {\"SUBSYS\": {}}}\n    update_dict(self.input_dict, update_d)\n\n    old_kind_list = self.input_dict[\"FORCE_EVAL\"][\"SUBSYS\"].get(\"KIND\", [])\n    if len(old_kind_list) &gt; 0:\n        for k, v in kind_dict.items():\n            tmp_dict = copy.deepcopy(v)\n            tmp_dict.update({\"_\": k})\n            flag = False\n            for ii, item in enumerate(old_kind_list):\n                if k == item[\"_\"]:\n                    # print(v)\n                    old_kind_list[ii] = tmp_dict\n                    flag = True\n                    break\n            if not flag:\n                old_kind_list.append(tmp_dict)\n    return {}\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_kp","title":"<code>set_kp(kp_mp)</code>","text":"<p>Set k-points mesh.</p> <p>Parameters:</p> Name Type Description Default <code>kp_mp</code> <code>tuple</code> <p>K-point mesh as (kx, ky, kz)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for k-points</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_kp(self, kp_mp):\n    \"\"\"Set k-points mesh.\n\n    Parameters\n    ----------\n    kp_mp : tuple\n        K-point mesh as (kx, ky, kz)\n\n    Returns\n    -------\n    dict\n        Update dictionary for k-points\n    \"\"\"\n    update_d = {\n        \"FORCE_EVAL\": {\n            \"DFT\": {\n                \"KPOINTS\": {\n                    \"SCHEME MONKHORST-PACK\": f\"{kp_mp[0]:d} {kp_mp[1]:d} {kp_mp[2]:d}\",\n                    \"SYMMETRY\": \".TRUE.\",\n                    \"EPS_GEO\": 1.0e-8,\n                    \"FULL_GRID\": \".TRUE.\",\n                    \"PARALLEL_GROUP_SIZE\": 0,\n                }\n            }\n        }\n    }\n    return update_d\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_max_scf","title":"<code>set_max_scf(max_scf)</code>","text":"<p>Set maximum SCF iterations.</p> <p>Parameters:</p> Name Type Description Default <code>max_scf</code> <code>int</code> <p>Maximum number of SCF iterations</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for maximum SCF iterations</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_max_scf(self, max_scf: int):\n    \"\"\"Set maximum SCF iterations.\n\n    Parameters\n    ----------\n    max_scf : int\n        Maximum number of SCF iterations\n\n    Returns\n    -------\n    dict\n        Update dictionary for maximum SCF iterations\n    \"\"\"\n    update_d = {\"FORCE_EVAL\": {\"DFT\": {\"SCF\": {\"MAX_SCF\": max_scf}}}}\n    return update_d\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_md_step","title":"<code>set_md_step(md_step)</code>","text":"<p>Set number of MD steps.</p> <p>Parameters:</p> Name Type Description Default <code>md_step</code> <code>int</code> <p>Number of MD steps</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for MD steps</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_md_step(self, md_step):\n    \"\"\"Set number of MD steps.\n\n    Parameters\n    ----------\n    md_step : int\n        Number of MD steps\n\n    Returns\n    -------\n    dict\n        Update dictionary for MD steps\n    \"\"\"\n    update_d = {\"MOTION\": {\"MD\": {\"STEPS\": md_step}}}\n    return update_d\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_md_temp","title":"<code>set_md_temp(md_temp)</code>","text":"<p>Set MD temperature.</p> <p>Parameters:</p> Name Type Description Default <code>md_temp</code> <code>float</code> <p>Temperature for MD simulation</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for MD temperature</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_md_temp(self, md_temp):\n    \"\"\"Set MD temperature.\n\n    Parameters\n    ----------\n    md_temp : float\n        Temperature for MD simulation\n\n    Returns\n    -------\n    dict\n        Update dictionary for MD temperature\n    \"\"\"\n    update_d = {\"MOTION\": {\"MD\": {\"TEMPERATURE\": md_temp}}}\n    return update_d\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_md_timestep","title":"<code>set_md_timestep(md_timestep)</code>","text":"<p>Set MD timestep.</p> <p>Parameters:</p> Name Type Description Default <code>md_timestep</code> <code>float</code> <p>Timestep for MD simulation</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for MD timestep</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_md_timestep(self, md_timestep):\n    \"\"\"Set MD timestep.\n\n    Parameters\n    ----------\n    md_timestep : float\n        Timestep for MD simulation\n\n    Returns\n    -------\n    dict\n        Update dictionary for MD timestep\n    \"\"\"\n    update_d = {\"MOTION\": {\"MD\": {\"TIMESTEP\": md_timestep}}}\n    return update_d\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_mlwf","title":"<code>set_mlwf(flag)</code>","text":"<p>Set maximally localized Wannier functions.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>bool</code> <p>Whether to enable MLWF calculation</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for MLWF settings</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_mlwf(self, flag):\n    \"\"\"Set maximally localized Wannier functions.\n\n    Parameters\n    ----------\n    flag : bool\n        Whether to enable MLWF calculation\n\n    Returns\n    -------\n    dict\n        Update dictionary for MLWF settings\n    \"\"\"\n    if flag:\n        update_d = {\n            \"FORCE_EVAL\": {\n                \"DFT\": {\n                    \"LOCALIZE\": {\n                        \"METHOD\": \"CRAZY\",\n                        \"EPS_LOCALIZATION\": 1e-08,\n                        \"PRINT\": {\"WANNIER_CENTERS\": {\"IONS+CENTERS\": \".TRUE.\"}},\n                    }\n                }\n            }\n        }\n        return update_d\n    else:\n        return {}\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_mo","title":"<code>set_mo(flag)</code>","text":"<p>Set molecular orbital cube output.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>bool</code> <p>Whether to output molecular orbital cubes</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for MO output</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_mo(self, flag):\n    \"\"\"Set molecular orbital cube output.\n\n    Parameters\n    ----------\n    flag : bool\n        Whether to output molecular orbital cubes\n\n    Returns\n    -------\n    dict\n        Update dictionary for MO output\n    \"\"\"\n    if flag:\n        update_d = {\n            \"FORCE_EVAL\": {\"DFT\": {\"PRINT\": {\"MO_CUBES\": {\"ADD_LAST\": \"NUMERIC\"}}}}\n        }\n        return update_d\n    else:\n        return {}\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_multiplicity","title":"<code>set_multiplicity(multiplicity)</code>","text":"<p>Set spin multiplicity.</p> <p>Parameters:</p> Name Type Description Default <code>multiplicity</code> <code>int</code> <p>Spin multiplicity of the system</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for multiplicity</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_multiplicity(self, multiplicity):\n    \"\"\"Set spin multiplicity.\n\n    Parameters\n    ----------\n    multiplicity : int\n        Spin multiplicity of the system\n\n    Returns\n    -------\n    dict\n        Update dictionary for multiplicity\n    \"\"\"\n    update_d = {\"FORCE_EVAL\": {\"DFT\": {\"MULTIPLICITY\": multiplicity}}}\n    return update_d\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_params","title":"<code>set_params(kwargs)</code>","text":"<p>Set parameters for CP2K input.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>Dictionary of parameters to set</p> required Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_params(self, kwargs):\n    \"\"\"Set parameters for CP2K input.\n\n    Parameters\n    ----------\n    kwargs : dict\n        Dictionary of parameters to set\n    \"\"\"\n    for kw, value in kwargs.items():\n        update_d = getattr(self, f\"set_{kw}\")(value)\n        update_dict(self.input_dict, update_d)\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_pdos","title":"<code>set_pdos(flag)</code>","text":"<p>Set projected density of states output.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>bool</code> <p>Whether to output PDOS</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for PDOS output</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_pdos(self, flag):\n    \"\"\"Set projected density of states output.\n\n    Parameters\n    ----------\n    flag : bool\n        Whether to output PDOS\n\n    Returns\n    -------\n    dict\n        Update dictionary for PDOS output\n    \"\"\"\n    if flag:\n        update_d = {\n            \"FORCE_EVAL\": {\n                \"DFT\": {\n                    \"PRINT\": {\n                        \"PDOS\": {\n                            \"COMPONENTS\": \".TRUE.\",\n                            \"ADD_LAST\": \"NUMERIC\",\n                            \"NLUMO\": -1,\n                            \"COMMON_ITERATION_LEVELS\": 0,\n                        }\n                    }\n                }\n            }\n        }\n        return update_d\n    else:\n        return {}\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_pp_dir","title":"<code>set_pp_dir(pp_dir)</code>","text":"<p>Set pseudopotential directory.</p> <p>Parameters:</p> Name Type Description Default <code>pp_dir</code> <code>str</code> <p>Directory containing basis sets and pseudopotentials</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for pseudopotential directory</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_pp_dir(self, pp_dir):\n    \"\"\"Set pseudopotential directory.\n\n    Parameters\n    ----------\n    pp_dir : str\n        Directory containing basis sets and pseudopotentials\n\n    Returns\n    -------\n    dict\n        Update dictionary for pseudopotential directory\n    \"\"\"\n    pp_dir = os.path.abspath(pp_dir)\n    update_d = {\n        \"FORCE_EVAL\": {\n            \"DFT\": {\n                \"BASIS_SET_FILE_NAME\": [\n                    os.path.join(pp_dir, \"BASIS_MOLOPT\"),\n                    os.path.join(pp_dir, \"BASIS_ADMM\"),\n                    os.path.join(pp_dir, \"BASIS_ADMM_MOLOPT\"),\n                    os.path.join(pp_dir, \"BASIS_MOLOPT-HSE06\"),\n                ],\n                \"POTENTIAL_FILE_NAME\": os.path.join(pp_dir, \"GTH_POTENTIALS\"),\n                \"XC\": {\n                    \"vdW_POTENTIAL\": {\n                        \"PAIR_POTENTIAL\": {\n                            \"PARAMETER_FILE_NAME\": os.path.join(pp_dir, \"dftd3.dat\")\n                        }\n                    }\n                },\n            }\n        }\n    }\n    return update_d\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_project","title":"<code>set_project(project_name)</code>","text":"<p>Set project name for CP2K calculation.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name for CP2K calculation</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for project name</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_project(self, project_name: str):\n    \"\"\"Set project name for CP2K calculation.\n\n    Parameters\n    ----------\n    project_name : str\n        Project name for CP2K calculation\n\n    Returns\n    -------\n    dict\n        Update dictionary for project name\n    \"\"\"\n    update_d = {\"GLOBAL\": {\"PROJECT\": project_name}}\n    return update_d\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_qm_charge","title":"<code>set_qm_charge(charge)</code>","text":"<p>Set quantum mechanical charge.</p> <p>Parameters:</p> Name Type Description Default <code>charge</code> <code>float</code> <p>Total charge of the system</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for charge</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_qm_charge(self, charge):\n    \"\"\"Set quantum mechanical charge.\n\n    Parameters\n    ----------\n    charge : float\n        Total charge of the system\n\n    Returns\n    -------\n    dict\n        Update dictionary for charge\n    \"\"\"\n    update_d = {\"FORCE_EVAL\": {\"DFT\": {\"CHARGE\": charge}}}\n    return update_d\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_rel_cutoff","title":"<code>set_rel_cutoff(rel_cutoff)</code>","text":"<p>Set relative cutoff.</p> <p>Parameters:</p> Name Type Description Default <code>rel_cutoff</code> <code>float</code> <p>Relative cutoff for multi-grid</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for relative cutoff</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_rel_cutoff(self, rel_cutoff):\n    \"\"\"Set relative cutoff.\n\n    Parameters\n    ----------\n    rel_cutoff : float\n        Relative cutoff for multi-grid\n\n    Returns\n    -------\n    dict\n        Update dictionary for relative cutoff\n    \"\"\"\n    update_d = {\"FORCE_EVAL\": {\"DFT\": {\"MGRID\": {\"REL_CUTOFF\": rel_cutoff}}}}\n    return update_d\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_restart","title":"<code>set_restart(flag)</code>","text":"<p>Set restart file for CP2K calculation.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>bool</code> <p>Whether to use restart file</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for restart settings</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_restart(self, flag):\n    \"\"\"Set restart file for CP2K calculation.\n\n    Parameters\n    ----------\n    flag : bool\n        Whether to use restart file\n\n    Returns\n    -------\n    dict\n        Update dictionary for restart settings\n    \"\"\"\n    if flag:\n        update_d = {\n            \"EXT_RESTART\": {\n                \"RESTART_FILE_NAME\": \"{}-1.restart\".format(\n                    self.input_dict[\"GLOBAL\"][\"PROJECT\"]\n                )\n            }\n        }\n        return update_d\n    else:\n        return {}\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_smear","title":"<code>set_smear(flag)</code>","text":"<p>Set smearing method for SCF calculation.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>bool</code> <p>Whether to enable smearing</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for smearing settings</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_smear(self, flag):\n    \"\"\"Set smearing method for SCF calculation.\n\n    Parameters\n    ----------\n    flag : bool\n        Whether to enable smearing\n\n    Returns\n    -------\n    dict\n        Update dictionary for smearing settings\n    \"\"\"\n    if not flag:\n        update_d = {\n            \"FORCE_EVAL\": {\n                \"DFT\": {\n                    \"SCF\": {\n                        \"ADDED_MOS\": 0,\n                        \"CHOLESKY\": \"RESTORE\",\n                        \"SMEAR\": {\"_\": \".FALSE.\"},\n                        \"DIAGONALIZATION\": {\"_\": \".FALSE.\"},\n                    }\n                }\n            }\n        }\n        return update_d\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_totden","title":"<code>set_totden(flag)</code>","text":"<p>Set total density cube output.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>bool</code> <p>Whether to output total density cube</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for total density output</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_totden(self, flag):\n    \"\"\"Set total density cube output.\n\n    Parameters\n    ----------\n    flag : bool\n        Whether to output total density cube\n\n    Returns\n    -------\n    dict\n        Update dictionary for total density output\n    \"\"\"\n    if flag:\n        update_d = {\n            \"FORCE_EVAL\": {\n                \"DFT\": {\n                    \"PRINT\": {\n                        \"TOT_DENSITY_CUBE\": {\n                            \"ADD_LAST\": \"NUMERIC\",\n                            \"STRIDE\": \"1 1 1\",\n                        }\n                    }\n                }\n            }\n        }\n        return update_d\n    else:\n        return {}\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_uks","title":"<code>set_uks(flag)</code>","text":"<p>Set unrestricted Kohn-Sham calculation.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>bool</code> <p>Whether to use UKS calculation</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for UKS</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_uks(self, flag):\n    \"\"\"Set unrestricted Kohn-Sham calculation.\n\n    Parameters\n    ----------\n    flag : bool\n        Whether to use UKS calculation\n\n    Returns\n    -------\n    dict\n        Update dictionary for UKS\n    \"\"\"\n    if flag:\n        update_d = {\"FORCE_EVAL\": {\"DFT\": {\"UKS\": \".TRUE.\"}}}\n        return update_d\n    else:\n        return {}\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.set_wfn_restart","title":"<code>set_wfn_restart(wfn_file)</code>","text":"<p>Set wavefunction restart file.</p> <p>Parameters:</p> Name Type Description Default <code>wfn_file</code> <code>str or None</code> <p>Path to wavefunction restart file</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Update dictionary for wavefunction restart file</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def set_wfn_restart(self, wfn_file):\n    \"\"\"Set wavefunction restart file.\n\n    Parameters\n    ----------\n    wfn_file : str or None\n        Path to wavefunction restart file\n\n    Returns\n    -------\n    dict\n        Update dictionary for wavefunction restart file\n    \"\"\"\n    update_d = {}\n    if wfn_file is not None:\n        update_d = {\n            \"FORCE_EVAL\": {\n                \"DFT\": {\"WFN_RESTART_FILE_NAME\": os.path.abspath(wfn_file)}\n            }\n        }\n    return update_d\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.update_dp","title":"<code>update_dp(dp_model)</code>","text":"<p>Update CP2K input with Deep Potential model.</p> <p>Parameters:</p> Name Type Description Default <code>dp_model</code> <code>str</code> <p>Path to Deep Potential model file</p> required Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def update_dp(self, dp_model: str):\n    \"\"\"Update CP2K input with Deep Potential model.\n\n    Parameters\n    ----------\n    dp_model : str\n        Path to Deep Potential model file\n    \"\"\"\n    from deepmd.infer import DeepPot\n\n    dp = DeepPot(dp_model)\n    type_map = dp.tmap\n    for ii, atype in enumerate(type_map):\n        self.input_dict[\"FORCE_EVAL\"][\"MM\"][\"FORCEFIELD\"][\"CHARGE\"].append(\n            {\n                \"ATOM\": atype,\n                \"CHARGE\": 0.0,\n            }\n        )\n        self.input_dict[\"FORCE_EVAL\"][\"MM\"][\"FORCEFIELD\"][\"NONBONDED\"][\n            \"DEEPMD\"\n        ].append(\n            {\n                \"ATOMS\": f\"{atype} {atype}\",\n                \"POT_FILE_NAME\": dp_model,\n                \"ATOM_DEEPMD_TYPE\": ii,\n            }\n        )\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kInput.write","title":"<code>write(output_dir='.', fp_params=None, save_dict=False)</code>","text":"<p>Generate coord.xyz and input.inp for CP2K calculation at output_dir.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>str</code> <p>directory to store coord.xyz and input.inp</p> <code>'.'</code> <code>fp_params</code> <code>dict</code> <p>dict for updated parameters</p> <code>None</code> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def write(self, output_dir=\".\", fp_params=None, save_dict=False):\n    \"\"\"\n    Generate coord.xyz and input.inp for CP2K calculation at output_dir.\n\n    Parameters\n    ----------\n    output_dir : str\n        directory to store coord.xyz and input.inp\n    fp_params : dict\n        dict for updated parameters\n    \"\"\"\n    if fp_params is None:\n        fp_params = {}\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n\n    cell = self.atoms.get_cell()\n    cell_a = np.array2string(\n        cell[0], formatter={\"float_kind\": lambda x: f\"{x:.4f}\"}\n    )\n    cell_a = cell_a[1:-1]\n    cell_b = np.array2string(\n        cell[1], formatter={\"float_kind\": lambda x: f\"{x:.4f}\"}\n    )\n    cell_b = cell_b[1:-1]\n    cell_c = np.array2string(\n        cell[2], formatter={\"float_kind\": lambda x: f\"{x:.4f}\"}\n    )\n    cell_c = cell_c[1:-1]\n\n    user_config = fp_params\n    update_dict(self.input_dict, user_config)\n\n    if self.input_dict[\"FORCE_EVAL\"].get(\"QMMM\", None) is not None:\n        cell_config = {\n            \"FORCE_EVAL\": {\n                \"SUBSYS\": {\"CELL\": {\"A\": cell_a, \"B\": cell_b, \"C\": cell_c}},\n                \"QMMM\": {\n                    \"CELL\": {\n                        \"A\": cell_a,\n                        \"B\": cell_b,\n                        \"C\": cell_c,\n                        \"PERIODIC\": \"XYZ\",\n                    }\n                },\n            }\n        }\n    else:\n        cell_config = {\n            \"FORCE_EVAL\": {\n                \"SUBSYS\": {\"CELL\": {\"A\": cell_a, \"B\": cell_b, \"C\": cell_c}}\n            }\n        }\n\n    update_dict(self.input_dict, cell_config)\n    # output list\n    input_str = iterdict(self.input_dict, out_list=[\"\\n\"], loop_idx=0)\n    # del input_str[0]\n    # del input_str[-1]\n    # print(input_str)\n    str = \"\\n\".join(input_str)\n    str = str.strip(\"\\n\")\n\n    io.write(os.path.join(output_dir, \"coord.xyz\"), self.atoms)\n    with open(os.path.join(output_dir, \"input.inp\"), \"w\", encoding=\"utf-8\") as f:\n        f.write(str)\n\n    if save_dict:\n        save_dict_json(self.input_dict, os.path.join(output_dir, \"input.json\"))\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput","title":"<code>Cp2kOutput</code>","text":"<p>Class for parsing CP2K output files.</p> <p>This class provides methods to extract various properties from CP2K output files, including energies, forces, charges, and other calculation results.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Path to CP2K output file, by default \"output.out\"</p> <code>'output.out'</code> <code>ignore_warning</code> <code>bool</code> <p>Whether to ignore SCF convergence warnings, by default False</p> <code>False</code> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>class Cp2kOutput:\n    \"\"\"\n    Class for parsing CP2K output files.\n\n    This class provides methods to extract various properties from CP2K output files,\n    including energies, forces, charges, and other calculation results.\n\n    Parameters\n    ----------\n    fname : str, optional\n        Path to CP2K output file, by default \"output.out\"\n    ignore_warning : bool, optional\n        Whether to ignore SCF convergence warnings, by default False\n    \"\"\"\n\n    def __init__(self, fname=\"output.out\", ignore_warning=False) -&gt; None:\n        self.output_file = fname\n        with open(fname, encoding=\"UTF-8\") as f:\n            self.content = f.readlines()\n        self.string = \"\".join(self.content)\n\n        self.check_scf = not ignore_warning\n        if (self.check_scf) and (self.scf_loop == -1):\n            raise Warning(\"SCF run NOT converged\")\n\n        self.natoms = len(self.atoms)\n\n    @property\n    def worktime(self):\n        \"\"\"Get CP2K calculation time.\n\n        Returns\n        -------\n        float\n            Total calculation time in seconds\n        \"\"\"\n        # pattern = r\"\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3}\"\n        # out = re.findall(pattern, self.string)\n        # t = re.split(r\"\\.|:|-|\\s\", out[0])\n        # start_time = datetime.datetime(\n        #     int(t[0]), int(t[1]), int(t[2]), int(t[3]), int(t[4]), int(t[5]), int(t[6])\n        # )\n        # t = re.split(r\"\\.|:|-|\\s\", out[-1])\n        # end_time = datetime.datetime(\n        #     int(t[0]), int(t[1]), int(t[2]), int(t[3]), int(t[4]), int(t[5]), int(t[6])\n        # )\n        # delta_t = end_time - start_time\n        # run_time = delta_t.total_seconds()\n        # return run_time\n        return self.timing_dict[\"CP2K\"]\n\n    def grep_text_search(self, pattern):\n        \"\"\"Search for a pattern in CP2K output file.\n\n        Parameters\n        ----------\n        pattern : str\n            Regular expression pattern to search for\n\n        Returns\n        -------\n        str\n            Line containing the pattern, or empty string if not found\n        \"\"\"\n        search_pattern = re.compile(pattern)\n        scf_pattern = re.compile(r\"SCF run converged in\")\n\n        flag = False\n        scf_flag = not self.check_scf\n        line = None\n        for line in self.content:\n            line = line.strip(\"\\n\")\n            if scf_pattern.search(line) is not None:\n                scf_flag = True\n            if not scf_flag:\n                continue\n            if search_pattern.search(line) is not None:\n                flag = True\n                break\n        if flag:\n            return line\n        else:\n            return \"\"\n\n    def grep_texts(self, start_pattern, end_pattern):\n        \"\"\"Extract text between start and end patterns.\n\n        Parameters\n        ----------\n        start_pattern : str\n            Regular expression pattern for start of text block\n        end_pattern : str\n            Regular expression pattern for end of text block\n\n        Returns\n        -------\n        tuple\n            Tuple containing (nframe, data_lines) where nframe is the number of\n            matching blocks and data_lines is a 2D array of the extracted text\n        \"\"\"\n        start_pattern = re.compile(start_pattern)\n        end_pattern = re.compile(end_pattern)\n        scf_pattern = re.compile(r\"SCF run converged in\")\n\n        flag = False\n        scf_flag = not self.check_scf\n        data_lines = []\n        nframe = 0\n        for line in self.content:\n            line = line.strip(\"\\n\")\n            if scf_pattern.search(line) is not None:\n                scf_flag = True\n            if not scf_flag:\n                continue\n            if start_pattern.match(line):\n                flag = True\n            if end_pattern.match(line):\n                assert flag is True, (flag, \"No data is found in this file.\")\n                flag = False\n                nframe += 1\n            if flag is True:\n                data_lines.append(line)\n        return nframe, np.reshape(data_lines, (nframe, -1))\n\n    def grep_texts_by_nlines(self, start_pattern, nlines):\n        \"\"\"Extract a fixed number of lines after a pattern.\n\n        Parameters\n        ----------\n        start_pattern : str\n            Regular expression pattern to search for\n        nlines : int\n            Number of lines to extract after the pattern\n\n        Returns\n        -------\n        tuple\n            Tuple containing (nframe, data_lines) where nframe is the number of\n            matching blocks and data_lines is a 2D array of the extracted text\n        \"\"\"\n        start_pattern = re.compile(start_pattern)\n        scf_pattern = re.compile(r\"SCF run converged in\")\n\n        data_lines = []\n        nframe = 0\n        scf_flag = not self.check_scf\n        for ii, line in enumerate(self.content):\n            line = line.strip(\"\\n\")\n            if scf_pattern.search(line) is not None:\n                scf_flag = True\n            if not scf_flag:\n                continue\n            if start_pattern.search(line) is not None:\n                data_lines.append(self.content[ii : ii + nlines])\n                nframe += 1\n                continue\n        if nframe == 0:\n            raise AttributeError(\"No data is found in this file.\")\n        return nframe, np.reshape(data_lines, (nframe, -1))\n\n    @property\n    def coord(self):\n        \"\"\"\n        Get atomic coordinate from cp2k output.\n\n        Return:\n            coord numpy array (n_atom, 3)\n        \"\"\"\n        out = parse_init_atomic_coordinates(self.string)\n        self.chemical_symbols = out[2]\n        return out[0]\n\n    @property\n    def atoms(self):\n        \"\"\"Get ASE Atoms object from CP2K output.\n\n        Returns\n        -------\n        ase.Atoms\n            ASE Atoms object with positions, cell, and periodic boundary conditions\n        \"\"\"\n        positions = self.coord\n        atoms = Atoms(symbols=self.chemical_symbols, positions=positions)\n        check_scf = self.check_scf\n        self.check_scf = False\n        out = parse_all_cells(self.string)\n        self.check_scf = check_scf\n\n        atoms.set_cell(out[0])\n        atoms.set_pbc(True)\n        return atoms\n\n    @property\n    def force(self):\n        \"\"\"\n        Get atomic force from cp2k output.\n\n        Return:\n            force numpy array (n_atom, 3)\n        \"\"\"\n        out = parse_atomic_forces_list(self.string)\n        return out[0] * AU_TO_EV_EVERY_ANG\n\n    @property\n    def energy(self):\n        \"\"\"Get total energy from CP2K output.\n\n        Returns\n        -------\n        float\n            Total energy in eV\n        \"\"\"\n        out = parse_energies_list(self.string)\n        return out[0] * AU_TO_EV\n\n    @property\n    def scf_loop(self):\n        \"\"\"Get number of SCF iterations.\n\n        Returns\n        -------\n        int\n            Number of SCF iterations, or -1 if SCF did not converge\n        \"\"\"\n        pattern = r\"\\s+SCF\\srun\\sconverged\\sin\\s+\\d+\"\n        out = re.findall(pattern, self.string)\n        if len(out) == 0:\n            return -1\n        else:\n            return int(out[0].split(\" \")[-1])\n\n    @property\n    def fermi(self):\n        \"\"\"Get Fermi energy from CP2K output.\n\n        Returns\n        -------\n        float\n            Fermi energy in eV\n        \"\"\"\n        if self.uks:\n            fermi = []\n            for line in self.content:\n                if re.search(\"Fermi Energy \", line):\n                    fermi.append(float(line.split()[-1]))\n            assert (\n                len(fermi) == 2\n            ), \"There should be two Fermi energy in UKS calculation\"\n            return max(fermi)\n        else:\n            try:\n                pattern = r\"\\s+Fermi\\senergy:\\s+.\\d\\.\\d+\"\n                out = re.findall(pattern, self.string)\n                return float(out[0].split(\" \")[-1]) * AU_TO_EV\n            except IndexError:\n                for line in self.content:\n                    if re.search(\"Fermi Energy \", line):\n                        return float(line.split()[-1])\n\n    @property\n    def m_charge(self):\n        \"\"\"Get Mulliken charges from CP2K output.\n\n        Returns\n        -------\n        numpy.ndarray\n            Array of Mulliken charges for each atom\n        \"\"\"\n        start_pattern = \"Mulliken Population Analysis\"\n        nframe, data_lines = self.grep_texts_by_nlines(start_pattern, self.natoms + 3)\n        data_list = []\n        for line in data_lines[-1, 3:]:\n            line_list = line.split()\n            data_list.append(float(line_list[-1]))\n        return np.reshape(data_list, -1)\n\n    @property\n    def h_charge(self):\n        \"\"\"Get Hirshfeld charges from CP2K output.\n\n        Returns\n        -------\n        numpy.ndarray\n            Array of Hirshfeld charges for each atom\n        \"\"\"\n        start_pattern = \"Hirshfeld Charges\"\n        _nf, data_lines = self.grep_texts_by_nlines(start_pattern, self.natoms + 3)\n        data_list = []\n        for line in data_lines[-1, 3:]:\n            line_list = line.split()\n            data_list.append(float(line_list[-1]))\n        return np.reshape(data_list, -1)\n\n    @property\n    def dipole_moment(self):\n        \"\"\"Get dipole moment from CP2K output.\n\n        Returns\n        -------\n        numpy.ndarray\n            Dipole moment vector [x, y, z] in Debye\n        \"\"\"\n        pattern = \"Dipole moment\"\n        _nf, data_lines = self.grep_texts_by_nlines(pattern, 2)\n\n        data_list = []\n        for line in data_lines[-1, 1:]:\n            line_list = line.split()\n            data_list.append(list(map(float, line_list[1:-1:2])))\n        return np.reshape(data_list, 3)\n\n    @property\n    def surf_dipole_moment(self):\n        \"\"\"Grep surface dipole moment.\n\n        Total dipole moment perpendicular to\n        the slab [electrons-Angstroem]:              -1.5878220042.\n        \"\"\"\n        pattern = \"Total dipole moment perpendicular to\"\n        _nf, data_lines = self.grep_texts_by_nlines(pattern, 2)\n\n        line = data_lines[-1, 1]\n        line_list = line.split()\n        return float(line_list[-1])\n\n    @property\n    def potdrop(self):\n        \"\"\"Calculate potential drop across the surface.\n\n        Returns\n        -------\n        float\n            Potential drop in V\n        \"\"\"\n        cross_area = np.linalg.norm(np.cross(self.atoms.cell[0], self.atoms.cell[1]))\n        DeltaV = self.surf_dipole_moment / cross_area / EPSILON\n        return DeltaV\n\n    @property\n    def energy_dict(self):\n        \"\"\"Get detailed energy breakdown from CP2K output.\n\n        Returns\n        -------\n        dict\n            Dictionary containing various energy components in eV\n        \"\"\"\n        energy_dict = {}\n\n        start_pattern = r\"  Total charge density g-space grids:\"\n        end_pattern = r\"  Total energy:\"\n        _nf, data_lines = self.grep_texts(start_pattern, end_pattern)\n\n        for kw in data_lines[-1, 2:-1]:\n            kw = kw.split(\":\")\n            k = kw[0].strip(\" \")\n            v = float(kw[1]) * AU_TO_EV\n            energy_dict[k] = v\n\n        energy_dict.pop(\"Fermi energy\", None)\n\n        tot_e = 0.0\n        for v in energy_dict.values():\n            tot_e += v\n        energy_dict[\"total\"] = tot_e\n\n        return energy_dict\n\n    @property\n    def multiplicity(self):\n        \"\"\"Get spin multiplicity from CP2K output.\n\n        Returns\n        -------\n        int\n            Spin multiplicity of the system\n        \"\"\"\n        for line in self.content:\n            if \"Multiplicity\" in line:\n                break\n        return int(line.split()[-1])\n\n    @property\n    def uks(self):\n        \"\"\"Check if calculation is spin-unrestricted.\n\n        Returns\n        -------\n        bool\n            True if calculation is spin-unrestricted (UKS), False otherwise\n        \"\"\"\n        return any(re.search(\"Spin unrestricted\", line) for line in self.content)\n\n    @property\n    def charge(self):\n        \"\"\"Get system charge from CP2K output.\n\n        Returns\n        -------\n        int\n            Total charge of the system\n        \"\"\"\n        for line in self.content:\n            if \"Charge\" in line:\n                break\n        return int(line.split()[-1])\n\n    @property\n    def timing_dict(self):\n        \"\"\"Get timing information from CP2K output.\n\n        Returns\n        -------\n        dict\n            Dictionary containing timing information for different CP2K modules\n        \"\"\"\n        t_dict = {}\n        flag = False\n        for line in self.content:\n            if \"SUBROUTINE\" in line:\n                flag = True\n                continue\n            if flag:\n                if \"---\" in line:\n                    flag = False\n                    break\n                data = line.split()\n                if len(data) == 7:\n                    # print(data)\n                    t_dict[data[0]] = float(data[-2])\n        return t_dict\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.atoms","title":"<code>atoms</code>  <code>property</code>","text":"<p>Get ASE Atoms object from CP2K output.</p> <p>Returns:</p> Type Description <code>Atoms</code> <p>ASE Atoms object with positions, cell, and periodic boundary conditions</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.charge","title":"<code>charge</code>  <code>property</code>","text":"<p>Get system charge from CP2K output.</p> <p>Returns:</p> Type Description <code>int</code> <p>Total charge of the system</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.coord","title":"<code>coord</code>  <code>property</code>","text":"<p>Get atomic coordinate from cp2k output.</p> <p>Return:     coord numpy array (n_atom, 3)</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.dipole_moment","title":"<code>dipole_moment</code>  <code>property</code>","text":"<p>Get dipole moment from CP2K output.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Dipole moment vector [x, y, z] in Debye</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.energy","title":"<code>energy</code>  <code>property</code>","text":"<p>Get total energy from CP2K output.</p> <p>Returns:</p> Type Description <code>float</code> <p>Total energy in eV</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.energy_dict","title":"<code>energy_dict</code>  <code>property</code>","text":"<p>Get detailed energy breakdown from CP2K output.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing various energy components in eV</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.fermi","title":"<code>fermi</code>  <code>property</code>","text":"<p>Get Fermi energy from CP2K output.</p> <p>Returns:</p> Type Description <code>float</code> <p>Fermi energy in eV</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.force","title":"<code>force</code>  <code>property</code>","text":"<p>Get atomic force from cp2k output.</p> <p>Return:     force numpy array (n_atom, 3)</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.h_charge","title":"<code>h_charge</code>  <code>property</code>","text":"<p>Get Hirshfeld charges from CP2K output.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of Hirshfeld charges for each atom</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.m_charge","title":"<code>m_charge</code>  <code>property</code>","text":"<p>Get Mulliken charges from CP2K output.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of Mulliken charges for each atom</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.multiplicity","title":"<code>multiplicity</code>  <code>property</code>","text":"<p>Get spin multiplicity from CP2K output.</p> <p>Returns:</p> Type Description <code>int</code> <p>Spin multiplicity of the system</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.potdrop","title":"<code>potdrop</code>  <code>property</code>","text":"<p>Calculate potential drop across the surface.</p> <p>Returns:</p> Type Description <code>float</code> <p>Potential drop in V</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.scf_loop","title":"<code>scf_loop</code>  <code>property</code>","text":"<p>Get number of SCF iterations.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of SCF iterations, or -1 if SCF did not converge</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.surf_dipole_moment","title":"<code>surf_dipole_moment</code>  <code>property</code>","text":"<p>Grep surface dipole moment.</p> <p>Total dipole moment perpendicular to the slab [electrons-Angstroem]:              -1.5878220042.</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.timing_dict","title":"<code>timing_dict</code>  <code>property</code>","text":"<p>Get timing information from CP2K output.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing timing information for different CP2K modules</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.uks","title":"<code>uks</code>  <code>property</code>","text":"<p>Check if calculation is spin-unrestricted.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if calculation is spin-unrestricted (UKS), False otherwise</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.worktime","title":"<code>worktime</code>  <code>property</code>","text":"<p>Get CP2K calculation time.</p> <p>Returns:</p> Type Description <code>float</code> <p>Total calculation time in seconds</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.grep_text_search","title":"<code>grep_text_search(pattern)</code>","text":"<p>Search for a pattern in CP2K output file.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>Regular expression pattern to search for</p> required <p>Returns:</p> Type Description <code>str</code> <p>Line containing the pattern, or empty string if not found</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def grep_text_search(self, pattern):\n    \"\"\"Search for a pattern in CP2K output file.\n\n    Parameters\n    ----------\n    pattern : str\n        Regular expression pattern to search for\n\n    Returns\n    -------\n    str\n        Line containing the pattern, or empty string if not found\n    \"\"\"\n    search_pattern = re.compile(pattern)\n    scf_pattern = re.compile(r\"SCF run converged in\")\n\n    flag = False\n    scf_flag = not self.check_scf\n    line = None\n    for line in self.content:\n        line = line.strip(\"\\n\")\n        if scf_pattern.search(line) is not None:\n            scf_flag = True\n        if not scf_flag:\n            continue\n        if search_pattern.search(line) is not None:\n            flag = True\n            break\n    if flag:\n        return line\n    else:\n        return \"\"\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.grep_texts","title":"<code>grep_texts(start_pattern, end_pattern)</code>","text":"<p>Extract text between start and end patterns.</p> <p>Parameters:</p> Name Type Description Default <code>start_pattern</code> <code>str</code> <p>Regular expression pattern for start of text block</p> required <code>end_pattern</code> <code>str</code> <p>Regular expression pattern for end of text block</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple containing (nframe, data_lines) where nframe is the number of matching blocks and data_lines is a 2D array of the extracted text</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def grep_texts(self, start_pattern, end_pattern):\n    \"\"\"Extract text between start and end patterns.\n\n    Parameters\n    ----------\n    start_pattern : str\n        Regular expression pattern for start of text block\n    end_pattern : str\n        Regular expression pattern for end of text block\n\n    Returns\n    -------\n    tuple\n        Tuple containing (nframe, data_lines) where nframe is the number of\n        matching blocks and data_lines is a 2D array of the extracted text\n    \"\"\"\n    start_pattern = re.compile(start_pattern)\n    end_pattern = re.compile(end_pattern)\n    scf_pattern = re.compile(r\"SCF run converged in\")\n\n    flag = False\n    scf_flag = not self.check_scf\n    data_lines = []\n    nframe = 0\n    for line in self.content:\n        line = line.strip(\"\\n\")\n        if scf_pattern.search(line) is not None:\n            scf_flag = True\n        if not scf_flag:\n            continue\n        if start_pattern.match(line):\n            flag = True\n        if end_pattern.match(line):\n            assert flag is True, (flag, \"No data is found in this file.\")\n            flag = False\n            nframe += 1\n        if flag is True:\n            data_lines.append(line)\n    return nframe, np.reshape(data_lines, (nframe, -1))\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kOutput.grep_texts_by_nlines","title":"<code>grep_texts_by_nlines(start_pattern, nlines)</code>","text":"<p>Extract a fixed number of lines after a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>start_pattern</code> <code>str</code> <p>Regular expression pattern to search for</p> required <code>nlines</code> <code>int</code> <p>Number of lines to extract after the pattern</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple containing (nframe, data_lines) where nframe is the number of matching blocks and data_lines is a 2D array of the extracted text</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def grep_texts_by_nlines(self, start_pattern, nlines):\n    \"\"\"Extract a fixed number of lines after a pattern.\n\n    Parameters\n    ----------\n    start_pattern : str\n        Regular expression pattern to search for\n    nlines : int\n        Number of lines to extract after the pattern\n\n    Returns\n    -------\n    tuple\n        Tuple containing (nframe, data_lines) where nframe is the number of\n        matching blocks and data_lines is a 2D array of the extracted text\n    \"\"\"\n    start_pattern = re.compile(start_pattern)\n    scf_pattern = re.compile(r\"SCF run converged in\")\n\n    data_lines = []\n    nframe = 0\n    scf_flag = not self.check_scf\n    for ii, line in enumerate(self.content):\n        line = line.strip(\"\\n\")\n        if scf_pattern.search(line) is not None:\n            scf_flag = True\n        if not scf_flag:\n            continue\n        if start_pattern.search(line) is not None:\n            data_lines.append(self.content[ii : ii + nlines])\n            nframe += 1\n            continue\n    if nframe == 0:\n        raise AttributeError(\"No data is found in this file.\")\n    return nframe, np.reshape(data_lines, (nframe, -1))\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kPDOS","title":"<code>Cp2kPDOS</code>","text":"<p>Class for handling CP2K projected density of states (PDOS) files.</p> <p>This class provides methods to read and analyze PDOS data from CP2K, including calculation of various electronic properties.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Path to PDOS file</p> required Source code in <code>toolbox/io/cp2k.py</code> <pre><code>class Cp2kPDOS:\n    \"\"\"\n    Class for handling CP2K projected density of states (PDOS) files.\n\n    This class provides methods to read and analyze PDOS data from CP2K,\n    including calculation of various electronic properties.\n\n    Parameters\n    ----------\n    file_name : str\n        Path to PDOS file\n    \"\"\"\n\n    def __init__(self, file_name: str) -&gt; None:\n        self.file_name = file_name\n        with open(file_name, encoding=\"UTF-8\") as f:\n            line = f.readline()\n        # grep the word after \"kind\"\n        self.element = line.split()[line.split().index(\"kind\") + 1]\n        self.fermi = float(line.split()[-2]) * AU_TO_EV\n\n        self._data = np.loadtxt(file_name)\n        self.energies = self._data[:, 1]\n        self.occupation = self._data[:, 2]\n\n        self.dos_data = None\n        self.pdos_data = None\n\n    def get_dos(self, broadening: float = 0.01, energy_step: float = 0.01):\n        \"\"\"Ref: https://manual.cp2k.org/trunk/CP2K_INPUT/FORCE_EVAL/PROPERTIES/BANDSTRUCTURE/DOS.html.\"\"\"\n        bin_edges = np.arange(\n            self.energies[0], self.energies[-1] + energy_step, energy_step\n        )\n        bins, dos = gaussian_filter(self.energies, bin_edges, broadening)\n        self.dos_data = (bins, dos)\n        return self.dos_data\n\n    def get_pdos(self, broadening=0.01, energy_step=0.01, dos_type=\"total\"):\n        \"\"\"Ref: https://manual.cp2k.org/trunk/CP2K_INPUT/FORCE_EVAL/PROPERTIES/BANDSTRUCTURE/DOS.html.\"\"\"\n        bin_edges = np.arange(\n            self.energies[0], self.energies[-1] + energy_step, energy_step\n        )\n        bins, pdos = gaussian_filter(\n            self.energies, bin_edges, broadening, weight=self.get_raw_pdos(dos_type)\n        )\n        self.pdos_data = (bins, pdos)\n        return self.pdos_data\n\n    def get_raw_pdos(self, dos_type):\n        \"\"\"Get raw PDOS data of specified type.\n\n        Parameters\n        ----------\n        dos_type : str\n            Type of PDOS to retrieve (e.g., 'total', 's', 'p', 'd', 'f')\n\n        Returns\n        -------\n        numpy.ndarray\n            Raw PDOS data\n\n        Raises\n        ------\n        NameError\n            If the specified PDOS type does not exist\n        \"\"\"\n        try:\n            return getattr(self, f\"_get_raw_pdos_{dos_type}\")()\n        except AttributeError as e:\n            raise NameError(\"PDOS type does not exist!\") from e\n\n    def _get_raw_pdos_total(self):\n        return self._data[:, 3:].sum(axis=1)\n\n    def _get_raw_pdos_s(self):\n        return self._data[:, 3]\n\n    def _get_raw_pdos_p(self):\n        return self._data[:, 4:7].sum(axis=1)\n\n    def _get_raw_pdos_d(self):\n        return self._data[:, 7:12].sum(axis=1)\n\n    def _get_raw_pdos_f(self):\n        return self._data[:, 12:19].sum(axis=1)\n\n    @property\n    def homo(self):\n        \"\"\"Get highest occupied molecular orbital (HOMO) energy.\n\n        Returns\n        -------\n        float\n            HOMO energy relative to Fermi level in eV\n        \"\"\"\n        homo_idx = np.where(self.occupation == 0)[0][0] - 1\n        return self.energies[homo_idx] - self.fermi\n\n    @property\n    def lumo(self):\n        \"\"\"Get lowest unoccupied molecular orbital (LUMO) energy.\n\n        Returns\n        -------\n        float\n            LUMO energy relative to Fermi level in eV\n        \"\"\"\n        return self.energies[self.occupation == 0][0] - self.fermi\n\n    @property\n    def vbm(self):\n        \"\"\"Get valence band maximum (VBM) energy.\n\n        Returns\n        -------\n        float\n            VBM energy relative to Fermi level in eV\n        \"\"\"\n        raw_dos = self.get_raw_pdos(\"total\")\n        mask = (self.occupation &gt; 1e-5) &amp; (raw_dos &gt; 1e-3)\n        try:\n            return self.energies[mask].max() - self.fermi\n        except ValueError:\n            print(\"Warning: No VBM is found!\")\n            return self.energies.min() - self.fermi\n\n    @property\n    def cbm(self):\n        \"\"\"Get conduction band minimum (CBM) energy.\n\n        Returns\n        -------\n        float\n            CBM energy relative to Fermi level in eV\n        \"\"\"\n        raw_dos = self.get_raw_pdos(\"total\")\n        mask = (self.occupation &lt; 1e-5) &amp; (raw_dos &gt; 1e-3)\n        try:\n            return self.energies[mask].min() - self.fermi\n        except ValueError:\n            print(\"Warning: No CBM is found!\")\n            return self.energies.max() - self.fermi\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kPDOS.cbm","title":"<code>cbm</code>  <code>property</code>","text":"<p>Get conduction band minimum (CBM) energy.</p> <p>Returns:</p> Type Description <code>float</code> <p>CBM energy relative to Fermi level in eV</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kPDOS.homo","title":"<code>homo</code>  <code>property</code>","text":"<p>Get highest occupied molecular orbital (HOMO) energy.</p> <p>Returns:</p> Type Description <code>float</code> <p>HOMO energy relative to Fermi level in eV</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kPDOS.lumo","title":"<code>lumo</code>  <code>property</code>","text":"<p>Get lowest unoccupied molecular orbital (LUMO) energy.</p> <p>Returns:</p> Type Description <code>float</code> <p>LUMO energy relative to Fermi level in eV</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kPDOS.vbm","title":"<code>vbm</code>  <code>property</code>","text":"<p>Get valence band maximum (VBM) energy.</p> <p>Returns:</p> Type Description <code>float</code> <p>VBM energy relative to Fermi level in eV</p>"},{"location":"api/#toolbox.io.cp2k.Cp2kPDOS.get_dos","title":"<code>get_dos(broadening=0.01, energy_step=0.01)</code>","text":"<p>Ref: https://manual.cp2k.org/trunk/CP2K_INPUT/FORCE_EVAL/PROPERTIES/BANDSTRUCTURE/DOS.html.</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def get_dos(self, broadening: float = 0.01, energy_step: float = 0.01):\n    \"\"\"Ref: https://manual.cp2k.org/trunk/CP2K_INPUT/FORCE_EVAL/PROPERTIES/BANDSTRUCTURE/DOS.html.\"\"\"\n    bin_edges = np.arange(\n        self.energies[0], self.energies[-1] + energy_step, energy_step\n    )\n    bins, dos = gaussian_filter(self.energies, bin_edges, broadening)\n    self.dos_data = (bins, dos)\n    return self.dos_data\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kPDOS.get_pdos","title":"<code>get_pdos(broadening=0.01, energy_step=0.01, dos_type='total')</code>","text":"<p>Ref: https://manual.cp2k.org/trunk/CP2K_INPUT/FORCE_EVAL/PROPERTIES/BANDSTRUCTURE/DOS.html.</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def get_pdos(self, broadening=0.01, energy_step=0.01, dos_type=\"total\"):\n    \"\"\"Ref: https://manual.cp2k.org/trunk/CP2K_INPUT/FORCE_EVAL/PROPERTIES/BANDSTRUCTURE/DOS.html.\"\"\"\n    bin_edges = np.arange(\n        self.energies[0], self.energies[-1] + energy_step, energy_step\n    )\n    bins, pdos = gaussian_filter(\n        self.energies, bin_edges, broadening, weight=self.get_raw_pdos(dos_type)\n    )\n    self.pdos_data = (bins, pdos)\n    return self.pdos_data\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.Cp2kPDOS.get_raw_pdos","title":"<code>get_raw_pdos(dos_type)</code>","text":"<p>Get raw PDOS data of specified type.</p> <p>Parameters:</p> Name Type Description Default <code>dos_type</code> <code>str</code> <p>Type of PDOS to retrieve (e.g., 'total', 's', 'p', 'd', 'f')</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Raw PDOS data</p> <p>Raises:</p> Type Description <code>NameError</code> <p>If the specified PDOS type does not exist</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def get_raw_pdos(self, dos_type):\n    \"\"\"Get raw PDOS data of specified type.\n\n    Parameters\n    ----------\n    dos_type : str\n        Type of PDOS to retrieve (e.g., 'total', 's', 'p', 'd', 'f')\n\n    Returns\n    -------\n    numpy.ndarray\n        Raw PDOS data\n\n    Raises\n    ------\n    NameError\n        If the specified PDOS type does not exist\n    \"\"\"\n    try:\n        return getattr(self, f\"_get_raw_pdos_{dos_type}\")()\n    except AttributeError as e:\n        raise NameError(\"PDOS type does not exist!\") from e\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.MultiFrameCp2kOutput","title":"<code>MultiFrameCp2kOutput</code>","text":"<p>               Bases: <code>Cp2kOutput</code></p> <p>Class for parsing CP2K output files with multiple frames.</p> <p>This class extends Cp2kOutput to handle multi-frame calculations such as molecular dynamics or geometry optimizations.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Path to CP2K output file, by default \"output.out\"</p> <code>'output.out'</code> <code>ignore_warning</code> <code>bool</code> <p>Whether to ignore SCF convergence warnings, by default False</p> <code>False</code> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>class MultiFrameCp2kOutput(Cp2kOutput):\n    \"\"\"\n    Class for parsing CP2K output files with multiple frames.\n\n    This class extends Cp2kOutput to handle multi-frame calculations such as\n    molecular dynamics or geometry optimizations.\n\n    Parameters\n    ----------\n    fname : str, optional\n        Path to CP2K output file, by default \"output.out\"\n    ignore_warning : bool, optional\n        Whether to ignore SCF convergence warnings, by default False\n    \"\"\"\n\n    def __init__(self, fname=\"output.out\", ignore_warning=False) -&gt; None:\n        super().__init__(fname, ignore_warning)\n\n    @property\n    def atoms(self):\n        \"\"\"Get ASE Atoms object from multi-frame CP2K output.\n\n        Returns\n        -------\n        ase.Atoms\n            ASE Atoms object with positions, cell, and periodic boundary conditions\n        \"\"\"\n        positions = self.coord\n        atoms = Atoms(symbols=self.chemical_symbols, positions=positions)\n        a = float(self.grep_text_search(r\"Vector a\").split()[-1])\n        b = float(self.grep_text_search(r\"Vector b\").split()[-1])\n        c = float(self.grep_text_search(r\"Vector c\").split()[-1])\n        alpha = float(self.grep_text_search(r\"Angle | alpha\").split()[-1])\n        beta = float(self.grep_text_search(r\"Angle | beta\").split()[-1])\n        gamma = float(self.grep_text_search(r\"Angle | gamma\").split()[-1])\n        atoms.set_cell([a, b, c, alpha, beta, gamma])\n        atoms.set_pbc(True)\n        return atoms\n\n    @property\n    def force(self):\n        \"\"\"\n        Get atomic force from cp2k output.\n\n        Return:\n            force numpy array (n_atom, 3)\n        \"\"\"\n        start_pattern = r\" ATOMIC FORCES in\"\n        end_pattern = r\" SUM OF ATOMIC FORCES\"\n        nframe, data_lines = self.grep_texts(start_pattern, end_pattern)\n        data_lines = np.reshape(data_lines, (nframe, -1))\n\n        data_list = []\n        for line in data_lines[:, 3:].reshape(-1):\n            line_list = line.split()\n            data_list.append(\n                [\n                    float(line_list[3]) * AU_TO_EV_EVERY_ANG,\n                    float(line_list[4]) * AU_TO_EV_EVERY_ANG,\n                    float(line_list[5]) * AU_TO_EV_EVERY_ANG,\n                ]\n            )\n        return np.reshape(data_list, (nframe, -1, 3))\n\n    @property\n    def energy(self):\n        \"\"\"Get total energy from multi-frame CP2K output.\n\n        Returns\n        -------\n        float\n            Total energy in eV\n        \"\"\"\n        data = self.grep_text_search(\"Total energy: \")\n        # data = self.grep_text_search(\"Total FORCE_EVAL\")\n        data = data.replace(\"\\n\", \" \")\n        data = data.split(\" \")\n        return float(data[-1]) * AU_TO_EV\n\n    @property\n    def scf_loop(self):\n        \"\"\"Get number of SCF iterations from multi-frame CP2K output.\n\n        Returns\n        -------\n        int\n            Number of SCF iterations, or -1 if SCF did not converge\n        \"\"\"\n        pattern = r\"\\s+SCF\\srun\\sconverged\\sin\\s+\\d+\"\n        out = re.findall(pattern, self.string)\n        if len(out) == 0:\n            return -1\n        else:\n            return int(out[0].split(\" \")[-1])\n\n    @property\n    def fermi(self):\n        \"\"\"Get Fermi energy from multi-frame CP2K output.\n\n        Returns\n        -------\n        float\n            Fermi energy in eV\n        \"\"\"\n        pattern = r\"\\s+Fermi\\sEnergy\\s\\[eV\\]\\s:\\s+.\\d\\.\\d+\"\n        out = re.findall(pattern, self.string)\n        return float(out[0].split(\" \")[-1]) * AU_TO_EV\n\n    @property\n    def m_charge(self):\n        \"\"\"Get Mulliken charges from multi-frame CP2K output.\n\n        Returns\n        -------\n        numpy.ndarray\n            Array of Mulliken charges for each atom for each frame\n        \"\"\"\n        start_pattern = \"Mulliken Population Analysis\"\n        nframe, data_lines = self.grep_texts_by_nlines(start_pattern, self.natoms + 3)\n        data_lines = np.reshape(data_lines, (nframe, -1))\n\n        data_list = []\n        for line in data_lines[:, 3:].reshape(-1):\n            line_list = line.split()\n            data_list.append(float(line_list[-1]))\n        return np.reshape(data_list, (nframe, -1))\n\n    @property\n    def h_charge(self):\n        \"\"\"Get Hirshfeld charges from multi-frame CP2K output.\n\n        Returns\n        -------\n        numpy.ndarray\n            Array of Hirshfeld charges for each atom for each frame\n        \"\"\"\n        start_pattern = \"Hirshfeld Charges\"\n        nframe, data_lines = self.grep_texts_by_nlines(start_pattern, self.natoms + 3)\n        data_lines = np.reshape(data_lines, (nframe, -1))\n\n        data_list = []\n        for line in data_lines[:, 3:].reshape(-1):\n            line_list = line.split()\n            data_list.append(float(line_list[-1]))\n        return np.reshape(data_list, (nframe, -1))\n\n    @property\n    def dipole_moment(self):\n        \"\"\"Get dipole moment from multi-frame CP2K output.\n\n        Returns\n        -------\n        numpy.ndarray\n            Array of dipole moment vectors [x, y, z] in Debye for each frame\n        \"\"\"\n        pattern = \"Dipole moment\"\n        nframe, data_lines = self.grep_texts_by_nlines(pattern, 2)\n        data_lines = np.reshape(data_lines, (nframe, -1))\n\n        data_list = []\n        for line in data_lines[:, 1:].reshape(-1):\n            line_list = line.split()\n            data_list.append(list(map(float, line_list[1:-1:2])))\n        return np.reshape(data_list, (nframe, 3))\n\n    @property\n    def surf_dipole_moment(self):\n        \"\"\"Grep surface dipole moment.\n\n        Total dipole moment perpendicular to\n        the slab [electrons-Angstroem]:              -1.5878220042.\n        \"\"\"\n        pattern = \"Total dipole moment perpendicular to\"\n        nframe, data_lines = self.grep_texts_by_nlines(pattern, 2)\n        data_lines = np.reshape(data_lines, (nframe, -1))\n\n        data_list = []\n        for line in data_lines[:, 1:].reshape(-1):\n            line_list = line.split()\n            data_list.append(float(line_list[-1]))\n        return np.reshape(data_list, (nframe))\n\n    @property\n    def potdrop(self):\n        \"\"\"Calculate potential drop across the surface from multi-frame CP2K output.\n\n        Returns\n        -------\n        numpy.ndarray\n            Array of potential drops in V for each frame\n        \"\"\"\n        cross_area = np.linalg.norm(np.cross(self.atoms.cell[0], self.atoms.cell[1]))\n        DeltaV = self.surf_dipole_moment / cross_area / EPSILON\n        return DeltaV\n\n    @property\n    def energy_dict(self):\n        \"\"\"Get detailed energy breakdown from multi-frame CP2K output.\n\n        Returns\n        -------\n        dict\n            Dictionary containing various energy components in eV for each frame\n        \"\"\"\n        energy_dict = {}\n\n        start_pattern = r\"  Total charge density g-space grids:\"\n        end_pattern = r\"  Total energy:\"\n        nframe, data_lines = self.grep_texts(start_pattern, end_pattern)\n        data_lines = np.reshape(data_lines, (nframe, -1))\n\n        tot_e = 0.0\n        for kw in data_lines[-1, 2:-1].reshape(-1):\n            kw = kw.split(\":\")\n            k = kw[0].strip(\" \")\n            v = float(kw[1]) * AU_TO_EV\n            energy_dict[k] = [v]\n            tot_e += v\n        # energy_dict[\"Total energy\"].append(tot_e)\n        # for kws in data_lines[1:, 2:-1].reshape(-1):\n        #     tot_e = 0.\n        #     for kw in kws:\n        #         kw = kw.split(\":\")\n        #         k = kw[0].strip(' ')\n        #         v = float(kw[1]) * AU_TO_EV\n        #         energy_dict[k].append(v)\n        #         tot_e += v\n        #     # energy_dict[\"Total energy\"].append(tot_e)\n\n        energy_dict.pop(\"Fermi energy\", None)\n\n        return energy_dict\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.MultiFrameCp2kOutput.atoms","title":"<code>atoms</code>  <code>property</code>","text":"<p>Get ASE Atoms object from multi-frame CP2K output.</p> <p>Returns:</p> Type Description <code>Atoms</code> <p>ASE Atoms object with positions, cell, and periodic boundary conditions</p>"},{"location":"api/#toolbox.io.cp2k.MultiFrameCp2kOutput.dipole_moment","title":"<code>dipole_moment</code>  <code>property</code>","text":"<p>Get dipole moment from multi-frame CP2K output.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of dipole moment vectors [x, y, z] in Debye for each frame</p>"},{"location":"api/#toolbox.io.cp2k.MultiFrameCp2kOutput.energy","title":"<code>energy</code>  <code>property</code>","text":"<p>Get total energy from multi-frame CP2K output.</p> <p>Returns:</p> Type Description <code>float</code> <p>Total energy in eV</p>"},{"location":"api/#toolbox.io.cp2k.MultiFrameCp2kOutput.energy_dict","title":"<code>energy_dict</code>  <code>property</code>","text":"<p>Get detailed energy breakdown from multi-frame CP2K output.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing various energy components in eV for each frame</p>"},{"location":"api/#toolbox.io.cp2k.MultiFrameCp2kOutput.fermi","title":"<code>fermi</code>  <code>property</code>","text":"<p>Get Fermi energy from multi-frame CP2K output.</p> <p>Returns:</p> Type Description <code>float</code> <p>Fermi energy in eV</p>"},{"location":"api/#toolbox.io.cp2k.MultiFrameCp2kOutput.force","title":"<code>force</code>  <code>property</code>","text":"<p>Get atomic force from cp2k output.</p> <p>Return:     force numpy array (n_atom, 3)</p>"},{"location":"api/#toolbox.io.cp2k.MultiFrameCp2kOutput.h_charge","title":"<code>h_charge</code>  <code>property</code>","text":"<p>Get Hirshfeld charges from multi-frame CP2K output.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of Hirshfeld charges for each atom for each frame</p>"},{"location":"api/#toolbox.io.cp2k.MultiFrameCp2kOutput.m_charge","title":"<code>m_charge</code>  <code>property</code>","text":"<p>Get Mulliken charges from multi-frame CP2K output.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of Mulliken charges for each atom for each frame</p>"},{"location":"api/#toolbox.io.cp2k.MultiFrameCp2kOutput.potdrop","title":"<code>potdrop</code>  <code>property</code>","text":"<p>Calculate potential drop across the surface from multi-frame CP2K output.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of potential drops in V for each frame</p>"},{"location":"api/#toolbox.io.cp2k.MultiFrameCp2kOutput.scf_loop","title":"<code>scf_loop</code>  <code>property</code>","text":"<p>Get number of SCF iterations from multi-frame CP2K output.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of SCF iterations, or -1 if SCF did not converge</p>"},{"location":"api/#toolbox.io.cp2k.MultiFrameCp2kOutput.surf_dipole_moment","title":"<code>surf_dipole_moment</code>  <code>property</code>","text":"<p>Grep surface dipole moment.</p> <p>Total dipole moment perpendicular to the slab [electrons-Angstroem]:              -1.5878220042.</p>"},{"location":"api/#toolbox.io.cp2k.gaussian_convolve","title":"<code>gaussian_convolve(xs, ys, sigma)</code>","text":"<p>Convolve data with Gaussian kernel.</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>array_like</code> <p>X values</p> required <code>ys</code> <code>array_like</code> <p>Y values to convolve</p> required <code>sigma</code> <code>float</code> <p>Standard deviation of Gaussian</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Convolved values</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def gaussian_convolve(xs, ys, sigma):\n    \"\"\"Convolve data with Gaussian kernel.\n\n    Parameters\n    ----------\n    xs : array_like\n        X values\n    ys : array_like\n        Y values to convolve\n    sigma : float\n        Standard deviation of Gaussian\n\n    Returns\n    -------\n    np.ndarray\n        Convolved values\n    \"\"\"\n    len(xs) - 1\n\n    output = []\n    for x in xs:\n        bins = xs - x\n        tmp_out = gaussian_kernel(bins, sigma)\n        bin_width = bins[1:] - bins[:-1]\n        output.append(\n            np.sum(bin_width * ((tmp_out * ys)[1:] + (tmp_out * ys)[:-1]) / 2)\n        )\n    return np.array(output)\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.gaussian_kernel","title":"<code>gaussian_kernel(bins, sigma)</code>","text":"<p>Generate Gaussian kernel for convolution.</p> <p>Parameters:</p> Name Type Description Default <code>bins</code> <code>array_like</code> <p>Array of bin centers</p> required <code>sigma</code> <code>float</code> <p>Standard deviation of Gaussian</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Gaussian kernel values</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If sigma is negative</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def gaussian_kernel(bins, sigma):\n    \"\"\"Generate Gaussian kernel for convolution.\n\n    Parameters\n    ----------\n    bins : array_like\n        Array of bin centers\n    sigma : float\n        Standard deviation of Gaussian\n\n    Returns\n    -------\n    np.ndarray\n        Gaussian kernel values\n\n    Raises\n    ------\n    AttributeError\n        If sigma is negative\n    \"\"\"\n    if sigma == 0:\n        output = np.zeros_like(bins)\n        one_id = np.where(bins == 0.0)[0][0]\n        output[one_id] = 1\n        return output\n    elif sigma &gt; 0:\n        A = 1 / (sigma * np.sqrt(2 * np.pi))\n        output = np.exp(-bins * bins / (2 * sigma**2))\n        output *= A\n        return output\n    else:\n        raise AttributeError(\"Sigma should be non-negative value.\")\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.generate_ids_list","title":"<code>generate_ids_list(ids)</code>","text":"<p>Generate compact list representation of IDs.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>array_like</code> <p>Array of integer IDs</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of IDs with ranges compressed (e.g., [1, 2..5, 7])</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def generate_ids_list(ids):\n    \"\"\"Generate compact list representation of IDs.\n\n    Parameters\n    ----------\n    ids : array_like\n        Array of integer IDs\n\n    Returns\n    -------\n    list\n        List of IDs with ranges compressed (e.g., [1, 2..5, 7])\n    \"\"\"\n    ids = np.sort(ids)\n    diff = np.diff(ids)\n    # ids_std = \"\"\n    ids_list = []\n    update_flag = True\n    for count, ii in enumerate(diff):\n        if update_flag:\n            start_id = ids[count]\n            update_flag = False\n        end_id = ids[count]\n        # print(start_id, end_id)\n        if ii == 1:\n            continue\n        else:\n            if start_id == end_id:\n                # ids_std += \"%d\" % start_id\n                ids_list.append(start_id)\n            elif end_id &gt; start_id:\n                # ids_std += \"%d..%d \" % (start_id, end_id)\n                ids_list.append(f\"{start_id:d}..{end_id:d}\")\n            else:\n                raise ValueError(\"end_id is smaller than start_id\")\n            update_flag = True\n\n    if update_flag:\n        # ids_std += \"%d \" % ids[-1]\n        ids_list.append(ids[-1])\n    else:\n        # ids_std += \"%d..%d \" % (start_id, ids[-1])\n        ids_list.append(f\"{start_id:d}..{ids[-1]:d}\")\n\n    # return ids_std.strip()\n    return ids_list\n</code></pre>"},{"location":"api/#toolbox.io.cp2k.read_wannier_spread","title":"<code>read_wannier_spread(fname='wannier_spread.out')</code>","text":"<p>Read wannier spread file generated by cp2k.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>wannier_spread.out file name</p> <code>'wannier_spread.out'</code> <p>Returns:</p> Name Type Description <code>wannier_spread</code> <code>numpy array</code> <p>wannier spread data</p> Source code in <code>toolbox/io/cp2k.py</code> <pre><code>def read_wannier_spread(fname: str = \"wannier_spread.out\"):\n    \"\"\"\n    Read wannier spread file generated by cp2k.\n\n    Parameters\n    ----------\n    fname : str\n        wannier_spread.out file name\n\n    Returns\n    -------\n    wannier_spread : numpy array\n        wannier spread data\n    \"\"\"\n    # skip 1, 2, and the last lines\n    # save the others as array\n    with open(fname, encoding=\"UTF-8\") as f:\n        lines = f.readlines()[2:-1]\n\n    wannier = []\n    for line in lines:\n        # line to array\n        line = line.strip().split()\n        wannier.append([float(line[1]), float(line[2])])\n    return np.array(wannier)\n</code></pre>"},{"location":"api/#deep-potential-jax","title":"Deep Potential JAX","text":""},{"location":"api/#toolbox.io.dp_jax","title":"<code>toolbox.io.dp_jax</code>","text":"<p>DeepMD JAX molecular dynamics module.</p> <p>This module provides classes for running molecular dynamics simulations using DeepMD JAX implementation with trajectory dumping functionality.</p>"},{"location":"api/#toolbox.io.dp_jax.Simulation","title":"<code>Simulation</code>","text":"<p>               Bases: <code>Simulation</code></p> <p>DeepMD JAX molecular dynamics simulation class.</p> <p>This class extends the base DeepMD JAX Simulation class to provide trajectory dumping and logging functionality.</p> Example Source code in <code>toolbox/io/dp_jax.py</code> <pre><code>class Simulation(_Simulation):\n    \"\"\"DeepMD JAX molecular dynamics simulation class.\n\n    This class extends the base DeepMD JAX Simulation class to provide\n    trajectory dumping and logging functionality.\n\n    Example\n    -------\n    # setup simulation\n    sim = Simulation(\n        model_path=\"model.pkl\",  # Has to be an 'energy' or 'dplr' model\n        box=box,  # Angstroms\n        type_idx=type_idx,  # here the index-element map (e.g. 0-Oxygen, 1-Hydrogen) must match the dataset used to train the model\n        mass=[15.9994, 1.0078, 195.08],  # Oxygen, Hydrogen\n        routine=\"NVT\",  # 'NVE', 'NVT', 'NPT' (Nos\u00e9-Hoover)\n        dt=0.5,  # femtoseconds\n        initial_position=initial_position,  # Angstroms\n        temperature=330,  # Kelvin\n        report_interval=1,  # Report every 100 steps\n        seed=np.random.randint(1, 1e5),  # Random seed\n    )\n\n    sim.run(\n        n_steps,\n        [\n            TrajDump(atoms, \"pos_traj.xyz\", 10, append=True),\n            TrajDump(atoms, \"vel_traj.xyz\", 10, vel=True, append=True),\n        ],\n    )\n\n    \"\"\"\n\n    def __init__(\n        self,\n        model_path,\n        box,\n        type_idx,\n        mass,\n        routine,\n        dt,\n        initial_position,\n        log_file: Optional[str] = \"deepmd_jax.stdout\",\n        **kwargs,\n    ):\n        \"\"\"Initialize Simulation.\n\n        Parameters\n        ----------\n        model_path : str\n            Path to trained model file\n        box : array_like\n            Simulation box dimensions in Angstroms\n        type_idx : array_like\n            Index-element mapping for atom types\n        mass : array_like\n            Atomic masses\n        routine : str\n            Ensemble type ('NVE', 'NVT', 'NPT')\n        dt : float\n            Timestep in femtoseconds\n        initial_position : array_like\n            Initial atomic positions in Angstroms\n        log_file : Optional[str], optional\n            Log file path, by default \"deepmd_jax.stdout\"\n        **kwargs\n            Additional keyword arguments\n        \"\"\"\n        super().__init__(\n            model_path,\n            box,\n            type_idx,\n            mass,\n            routine,\n            dt,\n            initial_position,\n            **kwargs,\n        )\n        self.log_file = log_file\n        if log_file is not None:\n            # export all stdout to log_file\n            self._stdout = sys.stdout\n            with open(log_file, \"w\", encoding=\"utf-8\") as f:\n                sys.stdout = f\n\n    def __del__(self):\n        \"\"\"Restore stdout when object is deleted.\"\"\"\n        if self.log_file is not None:\n            sys.stdout.close()\n            sys.stdout = self._stdout\n\n    def _initialize_run(self, steps):\n        \"\"\"Initialize simulation run.\n\n        This function resets trajectory for each new run and\n        initializes run variables. If the simulation has not\n        been run before, it includes the initial state.\n\n        Parameters\n        ----------\n        steps : int\n            Total number of steps to run\n        \"\"\"\n        print(f\"# Running {steps} steps...\")\n        self._offset = self.step - int(self._is_initial_state)\n        self._tic_of_this_run = time.time()\n        self._tic_between_report = time.time()\n        self._error_code = 0\n        self._print_report()\n        self._is_initial_state = False\n\n    def run(self, steps, dump_list: List[TrajDump]):\n        \"\"\"Run the simulation for a number of steps.\"\"\"\n        self._initialize_run(steps)\n        remaining_steps = steps\n        while remaining_steps &gt; 0:\n            # run the simulation for a jit-compiled chunk of steps\n            next_chunk = min(\n                self.report_interval - self.step % self.report_interval,\n                self._step_chunk_size,\n                remaining_steps,\n            )\n            states = (\n                self._state,\n                self._typed_nbrs if self._static_args[\"use_neighbor_list\"] else None,\n                self._error_code,\n                self._neighbor_update_profile,\n            )\n            states_new, traj = self._multiple_inner_step_fn(states, next_chunk)\n            state_new, typed_nbrs_new, error_code, profile = states_new\n            self._error_code |= error_code\n\n            if self._error_code &amp; 16:\n                print(\"# Warning: Nan or Inf encountered in simulation. Terminating.\")\n                remaining_steps = 0\n\n            # If there is any hard overflow, we have to re-run the chunk\n            if not (\n                self._error_code == 0 or self._error_code == 4 or self._error_code == 16\n            ):\n                self._resolve_error_code()\n                continue\n\n            # If nothing overflows, update the tracked state and record the trajectory\n            self._keep_nbr_or_lattice_up_to_date()\n            self._state = state_new\n            self._typed_nbrs = typed_nbrs_new\n            self._neighbor_update_profile = profile\n            if \"NPT\" in self._routine:\n                self._current_box = self._state.box\n            pos_traj, vel_traj, box_traj = traj\n            self.step += next_chunk\n            remaining_steps -= next_chunk\n\n            # Report at preset regular intervals\n            if self.step % self.report_interval == 0 or remaining_steps == 0:\n                self._print_report()\n\n            for dump in dump_list:\n                if self.step % dump.interval == 0 or remaining_steps == 0:\n                    cell = np.concatenate([np.array(box_traj[-1]), [90, 90, 90]])\n                    dump.write(pos_traj[-1] if not dump.vel else vel_traj[-1], cell)\n\n        self._print_run_profile(steps, time.time() - self._tic_of_this_run)\n        self._keep_nbr_or_lattice_up_to_date()\n</code></pre>"},{"location":"api/#toolbox.io.dp_jax.Simulation--setup-simulation","title":"setup simulation","text":"<p>sim = Simulation(     model_path=\"model.pkl\",  # Has to be an 'energy' or 'dplr' model     box=box,  # Angstroms     type_idx=type_idx,  # here the index-element map (e.g. 0-Oxygen, 1-Hydrogen) must match the dataset used to train the model     mass=[15.9994, 1.0078, 195.08],  # Oxygen, Hydrogen     routine=\"NVT\",  # 'NVE', 'NVT', 'NPT' (Nos\u00e9-Hoover)     dt=0.5,  # femtoseconds     initial_position=initial_position,  # Angstroms     temperature=330,  # Kelvin     report_interval=1,  # Report every 100 steps     seed=np.random.randint(1, 1e5),  # Random seed )</p> <p>sim.run(     n_steps,     [         TrajDump(atoms, \"pos_traj.xyz\", 10, append=True),         TrajDump(atoms, \"vel_traj.xyz\", 10, vel=True, append=True),     ], )</p>"},{"location":"api/#toolbox.io.dp_jax.Simulation.__del__","title":"<code>__del__()</code>","text":"<p>Restore stdout when object is deleted.</p> Source code in <code>toolbox/io/dp_jax.py</code> <pre><code>def __del__(self):\n    \"\"\"Restore stdout when object is deleted.\"\"\"\n    if self.log_file is not None:\n        sys.stdout.close()\n        sys.stdout = self._stdout\n</code></pre>"},{"location":"api/#toolbox.io.dp_jax.Simulation.__init__","title":"<code>__init__(model_path, box, type_idx, mass, routine, dt, initial_position, log_file='deepmd_jax.stdout', **kwargs)</code>","text":"<p>Initialize Simulation.</p> <p>Parameters:</p> Name Type Description Default <code>model_path</code> <code>str</code> <p>Path to trained model file</p> required <code>box</code> <code>array_like</code> <p>Simulation box dimensions in Angstroms</p> required <code>type_idx</code> <code>array_like</code> <p>Index-element mapping for atom types</p> required <code>mass</code> <code>array_like</code> <p>Atomic masses</p> required <code>routine</code> <code>str</code> <p>Ensemble type ('NVE', 'NVT', 'NPT')</p> required <code>dt</code> <code>float</code> <p>Timestep in femtoseconds</p> required <code>initial_position</code> <code>array_like</code> <p>Initial atomic positions in Angstroms</p> required <code>log_file</code> <code>Optional[str]</code> <p>Log file path, by default \"deepmd_jax.stdout\"</p> <code>'deepmd_jax.stdout'</code> <code>**kwargs</code> <p>Additional keyword arguments</p> <code>{}</code> Source code in <code>toolbox/io/dp_jax.py</code> <pre><code>def __init__(\n    self,\n    model_path,\n    box,\n    type_idx,\n    mass,\n    routine,\n    dt,\n    initial_position,\n    log_file: Optional[str] = \"deepmd_jax.stdout\",\n    **kwargs,\n):\n    \"\"\"Initialize Simulation.\n\n    Parameters\n    ----------\n    model_path : str\n        Path to trained model file\n    box : array_like\n        Simulation box dimensions in Angstroms\n    type_idx : array_like\n        Index-element mapping for atom types\n    mass : array_like\n        Atomic masses\n    routine : str\n        Ensemble type ('NVE', 'NVT', 'NPT')\n    dt : float\n        Timestep in femtoseconds\n    initial_position : array_like\n        Initial atomic positions in Angstroms\n    log_file : Optional[str], optional\n        Log file path, by default \"deepmd_jax.stdout\"\n    **kwargs\n        Additional keyword arguments\n    \"\"\"\n    super().__init__(\n        model_path,\n        box,\n        type_idx,\n        mass,\n        routine,\n        dt,\n        initial_position,\n        **kwargs,\n    )\n    self.log_file = log_file\n    if log_file is not None:\n        # export all stdout to log_file\n        self._stdout = sys.stdout\n        with open(log_file, \"w\", encoding=\"utf-8\") as f:\n            sys.stdout = f\n</code></pre>"},{"location":"api/#toolbox.io.dp_jax.Simulation.run","title":"<code>run(steps, dump_list)</code>","text":"<p>Run the simulation for a number of steps.</p> Source code in <code>toolbox/io/dp_jax.py</code> <pre><code>def run(self, steps, dump_list: List[TrajDump]):\n    \"\"\"Run the simulation for a number of steps.\"\"\"\n    self._initialize_run(steps)\n    remaining_steps = steps\n    while remaining_steps &gt; 0:\n        # run the simulation for a jit-compiled chunk of steps\n        next_chunk = min(\n            self.report_interval - self.step % self.report_interval,\n            self._step_chunk_size,\n            remaining_steps,\n        )\n        states = (\n            self._state,\n            self._typed_nbrs if self._static_args[\"use_neighbor_list\"] else None,\n            self._error_code,\n            self._neighbor_update_profile,\n        )\n        states_new, traj = self._multiple_inner_step_fn(states, next_chunk)\n        state_new, typed_nbrs_new, error_code, profile = states_new\n        self._error_code |= error_code\n\n        if self._error_code &amp; 16:\n            print(\"# Warning: Nan or Inf encountered in simulation. Terminating.\")\n            remaining_steps = 0\n\n        # If there is any hard overflow, we have to re-run the chunk\n        if not (\n            self._error_code == 0 or self._error_code == 4 or self._error_code == 16\n        ):\n            self._resolve_error_code()\n            continue\n\n        # If nothing overflows, update the tracked state and record the trajectory\n        self._keep_nbr_or_lattice_up_to_date()\n        self._state = state_new\n        self._typed_nbrs = typed_nbrs_new\n        self._neighbor_update_profile = profile\n        if \"NPT\" in self._routine:\n            self._current_box = self._state.box\n        pos_traj, vel_traj, box_traj = traj\n        self.step += next_chunk\n        remaining_steps -= next_chunk\n\n        # Report at preset regular intervals\n        if self.step % self.report_interval == 0 or remaining_steps == 0:\n            self._print_report()\n\n        for dump in dump_list:\n            if self.step % dump.interval == 0 or remaining_steps == 0:\n                cell = np.concatenate([np.array(box_traj[-1]), [90, 90, 90]])\n                dump.write(pos_traj[-1] if not dump.vel else vel_traj[-1], cell)\n\n    self._print_run_profile(steps, time.time() - self._tic_of_this_run)\n    self._keep_nbr_or_lattice_up_to_date()\n</code></pre>"},{"location":"api/#toolbox.io.dp_jax.TrajDump","title":"<code>TrajDump</code>","text":"<p>Class for dumping trajectory data during simulation.</p> <p>This class handles writing trajectory data at specified intervals during molecular dynamics simulations.</p> Source code in <code>toolbox/io/dp_jax.py</code> <pre><code>class TrajDump:\n    \"\"\"Class for dumping trajectory data during simulation.\n\n    This class handles writing trajectory data at specified intervals\n    during molecular dynamics simulations.\n    \"\"\"\n\n    def __init__(\n        self,\n        atoms: Atoms,\n        fname: str,\n        interval: int,\n        vel: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Initialize TrajDump.\n\n        Parameters\n        ----------\n        atoms : ase.Atoms\n            Atoms object for the system\n        fname : str\n            Output filename\n        interval : int\n            Dump interval in timesteps\n        vel : bool, optional\n            Whether to dump velocities, by default False\n        **kwargs\n            Additional keyword arguments for writing\n        \"\"\"\n        self.fname = fname\n        self.interval = interval\n        self.vel = vel\n        self.atoms = atoms\n\n        self.write_settings = kwargs\n\n    def write(self, positions, cell):\n        \"\"\"Write current frame to file.\n\n        Parameters\n        ----------\n        positions : array_like\n            Atomic positions\n        cell : array_like\n            Unit cell vectors\n        \"\"\"\n        self.atoms.set_positions(positions)\n        self.atoms.set_cell(cell)\n        io.write(\n            self.fname,\n            self.atoms,\n            **self.write_settings,\n        )\n</code></pre>"},{"location":"api/#toolbox.io.dp_jax.TrajDump.__init__","title":"<code>__init__(atoms, fname, interval, vel=False, **kwargs)</code>","text":"<p>Initialize TrajDump.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>Atoms object for the system</p> required <code>fname</code> <code>str</code> <p>Output filename</p> required <code>interval</code> <code>int</code> <p>Dump interval in timesteps</p> required <code>vel</code> <code>bool</code> <p>Whether to dump velocities, by default False</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments for writing</p> <code>{}</code> Source code in <code>toolbox/io/dp_jax.py</code> <pre><code>def __init__(\n    self,\n    atoms: Atoms,\n    fname: str,\n    interval: int,\n    vel: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Initialize TrajDump.\n\n    Parameters\n    ----------\n    atoms : ase.Atoms\n        Atoms object for the system\n    fname : str\n        Output filename\n    interval : int\n        Dump interval in timesteps\n    vel : bool, optional\n        Whether to dump velocities, by default False\n    **kwargs\n        Additional keyword arguments for writing\n    \"\"\"\n    self.fname = fname\n    self.interval = interval\n    self.vel = vel\n    self.atoms = atoms\n\n    self.write_settings = kwargs\n</code></pre>"},{"location":"api/#toolbox.io.dp_jax.TrajDump.write","title":"<code>write(positions, cell)</code>","text":"<p>Write current frame to file.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>array_like</code> <p>Atomic positions</p> required <code>cell</code> <code>array_like</code> <p>Unit cell vectors</p> required Source code in <code>toolbox/io/dp_jax.py</code> <pre><code>def write(self, positions, cell):\n    \"\"\"Write current frame to file.\n\n    Parameters\n    ----------\n    positions : array_like\n        Atomic positions\n    cell : array_like\n        Unit cell vectors\n    \"\"\"\n    self.atoms.set_positions(positions)\n    self.atoms.set_cell(cell)\n    io.write(\n        self.fname,\n        self.atoms,\n        **self.write_settings,\n    )\n</code></pre>"},{"location":"api/#dpdata-io","title":"DPData I/O","text":""},{"location":"api/#toolbox.io.dpdata","title":"<code>toolbox.io.dpdata</code>","text":"<p>DPData utility module.</p> <p>This module provides utility functions for working with DPData format, including setting energies, forces, and updating atom types.</p>"},{"location":"api/#toolbox.io.dpdata.set_energy_and_forces","title":"<code>set_energy_and_forces(atoms, energy, forces)</code>","text":"<p>Set energy and forces to atoms object.</p> <p>This function sets the energy and forces on an ASE Atoms object to make atoms.get_potential_energy() and atoms.get_forces() return the given energy and forces.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>The atoms object to modify</p> required <code>energy</code> <code>float</code> <p>The energy value to set</p> required <code>forces</code> <code>ndarray</code> <p>The forces array to set</p> required Source code in <code>toolbox/io/dpdata.py</code> <pre><code>def set_energy_and_forces(atoms: Atoms, energy: float, forces: np.ndarray):\n    \"\"\"Set energy and forces to atoms object.\n\n    This function sets the energy and forces on an ASE Atoms object\n    to make atoms.get_potential_energy() and atoms.get_forces()\n    return the given energy and forces.\n\n    Parameters\n    ----------\n    atoms : ase.Atoms\n        The atoms object to modify\n    energy : float\n        The energy value to set\n    forces : np.ndarray\n        The forces array to set\n    \"\"\"\n    calc = SinglePointCalculator(atoms)\n    atoms.set_calculator(calc)\n    atoms.calc.results[\"energy\"] = energy\n    atoms.calc.results[\"forces\"] = forces\n</code></pre>"},{"location":"api/#toolbox.io.dpdata.update_atype","title":"<code>update_atype(dname, type_map)</code>","text":"<p>Update atom types in multiple directories.</p> <p>This function updates atom type files in all subdirectories to match a specified type mapping.</p> <p>Parameters:</p> Name Type Description Default <code>dname</code> <code>str</code> <p>Directory name to search for type files</p> required <code>type_map</code> <code>List[str]</code> <p>List of element symbols in desired order</p> required Source code in <code>toolbox/io/dpdata.py</code> <pre><code>def update_atype(dname: str, type_map: list[str]):\n    \"\"\"Update atom types in multiple directories.\n\n    This function updates atom type files in all subdirectories\n    to match a specified type mapping.\n\n    Parameters\n    ----------\n    dname : str\n        Directory name to search for type files\n    type_map : List[str]\n        List of element symbols in desired order\n    \"\"\"\n    fnames = glob.glob(os.path.join(dname, \"**/type.raw\"), recursive=True)\n    fnames.sort()\n    for fname in fnames:\n        dname = os.path.dirname(fname)\n        _type_map = np.loadtxt(os.path.join(dname, \"type_map.raw\"), dtype=str)\n        _atype = np.loadtxt(fname, dtype=int)\n        symbols = _type_map[_atype]\n        # generate new type.raw according to the input type_map\n        assert np.all(np.isin(symbols, type_map)), \"Invalid type_map\"\n        new_atype = np.array([type_map.index(s) for s in symbols], dtype=int)\n        np.savetxt(fname, new_atype, fmt=\"%d\")\n        np.savetxt(os.path.join(dname, \"type_map.raw\"), type_map, fmt=\"%s\")\n</code></pre>"},{"location":"api/#lammps-io","title":"LAMMPS I/O","text":""},{"location":"api/#toolbox.io.lammps","title":"<code>toolbox.io.lammps</code>","text":"<p>LAMMPS I/O module.</p> <p>This module provides classes and functions for reading and writing LAMMPS data files, dump files, and log files.</p>"},{"location":"api/#toolbox.io.lammps.DPLRLammpsData","title":"<code>DPLRLammpsData</code>","text":"<p>               Bases: <code>LammpsData</code></p> <p>Class for DPLR LAMMPS data files.</p> <p>This class extends LammpsData to handle DPLR (Deep Potential Learning and Reproducing) specific data format.</p> Example <p>atoms = io.read(\"coord.xyz\") sel_type = [\"O\"] sys_charge_dict = {     \"O\": 6.0,     \"H\": 1.0, } lmp_data = DPLRLammpsData(atoms, sel_type=sel_type, sys_charge_dict=sys_charge_dict) lmp_data.write(\"system.data\", format=\"lammps-data\", specorder=[\"O\", \"H\"], atom_style=\"full\")</p> Source code in <code>toolbox/io/lammps.py</code> <pre><code>class DPLRLammpsData(LammpsData):\n    \"\"\"Class for DPLR LAMMPS data files.\n\n    This class extends LammpsData to handle DPLR (Deep Potential\n    Learning and Reproducing) specific data format.\n\n    Example\n    -------\n\n    atoms = io.read(\"coord.xyz\")\n    sel_type = [\"O\"]\n    sys_charge_dict = {\n        \"O\": 6.0,\n        \"H\": 1.0,\n    }\n    lmp_data = DPLRLammpsData(atoms, sel_type=sel_type, sys_charge_dict=sys_charge_dict)\n    lmp_data.write(\"system.data\", format=\"lammps-data\", specorder=[\"O\", \"H\"], atom_style=\"full\")\n    \"\"\"\n\n    def __init__(self, atoms, sel_type, sys_charge_dict) -&gt; None:\n        atoms, center_ids = self._make_extended_atoms(\n            atoms.copy(), sel_type, sys_charge_dict\n        )\n        super().__init__(atoms)\n        # set bonds between real atoms and wannier atoms\n        nbonds = len(center_ids)\n        bonds = np.ones((nbonds, 4), dtype=int)\n        np.copyto(bonds[:, 0], np.arange(nbonds) + 1)\n        wannier_ids = np.arange(len(atoms) - nbonds, len(atoms)) + 1\n        np.copyto(bonds[:, 2], center_ids)\n        np.copyto(bonds[:, 3], wannier_ids)\n        self.set_bonds(bonds)\n\n    def _make_extended_atoms(self, atoms, sel_type, sys_charge_dict):\n        dummy_type_map = [\"He\", \"Ne\", \"Ar\", \"Kr\", \"Xe\", \"Rn\"]\n        # extend Wannier atoms\n        center_ids = []\n        for ii, _atype in enumerate(sel_type):\n            sel_ids = np.where(atoms.symbols == _atype)[0]\n            sel_atoms = atoms[sel_ids]\n            while dummy_type_map[ii] in atoms.get_chemical_symbols():\n                dummy_type_map.pop(ii)\n            sel_atoms.symbols[:] = dummy_type_map[ii]\n            atoms.extend(sel_atoms)\n            center_ids.append(sel_ids + 1)\n        center_ids = np.concatenate(center_ids)\n\n        charges = np.full(len(atoms), -8.0)\n        for k, v in sys_charge_dict.items():\n            charges[atoms.symbols == k] = v\n        atoms.set_initial_charges(charges)\n\n        self.dummy_type_map = dummy_type_map[: len(sel_type)]\n        return atoms, center_ids\n\n    def write(self, out_file=\"system.data\", specorder=None, **kwargs):\n        \"\"\"Write DPLR LAMMPS data file.\n\n        Parameters\n        ----------\n        out_file : str, optional\n            Output filename, by default \"system.data\"\n        specorder : list, optional\n            Specification order for atom types\n        **kwargs\n            Additional keyword arguments for writing\n        \"\"\"\n        if specorder is not None:\n            specorder.extend(self.dummy_type_map)\n        super().write(out_file, specorder=specorder, **kwargs)\n</code></pre>"},{"location":"api/#toolbox.io.lammps.DPLRLammpsData.write","title":"<code>write(out_file='system.data', specorder=None, **kwargs)</code>","text":"<p>Write DPLR LAMMPS data file.</p> <p>Parameters:</p> Name Type Description Default <code>out_file</code> <code>str</code> <p>Output filename, by default \"system.data\"</p> <code>'system.data'</code> <code>specorder</code> <code>list</code> <p>Specification order for atom types</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for writing</p> <code>{}</code> Source code in <code>toolbox/io/lammps.py</code> <pre><code>def write(self, out_file=\"system.data\", specorder=None, **kwargs):\n    \"\"\"Write DPLR LAMMPS data file.\n\n    Parameters\n    ----------\n    out_file : str, optional\n        Output filename, by default \"system.data\"\n    specorder : list, optional\n        Specification order for atom types\n    **kwargs\n        Additional keyword arguments for writing\n    \"\"\"\n    if specorder is not None:\n        specorder.extend(self.dummy_type_map)\n    super().write(out_file, specorder=specorder, **kwargs)\n</code></pre>"},{"location":"api/#toolbox.io.lammps.DPLRRestartLammpsData","title":"<code>DPLRRestartLammpsData</code>","text":"<p>               Bases: <code>LammpsData</code></p> <p>Class for DPLR restart LAMMPS data files.</p> <p>This class extends LammpsData to handle DPLR restart files with specific velocity and topology information.</p> Example <p>atoms = io.read(\"after_system.data\",             format=\"lammps-data\",             sort_by_id=True,             Z_of_type={1: 8, 2: 1, 3: 2}            ) sel_type = [\"O\"] lmp_data = DPLRRestartLammpsData(atoms, sel_type=sel_type) lmp_data.write(\"restart_system.data\", format=\"lammps-data\", specorder=[\"O\", \"H\", \"He\"], atom_style=\"full\")</p> Source code in <code>toolbox/io/lammps.py</code> <pre><code>class DPLRRestartLammpsData(LammpsData):\n    \"\"\"Class for DPLR restart LAMMPS data files.\n\n    This class extends LammpsData to handle DPLR restart files\n    with specific velocity and topology information.\n\n    Example\n    -------\n\n    atoms = io.read(\"after_system.data\",\n                format=\"lammps-data\",\n                sort_by_id=True,\n                Z_of_type={1: 8, 2: 1, 3: 2}\n               )\n    sel_type = [\"O\"]\n    lmp_data = DPLRRestartLammpsData(atoms, sel_type=sel_type)\n    lmp_data.write(\"restart_system.data\", format=\"lammps-data\", specorder=[\"O\", \"H\", \"He\"], atom_style=\"full\")\n    \"\"\"\n\n    def __init__(self, atoms, sel_type) -&gt; None:\n        n_wannier = np.count_nonzero(np.isin(atoms.symbols, sel_type))\n        n_real = len(atoms) - n_wannier\n        center_ids = []\n        count = n_real\n        coords = atoms.get_positions()\n        for _atype in sel_type:\n            sel_ids = np.where(atoms.symbols == _atype)[0]\n            np.copyto(coords[count : count + len(sel_ids)], coords[sel_ids])\n            center_ids.append(sel_ids + 1)\n            count += len(sel_ids)\n        center_ids = np.concatenate(center_ids)\n        atoms.set_positions(coords)\n        super().__init__(atoms)\n        # set velocities\n        # from ase internal unit to lammps metal unit (A/ps)\n        # https://wiki.fysik.dtu.dk/ase/ase/units.html#units\n        vs = atoms.get_velocities() * fs * 1e3\n        # vs[n_real:] = 0.0\n        self.set_velocities(\n            np.concatenate((np.arange(1, len(atoms) + 1).reshape(-1, 1), vs), axis=1)\n        )\n        # set bonds\n        nbonds = len(center_ids)\n        bonds = np.ones((nbonds, 4), dtype=int)\n        np.copyto(bonds[:, 0], np.arange(nbonds) + 1)\n        wannier_ids = np.arange(len(atoms) - nbonds, len(atoms)) + 1\n        np.copyto(bonds[:, 2], center_ids)\n        np.copyto(bonds[:, 3], wannier_ids)\n        self.set_bonds(bonds)\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsData","title":"<code>LammpsData</code>","text":"<p>Class for writing LAMMPS data files from ASE Atoms objects.</p> <p>This class provides functionality to convert ASE Atoms objects to LAMMPS data format with various atom styles.</p> Source code in <code>toolbox/io/lammps.py</code> <pre><code>class LammpsData:\n    \"\"\"Class for writing LAMMPS data files from ASE Atoms objects.\n\n    This class provides functionality to convert ASE Atoms objects\n    to LAMMPS data format with various atom styles.\n    \"\"\"\n\n    def __init__(self, atoms) -&gt; None:\n        \"\"\"Initialize LammpsData.\n\n        Parameters\n        ----------\n        atoms : ase.Atoms\n            ASE Atoms object to convert to LAMMPS data format\n        \"\"\"\n        self.atoms = atoms\n        self._setup()\n\n        self.angles = None\n        self.bonds = None\n        self.dihedrals = None\n        self.velocities = None\n\n        self.atype = None\n\n    def write(self, out_file=\"system.data\", **kwargs):\n        \"\"\"Write LAMMPS data file.\n\n        Parameters\n        ----------\n        out_file : str, optional\n            Output filename, by default \"system.data\"\n        **kwargs\n            Additional keyword arguments for writing\n        \"\"\"\n        if self.atype is None:\n            # if atype is not set by hand, set by specorder\n            specorder = kwargs.get(\"specorder\")\n            if specorder is not None:\n                self.set_atype_from_specorder(specorder)\n\n        n_atype = len(np.unique(self.atype))\n        atom_style = kwargs.get(\"atom_style\", \"full\")\n\n        with open(out_file, \"w\", encoding=\"utf-8\") as f:\n            header = self._make_header(out_file, n_atype)\n            f.write(header)\n            body = self._make_atoms(atom_style)\n            f.write(body)\n            if self.bonds is not None:\n                f.write(\"\\nBonds\\n\\n\")\n                np.savetxt(f, self.bonds, fmt=\"%d\")\n            if self.angles is not None:\n                f.write(\"\\nAngles\\n\\n\")\n                np.savetxt(f, self.angles, fmt=\"%d\")\n            if self.dihedrals is not None:\n                f.write(\"\\nDihedrals\\n\\n\")\n                np.savetxt(f, self.dihedrals, fmt=\"%d\")\n            if self.velocities is not None:\n                f.write(\"\\nVelocities\\n\\n\")\n                np.savetxt(f, self.velocities, fmt=[\"%d\", \"%.16f\", \"%.16f\", \"%.16f\"])\n\n    def _make_header(self, out_file, n_atype):\n        \"\"\"Generate LAMMPS data file header.\n\n        Parameters\n        ----------\n        out_file : str\n            Output filename\n        n_atype : int\n            Number of atom types\n\n        Returns\n        -------\n        str\n            Header string for LAMMPS data file\n        \"\"\"\n        # cell = self.atoms.cell.cellpar()\n        nat = len(self.atoms)\n        s = f\"{out_file} (written by toolbox by Jia-Xin Zhu)\\n\\n\"\n        s += f\"{nat} atoms\\n\"\n        s += f\"{n_atype} atom types\\n\"\n        if self.bonds is not None:\n            s += f\"{len(self.bonds)} bonds\\n\"\n            s += f\"{len(np.unique(self.bonds[:, 1]))} bond types\\n\"\n        if self.angles is not None:\n            s += f\"{len(self.angles)} angles\\n\"\n            s += f\"{len(np.unique(self.angles[:, 1]))} angle types\\n\"\n        if self.dihedrals is not None:\n            s += f\"{len(self.dihedrals)} dihedrals\\n\"\n            s += f\"{len(np.unique(self.dihedrals[:, 1]))} dihedral types\\n\"\n        # s += \"%.4f %.4f xlo xhi\\n%.4f %.4f ylo yhi\\n%.4f %.4f zlo zhi\\n\\n\\n\" % (\n        #     0.0, cell[0], 0.0, cell[1], 0.0, cell[2])\n        prismobj = Prism(self.atoms.get_cell())\n        xhi, yhi, zhi, xy, xz, yz = convert(\n            prismobj.get_lammps_prism(), \"distance\", \"ASE\", \"metal\"\n        )\n        s += f\"0.0 {xhi:.6f} xlo xhi\\n\"\n        s += f\"0.0 {yhi:.6f} ylo yhi\\n\"\n        s += f\"0.0 {zhi:.6f} zlo zhi\\n\"\n        if prismobj.is_skewed():\n            s += f\"{xy:.6f} {xz:.6f} {yz:.6f} xy xz yz\\n\"\n        s += \"\\n\"\n        return s\n\n    def _make_atoms(self, atom_style):\n        \"\"\"Generate atoms section based on atom style.\n\n        Parameters\n        ----------\n        atom_style : str\n            LAMMPS atom style (e.g., \"full\", \"atomic\")\n\n        Returns\n        -------\n        str\n            Atoms section string for LAMMPS data file\n\n        Notes\n        -----\n        Supported styles:\n        - full: atom_id res_id type q x y z\n        - atomic: atom_id type x y z\n        \"\"\"\n        return getattr(self, f\"_make_atoms_{atom_style}\")()\n\n    def _make_atoms_full(self):\n        \"\"\"Generate atoms section for full atom style.\n\n        Returns\n        -------\n        str\n            Atoms section with format: atom_id res_id type q x y z\n        \"\"\"\n        s = \"Atoms\\n\\n\"\n        for atom in self.atoms:\n            ii = atom.index\n            s += f\"{ii + 1} {self.res_id[ii]} {self.atype[ii]} {self.charges[ii]:.16f} {self.positions[ii][0]:.16f} {self.positions[ii][1]:.16f} {self.positions[ii][2]:.16f}\\n\"\n        return s\n\n    def _make_atoms_atomic(self):\n        \"\"\"Generate atoms section for atomic atom style.\n\n        Returns\n        -------\n        str\n            Atoms section with format: atom_id type x y z\n        \"\"\"\n        pass\n\n    def set_res_id(self, res_id):\n        \"\"\"Set residue IDs for atoms.\n\n        Parameters\n        ----------\n        res_id : array_like\n            Array of residue IDs\n        \"\"\"\n        self.res_id = np.reshape(res_id, (-1))\n\n    def set_atype(self, atype):\n        \"\"\"Set atom types.\n\n        Parameters\n        ----------\n        atype : array_like\n            Array of atom types\n        \"\"\"\n        self.atype = np.reshape(atype, (-1))\n\n    def set_atype_from_specorder(self, specorder):\n        \"\"\"Set atom types from specification order.\n\n        Parameters\n        ----------\n        specorder : list\n            List of element symbols in desired order\n        \"\"\"\n        atype = []\n        for ii in self.atoms.get_chemical_symbols():\n            atype.append(specorder.index(ii))\n        self.atype = np.array(atype, dtype=np.int32) + 1\n\n    def set_bonds(self, bonds):\n        \"\"\"Set bonds between atoms.\n\n        Parameters\n        ----------\n        bonds : array_like\n            Array of bonds with shape (n_bonds, 4)\n        \"\"\"\n        self.bonds = np.reshape(bonds, (-1, 4))\n\n    def set_angles(self, angles):\n        \"\"\"Set angles between atoms.\n\n        Parameters\n        ----------\n        angles : array_like\n            Array of angles with shape (n_angles, 5)\n        \"\"\"\n        self.angles = np.reshape(angles, (-1, 5))\n\n    def set_dihedrals(self, dihedrals):\n        \"\"\"Set dihedrals between atoms.\n\n        Parameters\n        ----------\n        dihedrals : array_like\n            Array of dihedrals with shape (n_dihedrals, 6)\n        \"\"\"\n        self.dihedrals = np.reshape(dihedrals, (-1, 6))\n\n    def set_charges(self, charges):\n        \"\"\"Set atomic charges.\n\n        Parameters\n        ----------\n        charges : array_like\n            Array of atomic charges\n        \"\"\"\n        self.charges = np.reshape(charges, (-1))\n\n    def set_velocities(self, velocities):\n        \"\"\"Set atomic velocities.\n\n        Parameters\n        ----------\n        velocities : array_like\n            Array of velocities with shape (n_atoms, 4)\n        \"\"\"\n        self.velocities = np.reshape(velocities, (-1, 4))\n\n    def _setup(self):\n        \"\"\"Set up initial atom data from ASE Atoms object.\"\"\"\n        self.positions = self.atoms.get_positions()\n        if len(self.atoms.get_initial_charges()) &gt; 0:\n            self.charges = self.atoms.get_initial_charges().reshape(-1)\n        else:\n            self.charges = np.zeros(len(self.atoms))\n\n        if hasattr(self, \"res_id\"):\n            assert len(self.res_id) == len(self.atoms)\n        else:\n            self.res_id = np.zeros(len(self.atoms), dtype=np.int32)\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsData.__init__","title":"<code>__init__(atoms)</code>","text":"<p>Initialize LammpsData.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object to convert to LAMMPS data format</p> required Source code in <code>toolbox/io/lammps.py</code> <pre><code>def __init__(self, atoms) -&gt; None:\n    \"\"\"Initialize LammpsData.\n\n    Parameters\n    ----------\n    atoms : ase.Atoms\n        ASE Atoms object to convert to LAMMPS data format\n    \"\"\"\n    self.atoms = atoms\n    self._setup()\n\n    self.angles = None\n    self.bonds = None\n    self.dihedrals = None\n    self.velocities = None\n\n    self.atype = None\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsData.set_angles","title":"<code>set_angles(angles)</code>","text":"<p>Set angles between atoms.</p> <p>Parameters:</p> Name Type Description Default <code>angles</code> <code>array_like</code> <p>Array of angles with shape (n_angles, 5)</p> required Source code in <code>toolbox/io/lammps.py</code> <pre><code>def set_angles(self, angles):\n    \"\"\"Set angles between atoms.\n\n    Parameters\n    ----------\n    angles : array_like\n        Array of angles with shape (n_angles, 5)\n    \"\"\"\n    self.angles = np.reshape(angles, (-1, 5))\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsData.set_atype","title":"<code>set_atype(atype)</code>","text":"<p>Set atom types.</p> <p>Parameters:</p> Name Type Description Default <code>atype</code> <code>array_like</code> <p>Array of atom types</p> required Source code in <code>toolbox/io/lammps.py</code> <pre><code>def set_atype(self, atype):\n    \"\"\"Set atom types.\n\n    Parameters\n    ----------\n    atype : array_like\n        Array of atom types\n    \"\"\"\n    self.atype = np.reshape(atype, (-1))\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsData.set_atype_from_specorder","title":"<code>set_atype_from_specorder(specorder)</code>","text":"<p>Set atom types from specification order.</p> <p>Parameters:</p> Name Type Description Default <code>specorder</code> <code>list</code> <p>List of element symbols in desired order</p> required Source code in <code>toolbox/io/lammps.py</code> <pre><code>def set_atype_from_specorder(self, specorder):\n    \"\"\"Set atom types from specification order.\n\n    Parameters\n    ----------\n    specorder : list\n        List of element symbols in desired order\n    \"\"\"\n    atype = []\n    for ii in self.atoms.get_chemical_symbols():\n        atype.append(specorder.index(ii))\n    self.atype = np.array(atype, dtype=np.int32) + 1\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsData.set_bonds","title":"<code>set_bonds(bonds)</code>","text":"<p>Set bonds between atoms.</p> <p>Parameters:</p> Name Type Description Default <code>bonds</code> <code>array_like</code> <p>Array of bonds with shape (n_bonds, 4)</p> required Source code in <code>toolbox/io/lammps.py</code> <pre><code>def set_bonds(self, bonds):\n    \"\"\"Set bonds between atoms.\n\n    Parameters\n    ----------\n    bonds : array_like\n        Array of bonds with shape (n_bonds, 4)\n    \"\"\"\n    self.bonds = np.reshape(bonds, (-1, 4))\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsData.set_charges","title":"<code>set_charges(charges)</code>","text":"<p>Set atomic charges.</p> <p>Parameters:</p> Name Type Description Default <code>charges</code> <code>array_like</code> <p>Array of atomic charges</p> required Source code in <code>toolbox/io/lammps.py</code> <pre><code>def set_charges(self, charges):\n    \"\"\"Set atomic charges.\n\n    Parameters\n    ----------\n    charges : array_like\n        Array of atomic charges\n    \"\"\"\n    self.charges = np.reshape(charges, (-1))\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsData.set_dihedrals","title":"<code>set_dihedrals(dihedrals)</code>","text":"<p>Set dihedrals between atoms.</p> <p>Parameters:</p> Name Type Description Default <code>dihedrals</code> <code>array_like</code> <p>Array of dihedrals with shape (n_dihedrals, 6)</p> required Source code in <code>toolbox/io/lammps.py</code> <pre><code>def set_dihedrals(self, dihedrals):\n    \"\"\"Set dihedrals between atoms.\n\n    Parameters\n    ----------\n    dihedrals : array_like\n        Array of dihedrals with shape (n_dihedrals, 6)\n    \"\"\"\n    self.dihedrals = np.reshape(dihedrals, (-1, 6))\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsData.set_res_id","title":"<code>set_res_id(res_id)</code>","text":"<p>Set residue IDs for atoms.</p> <p>Parameters:</p> Name Type Description Default <code>res_id</code> <code>array_like</code> <p>Array of residue IDs</p> required Source code in <code>toolbox/io/lammps.py</code> <pre><code>def set_res_id(self, res_id):\n    \"\"\"Set residue IDs for atoms.\n\n    Parameters\n    ----------\n    res_id : array_like\n        Array of residue IDs\n    \"\"\"\n    self.res_id = np.reshape(res_id, (-1))\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsData.set_velocities","title":"<code>set_velocities(velocities)</code>","text":"<p>Set atomic velocities.</p> <p>Parameters:</p> Name Type Description Default <code>velocities</code> <code>array_like</code> <p>Array of velocities with shape (n_atoms, 4)</p> required Source code in <code>toolbox/io/lammps.py</code> <pre><code>def set_velocities(self, velocities):\n    \"\"\"Set atomic velocities.\n\n    Parameters\n    ----------\n    velocities : array_like\n        Array of velocities with shape (n_atoms, 4)\n    \"\"\"\n    self.velocities = np.reshape(velocities, (-1, 4))\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsData.write","title":"<code>write(out_file='system.data', **kwargs)</code>","text":"<p>Write LAMMPS data file.</p> <p>Parameters:</p> Name Type Description Default <code>out_file</code> <code>str</code> <p>Output filename, by default \"system.data\"</p> <code>'system.data'</code> <code>**kwargs</code> <p>Additional keyword arguments for writing</p> <code>{}</code> Source code in <code>toolbox/io/lammps.py</code> <pre><code>def write(self, out_file=\"system.data\", **kwargs):\n    \"\"\"Write LAMMPS data file.\n\n    Parameters\n    ----------\n    out_file : str, optional\n        Output filename, by default \"system.data\"\n    **kwargs\n        Additional keyword arguments for writing\n    \"\"\"\n    if self.atype is None:\n        # if atype is not set by hand, set by specorder\n        specorder = kwargs.get(\"specorder\")\n        if specorder is not None:\n            self.set_atype_from_specorder(specorder)\n\n    n_atype = len(np.unique(self.atype))\n    atom_style = kwargs.get(\"atom_style\", \"full\")\n\n    with open(out_file, \"w\", encoding=\"utf-8\") as f:\n        header = self._make_header(out_file, n_atype)\n        f.write(header)\n        body = self._make_atoms(atom_style)\n        f.write(body)\n        if self.bonds is not None:\n            f.write(\"\\nBonds\\n\\n\")\n            np.savetxt(f, self.bonds, fmt=\"%d\")\n        if self.angles is not None:\n            f.write(\"\\nAngles\\n\\n\")\n            np.savetxt(f, self.angles, fmt=\"%d\")\n        if self.dihedrals is not None:\n            f.write(\"\\nDihedrals\\n\\n\")\n            np.savetxt(f, self.dihedrals, fmt=\"%d\")\n        if self.velocities is not None:\n            f.write(\"\\nVelocities\\n\\n\")\n            np.savetxt(f, self.velocities, fmt=[\"%d\", \"%.16f\", \"%.16f\", \"%.16f\"])\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsDump","title":"<code>LammpsDump</code>","text":"<p>Class for writing LAMMPS dump files.</p> <p>This class provides functionality to write LAMMPS dump files from ASE trajectory objects with proper formatting.</p> Source code in <code>toolbox/io/lammps.py</code> <pre><code>class LammpsDump:\n    \"\"\"Class for writing LAMMPS dump files.\n\n    This class provides functionality to write LAMMPS dump files\n    from ASE trajectory objects with proper formatting.\n    \"\"\"\n\n    def __init__(self, traj, type_map) -&gt; None:\n        \"\"\"Initialize LammpsDump.\n\n        Parameters\n        ----------\n        traj : ase.Atoms or list\n            Trajectory data as ASE Atoms object or list\n        type_map : list or dict\n            Type mapping for atoms\n        \"\"\"\n        self.traj = traj\n        self._set_atype(type_map)\n        # self.type_map = type_map\n\n    def write(\n        self,\n        start=0,\n        step=1,\n        out_file=\"out.lammpstrj\",\n        append=False,\n    ):\n        \"\"\"Write LAMMPS dump file.\n\n        Parameters\n        ----------\n        start : int, optional\n            Starting timestep, by default 0\n        step : int, optional\n            Timestep interval, by default 1\n        out_file : str, optional\n            Output filename, by default \"out.lammpstrj\"\n        append : bool, optional\n            Whether to append to existing file, by default False\n        \"\"\"\n        if isinstance(self.traj, Atoms):\n            self._write_dump(self.traj, start, out_file, append)\n        else:\n            nframe = len(self.traj)\n            _ts = np.arange(start, step * nframe, step)\n            for ts, atoms in zip(_ts, self.traj, strict=False):\n                self._write_dump(atoms, ts, out_file, append=True)\n\n    def _set_atype(self, type_map):\n        if isinstance(type_map, list):\n            self.atype_dict = {}\n            for ii, atype in enumerate(type_map, start=1):\n                self.atype_dict[atype] = {}\n                self.atype_dict[atype][\"type\"] = ii\n                self.atype_dict[atype][\"element\"] = atype\n        elif isinstance(type_map, dict):\n            self.atype_dict = type_map\n        else:\n            raise AttributeError(\"Unknown type of type_map\")\n\n    def _write_dump(self, atoms, ts, out_file, append):\n        if append:\n            with open(out_file, \"a\", encoding=\"utf-8\") as f:\n                header = self.make_header(atoms, ts)\n                f.write(header)\n                body = self.make_body(atoms, self.atype_dict)\n                f.write(body)\n        else:\n            with open(out_file, \"w\", encoding=\"utf-8\") as f:\n                header = self.make_header(atoms, ts)\n                f.write(header)\n                body = self.make_body(atoms, self.atype_dict)\n                f.write(body)\n\n    @staticmethod\n    def make_header(atoms, ts):\n        \"\"\"Generate LAMMPS dump file header.\n\n        Parameters\n        ----------\n        atoms : ase.Atoms\n            Atoms object containing atomic data\n        ts : int\n            Current timestep\n\n        Returns\n        -------\n        str\n            Header string for LAMMPS dump file\n        \"\"\"\n        bc_dict = {True: \"pp\", False: \"ff\"}\n\n        cell = atoms.cell.cellpar()\n        bc = atoms.get_pbc()\n        nat = len(atoms)\n        s = f\"ITEM: TIMESTEP\\n{ts}\\n\"\n        s += \"ITEM: NUMBER OF ATOMS\\n\"\n        s += f\"{nat}\\n\"\n        s += f\"ITEM: BOX BOUNDS {bc_dict[bc[0]]} {bc_dict[bc[1]]} {bc_dict[bc[2]]}\\n\"\n        s += f\"{0.0:.4f} {cell[0]:.4f}\\n{0.0:.4f} {cell[1]:.4f}\\n{0.0:.4f} {cell[2]:.4f}\\n\"\n        if len(atoms.get_initial_charges()) &gt; 0:\n            s += \"ITEM: ATOMS id type element x y z q\\n\"\n        else:\n            s += \"ITEM: ATOMS id type element x y z\\n\"\n        return s\n\n    @staticmethod\n    def make_body(atoms, atype_dict):\n        \"\"\"Generate LAMMPS dump file body.\n\n        Parameters\n        ----------\n        atoms : ase.Atoms\n            Atoms object containing atomic data\n        atype_dict : dict\n            Dictionary mapping atom types to type numbers and elements\n\n        Returns\n        -------\n        str\n            Body string for LAMMPS dump file\n        \"\"\"\n        if len(atoms.get_initial_charges()) &gt; 0:\n            q_flag = True\n            charges = atoms.get_initial_charges()\n        else:\n            q_flag = False\n        ps = atoms.get_positions()\n\n        s = \"\"\n        for atom in atoms:\n            ii = atom.index\n            if q_flag:\n                s += f\"{ii + 1} {atype_dict[atom.symbol]['type']} {atype_dict[atom.symbol]['element']} {ps[ii][0]:.16f} {ps[ii][1]:.16f} {ps[ii][2]:.16f} {charges[ii]:.16f}\\n\"\n            else:\n                s += f\"{ii + 1} {atype_dict[atom.symbol]['type']} {atype_dict[atom.symbol]['element']} {ps[ii][0]:.16f} {ps[ii][1]:.16f} {ps[ii][2]:.16f}\\n\"\n        return s\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsDump.__init__","title":"<code>__init__(traj, type_map)</code>","text":"<p>Initialize LammpsDump.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>Atoms or list</code> <p>Trajectory data as ASE Atoms object or list</p> required <code>type_map</code> <code>list or dict</code> <p>Type mapping for atoms</p> required Source code in <code>toolbox/io/lammps.py</code> <pre><code>def __init__(self, traj, type_map) -&gt; None:\n    \"\"\"Initialize LammpsDump.\n\n    Parameters\n    ----------\n    traj : ase.Atoms or list\n        Trajectory data as ASE Atoms object or list\n    type_map : list or dict\n        Type mapping for atoms\n    \"\"\"\n    self.traj = traj\n    self._set_atype(type_map)\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsDump.make_body","title":"<code>make_body(atoms, atype_dict)</code>  <code>staticmethod</code>","text":"<p>Generate LAMMPS dump file body.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>Atoms object containing atomic data</p> required <code>atype_dict</code> <code>dict</code> <p>Dictionary mapping atom types to type numbers and elements</p> required <p>Returns:</p> Type Description <code>str</code> <p>Body string for LAMMPS dump file</p> Source code in <code>toolbox/io/lammps.py</code> <pre><code>@staticmethod\ndef make_body(atoms, atype_dict):\n    \"\"\"Generate LAMMPS dump file body.\n\n    Parameters\n    ----------\n    atoms : ase.Atoms\n        Atoms object containing atomic data\n    atype_dict : dict\n        Dictionary mapping atom types to type numbers and elements\n\n    Returns\n    -------\n    str\n        Body string for LAMMPS dump file\n    \"\"\"\n    if len(atoms.get_initial_charges()) &gt; 0:\n        q_flag = True\n        charges = atoms.get_initial_charges()\n    else:\n        q_flag = False\n    ps = atoms.get_positions()\n\n    s = \"\"\n    for atom in atoms:\n        ii = atom.index\n        if q_flag:\n            s += f\"{ii + 1} {atype_dict[atom.symbol]['type']} {atype_dict[atom.symbol]['element']} {ps[ii][0]:.16f} {ps[ii][1]:.16f} {ps[ii][2]:.16f} {charges[ii]:.16f}\\n\"\n        else:\n            s += f\"{ii + 1} {atype_dict[atom.symbol]['type']} {atype_dict[atom.symbol]['element']} {ps[ii][0]:.16f} {ps[ii][1]:.16f} {ps[ii][2]:.16f}\\n\"\n    return s\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsDump.make_header","title":"<code>make_header(atoms, ts)</code>  <code>staticmethod</code>","text":"<p>Generate LAMMPS dump file header.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>Atoms object containing atomic data</p> required <code>ts</code> <code>int</code> <p>Current timestep</p> required <p>Returns:</p> Type Description <code>str</code> <p>Header string for LAMMPS dump file</p> Source code in <code>toolbox/io/lammps.py</code> <pre><code>@staticmethod\ndef make_header(atoms, ts):\n    \"\"\"Generate LAMMPS dump file header.\n\n    Parameters\n    ----------\n    atoms : ase.Atoms\n        Atoms object containing atomic data\n    ts : int\n        Current timestep\n\n    Returns\n    -------\n    str\n        Header string for LAMMPS dump file\n    \"\"\"\n    bc_dict = {True: \"pp\", False: \"ff\"}\n\n    cell = atoms.cell.cellpar()\n    bc = atoms.get_pbc()\n    nat = len(atoms)\n    s = f\"ITEM: TIMESTEP\\n{ts}\\n\"\n    s += \"ITEM: NUMBER OF ATOMS\\n\"\n    s += f\"{nat}\\n\"\n    s += f\"ITEM: BOX BOUNDS {bc_dict[bc[0]]} {bc_dict[bc[1]]} {bc_dict[bc[2]]}\\n\"\n    s += f\"{0.0:.4f} {cell[0]:.4f}\\n{0.0:.4f} {cell[1]:.4f}\\n{0.0:.4f} {cell[2]:.4f}\\n\"\n    if len(atoms.get_initial_charges()) &gt; 0:\n        s += \"ITEM: ATOMS id type element x y z q\\n\"\n    else:\n        s += \"ITEM: ATOMS id type element x y z\\n\"\n    return s\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsDump.write","title":"<code>write(start=0, step=1, out_file='out.lammpstrj', append=False)</code>","text":"<p>Write LAMMPS dump file.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>Starting timestep, by default 0</p> <code>0</code> <code>step</code> <code>int</code> <p>Timestep interval, by default 1</p> <code>1</code> <code>out_file</code> <code>str</code> <p>Output filename, by default \"out.lammpstrj\"</p> <code>'out.lammpstrj'</code> <code>append</code> <code>bool</code> <p>Whether to append to existing file, by default False</p> <code>False</code> Source code in <code>toolbox/io/lammps.py</code> <pre><code>def write(\n    self,\n    start=0,\n    step=1,\n    out_file=\"out.lammpstrj\",\n    append=False,\n):\n    \"\"\"Write LAMMPS dump file.\n\n    Parameters\n    ----------\n    start : int, optional\n        Starting timestep, by default 0\n    step : int, optional\n        Timestep interval, by default 1\n    out_file : str, optional\n        Output filename, by default \"out.lammpstrj\"\n    append : bool, optional\n        Whether to append to existing file, by default False\n    \"\"\"\n    if isinstance(self.traj, Atoms):\n        self._write_dump(self.traj, start, out_file, append)\n    else:\n        nframe = len(self.traj)\n        _ts = np.arange(start, step * nframe, step)\n        for ts, atoms in zip(_ts, self.traj, strict=False):\n            self._write_dump(atoms, ts, out_file, append=True)\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsLog","title":"<code>LammpsLog</code>","text":"<p>Class for parsing LAMMPS log files.</p> <p>This class provides functionality to extract information from LAMMPS log files, including timing and performance data.</p> Source code in <code>toolbox/io/lammps.py</code> <pre><code>class LammpsLog:\n    \"\"\"Class for parsing LAMMPS log files.\n\n    This class provides functionality to extract information\n    from LAMMPS log files, including timing and performance data.\n    \"\"\"\n\n    def __init__(self, fname=\"log.lammps\") -&gt; None:\n        \"\"\"Initialize LammpsLog.\n\n        Parameters\n        ----------\n        fname : str, optional\n            Path to LAMMPS log file, by default \"log.lammps\"\n        \"\"\"\n        self.log_file = fname\n        with open(fname) as f:\n            self.content = f.readlines()\n        # self.string = \"\".join(self.content)\n        self.setup()\n\n    def setup(self):\n        \"\"\"Parse log file to extract performance information.\"\"\"\n        for line in self.content:\n            if re.search(\"MPI tasks\", line):\n                self.cpu_util = float(line.split()[0][:-1])\n                self.n_mpi = int(line.split()[4])\n                self.n_thread = int(line.split()[-3])\n            if re.match(\"Loop time of\", line):\n                self.n_atoms = int(line.split()[-2])\n                self.n_step = int(line.split()[-5])\n                self.n_proc = int(line.split()[5])\n                self.wall_time = float(line.split()[3])\n            if re.match(\"Performance\", line):\n                out = line.split()\n                self.performance = {\n                    \"ns/day\": float(out[1]),\n                    \"h/ns\": float(out[3]),\n                    \"timesteps/s\": float(out[5]),\n                }\n                try:\n                    self.performance[\"katom-step/s\"] = float(out[7])\n                except IndexError:\n                    self.performance[\"katom-step/s\"] = (\n                        float(out[5]) * self.n_atoms / 1e3\n                    )\n\n    @property\n    def timing_breakdown(self):\n        \"\"\"Get timing breakdown from LAMMPS log file.\n\n        Returns\n        -------\n        dict\n            Dictionary containing timing information for different LAMMPS operations\n            with time spent and percentage of total time\n        \"\"\"\n        start = False\n        timing_breakdown = []\n        for line in self.content:\n            if start:\n                timing_breakdown.append(line)\n            if re.match(\"MPI task timing breakdown\", line):\n                start = True\n            if start and re.match(\"Nlocal:\", line):\n                break\n\n        ldata = [line.split(\"|\") for line in timing_breakdown[2:-2]]\n        # read data into a dict\n        data = {\n            d[0]\n            .strip()\n            .lower(): {\n                \"time\": float(d[2].strip()),\n                \"percentage\": float(d[-1].strip()),\n            }\n            for d in ldata\n        }\n        return data\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsLog.timing_breakdown","title":"<code>timing_breakdown</code>  <code>property</code>","text":"<p>Get timing breakdown from LAMMPS log file.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing timing information for different LAMMPS operations with time spent and percentage of total time</p>"},{"location":"api/#toolbox.io.lammps.LammpsLog.__init__","title":"<code>__init__(fname='log.lammps')</code>","text":"<p>Initialize LammpsLog.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Path to LAMMPS log file, by default \"log.lammps\"</p> <code>'log.lammps'</code> Source code in <code>toolbox/io/lammps.py</code> <pre><code>def __init__(self, fname=\"log.lammps\") -&gt; None:\n    \"\"\"Initialize LammpsLog.\n\n    Parameters\n    ----------\n    fname : str, optional\n        Path to LAMMPS log file, by default \"log.lammps\"\n    \"\"\"\n    self.log_file = fname\n    with open(fname) as f:\n        self.content = f.readlines()\n    # self.string = \"\".join(self.content)\n    self.setup()\n</code></pre>"},{"location":"api/#toolbox.io.lammps.LammpsLog.setup","title":"<code>setup()</code>","text":"<p>Parse log file to extract performance information.</p> Source code in <code>toolbox/io/lammps.py</code> <pre><code>def setup(self):\n    \"\"\"Parse log file to extract performance information.\"\"\"\n    for line in self.content:\n        if re.search(\"MPI tasks\", line):\n            self.cpu_util = float(line.split()[0][:-1])\n            self.n_mpi = int(line.split()[4])\n            self.n_thread = int(line.split()[-3])\n        if re.match(\"Loop time of\", line):\n            self.n_atoms = int(line.split()[-2])\n            self.n_step = int(line.split()[-5])\n            self.n_proc = int(line.split()[5])\n            self.wall_time = float(line.split()[3])\n        if re.match(\"Performance\", line):\n            out = line.split()\n            self.performance = {\n                \"ns/day\": float(out[1]),\n                \"h/ns\": float(out[3]),\n                \"timesteps/s\": float(out[5]),\n            }\n            try:\n                self.performance[\"katom-step/s\"] = float(out[7])\n            except IndexError:\n                self.performance[\"katom-step/s\"] = (\n                    float(out[5]) * self.n_atoms / 1e3\n                )\n</code></pre>"},{"location":"api/#toolbox.io.lammps.OHHWaterLammpsData","title":"<code>OHHWaterLammpsData</code>","text":"<p>               Bases: <code>LammpsData</code></p> <p>Class for O-H-H water LAMMPS data files.</p> <p>This class extends LammpsData to specifically handle water molecules with O-H-H topology, automatically generating bonds and angles.</p> Source code in <code>toolbox/io/lammps.py</code> <pre><code>class OHHWaterLammpsData(LammpsData):\n    \"\"\"Class for O-H-H water LAMMPS data files.\n\n    This class extends LammpsData to specifically handle water molecules\n    with O-H-H topology, automatically generating bonds and angles.\n    \"\"\"\n\n    def __init__(self, atoms) -&gt; None:\n        \"\"\"Initialize OHHWaterLammpsData.\n\n        Parameters\n        ----------\n        atoms : ase.Atoms\n            ASE Atoms object containing water molecules\n        \"\"\"\n        super().__init__(atoms)\n\n        oxygen_ids = np.where(atoms.symbols == \"O\")[0] + 1\n        hydrogen_ids = np.where(atoms.symbols == \"H\")[0] + 1\n\n        bonds, angles = generate_water_bonds_and_angles(\n            oxygen_ids,\n            hydrogen_ids,\n        )\n\n        n_water = len(oxygen_ids)\n        res_id = np.arange(n_water) + 1\n        res_id = np.tile(res_id.reshape(-1, 1), [1, 3]).reshape(-1)\n\n        self.set_bonds(bonds)\n        self.set_angles(angles)\n        self.set_res_id(res_id)\n</code></pre>"},{"location":"api/#toolbox.io.lammps.OHHWaterLammpsData.__init__","title":"<code>__init__(atoms)</code>","text":"<p>Initialize OHHWaterLammpsData.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object containing water molecules</p> required Source code in <code>toolbox/io/lammps.py</code> <pre><code>def __init__(self, atoms) -&gt; None:\n    \"\"\"Initialize OHHWaterLammpsData.\n\n    Parameters\n    ----------\n    atoms : ase.Atoms\n        ASE Atoms object containing water molecules\n    \"\"\"\n    super().__init__(atoms)\n\n    oxygen_ids = np.where(atoms.symbols == \"O\")[0] + 1\n    hydrogen_ids = np.where(atoms.symbols == \"H\")[0] + 1\n\n    bonds, angles = generate_water_bonds_and_angles(\n        oxygen_ids,\n        hydrogen_ids,\n    )\n\n    n_water = len(oxygen_ids)\n    res_id = np.arange(n_water) + 1\n    res_id = np.tile(res_id.reshape(-1, 1), [1, 3]).reshape(-1)\n\n    self.set_bonds(bonds)\n    self.set_angles(angles)\n    self.set_res_id(res_id)\n</code></pre>"},{"location":"api/#toolbox.io.lammps.generate_water_bonds_and_angles","title":"<code>generate_water_bonds_and_angles(oxygen_ids, hydrogen_ids)</code>","text":"<p>Generate bonds and angles for water molecules.</p> <p>This function creates bonds and angles for water molecules based on O-H-H topology.</p> <p>Parameters:</p> Name Type Description Default <code>oxygen_ids</code> <code>array_like</code> <p>Array of oxygen atom indices (1-based)</p> required <code>hydrogen_ids</code> <code>array_like</code> <p>Array of hydrogen atom indices (1-based)</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (bonds, angles) where: - bonds: array with shape (n_water*2, 4) - angles: array with shape (n_water, 5)</p> Source code in <code>toolbox/io/lammps.py</code> <pre><code>def generate_water_bonds_and_angles(oxygen_ids, hydrogen_ids):\n    \"\"\"Generate bonds and angles for water molecules.\n\n    This function creates bonds and angles for water molecules\n    based on O-H-H topology.\n\n    Parameters\n    ----------\n    oxygen_ids : array_like\n        Array of oxygen atom indices (1-based)\n    hydrogen_ids : array_like\n        Array of hydrogen atom indices (1-based)\n\n    Returns\n    -------\n    tuple\n        Tuple of (bonds, angles) where:\n        - bonds: array with shape (n_water*2, 4)\n        - angles: array with shape (n_water, 5)\n    \"\"\"\n    oxygen_ids = np.array(oxygen_ids)\n    hydrogen_ids = np.array(hydrogen_ids)\n    n_water = len(oxygen_ids)\n\n    nbonds = n_water * 2\n    bonds = np.ones((nbonds, 4), dtype=int)\n    np.copyto(bonds[:, 0], np.arange(nbonds) + 1)\n    np.copyto(bonds[::2, 2], oxygen_ids)\n    np.copyto(bonds[1::2, 2], oxygen_ids)\n    np.copyto(bonds[:, 3], hydrogen_ids)\n\n    angles = np.ones((n_water, 5), dtype=int)\n    np.copyto(angles[:, 0], np.arange(n_water) + 1)\n    np.copyto(angles[:, 2], hydrogen_ids[::2])\n    np.copyto(angles[:, 3], oxygen_ids)\n    np.copyto(angles[:, 4], hydrogen_ids[1::2])\n    return bonds, angles\n</code></pre>"},{"location":"api/#toolbox.io.lammps.make_dump_body","title":"<code>make_dump_body(atoms, atype_dict)</code>","text":"<p>Generate LAMMPS dump file body.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>Atoms object</p> required <code>atype_dict</code> <code>dict</code> <p>Atom type dictionary</p> required <p>Returns:</p> Type Description <code>str</code> <p>Body string for LAMMPS dump file</p> Source code in <code>toolbox/io/lammps.py</code> <pre><code>def make_dump_body(atoms, atype_dict):\n    \"\"\"Generate LAMMPS dump file body.\n\n    Parameters\n    ----------\n    atoms : ase.Atoms\n        Atoms object\n    atype_dict : dict\n        Atom type dictionary\n\n    Returns\n    -------\n    str\n        Body string for LAMMPS dump file\n    \"\"\"\n    if len(atoms.get_initial_charges()) &gt; 0:\n        q_flag = True\n        charges = atoms.get_initial_charges()\n    else:\n        q_flag = False\n    ps = atoms.get_positions()\n\n    s = \"\"\n    for atom in atoms:\n        ii = atom.index\n        if q_flag:\n            s += \"{:d} {:d} {:s} {:.16f} {:.16f} {:.16f} {:.16f}\\n\".format(\n                ii + 1,\n                atype_dict[atom.symbol][\"type\"],\n                atype_dict[atom.symbol][\"element\"],\n                ps[ii][0],\n                ps[ii][1],\n                ps[ii][2],\n                charges[ii],\n            )\n        else:\n            s += \"{:d} {:d} {:s} {:.16f} {:.16f} {:.16f}\\n\".format(\n                ii + 1,\n                atype_dict[atom.symbol][\"type\"],\n                atype_dict[atom.symbol][\"element\"],\n                ps[ii][0],\n                ps[ii][1],\n                ps[ii][2],\n            )\n    return s\n</code></pre>"},{"location":"api/#toolbox.io.lammps.make_dump_header","title":"<code>make_dump_header(atoms, ts)</code>","text":"<p>Generate LAMMPS dump file header.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>Atoms object</p> required <code>ts</code> <code>int</code> <p>Current timestep</p> required <p>Returns:</p> Type Description <code>str</code> <p>Header string for LAMMPS dump file</p> Source code in <code>toolbox/io/lammps.py</code> <pre><code>def make_dump_header(atoms, ts):\n    \"\"\"Generate LAMMPS dump file header.\n\n    Parameters\n    ----------\n    atoms : ase.Atoms\n        Atoms object\n    ts : int\n        Current timestep\n\n    Returns\n    -------\n    str\n        Header string for LAMMPS dump file\n    \"\"\"\n    cell = atoms.cell.cellpar()\n    nat = len(atoms)\n    s = f\"ITEM: TIMESTEP\\n{ts:d}\\n\"\n    s += \"ITEM: NUMBER OF ATOMS\\n\"\n    s += f\"{nat:d}\\n\"\n    s += \"ITEM: BOX BOUNDS pp pp pp\\n\"\n    s += f\"{0.0:.4f} {cell[0]:.4f}\\n{0.0:.4f} {cell[1]:.4f}\\n{0.0:.4f} {cell[2]:.4f}\\n\"\n    if len(atoms.get_initial_charges()) &gt; 0:\n        s += \"ITEM: ATOMS id type element x y z q\\n\"\n    else:\n        s += \"ITEM: ATOMS id type element x y z\\n\"\n    return s\n</code></pre>"},{"location":"api/#toolbox.io.lammps.read_dump","title":"<code>read_dump(dump_file='dump.lammpstrj')</code>","text":"<p>Read LAMMPS dump file and extract trajectory data.</p> <p>Parameters:</p> Name Type Description Default <code>dump_file</code> <code>str</code> <p>Path to LAMMPS dump file, by default \"dump.lammpstrj\"</p> <code>'dump.lammpstrj'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (coords, forces, boxs, type_list) where: - coords: array of atomic positions with shape (n_frames, n_atoms*3) - forces: array of atomic forces with shape (n_frames, n_atoms*3) - boxs: array of box vectors with shape (n_frames, 9) - type_list: array of atom types with shape (n_atoms,)</p> Source code in <code>toolbox/io/lammps.py</code> <pre><code>def read_dump(dump_file=\"dump.lammpstrj\"):\n    \"\"\"Read LAMMPS dump file and extract trajectory data.\n\n    Parameters\n    ----------\n    dump_file : str, optional\n        Path to LAMMPS dump file, by default \"dump.lammpstrj\"\n\n    Returns\n    -------\n    tuple\n        Tuple of (coords, forces, boxs, type_list) where:\n        - coords: array of atomic positions with shape (n_frames, n_atoms*3)\n        - forces: array of atomic forces with shape (n_frames, n_atoms*3)\n        - boxs: array of box vectors with shape (n_frames, 9)\n        - type_list: array of atom types with shape (n_atoms,)\n    \"\"\"\n    traj = io.read(dump_file, index=\":\")\n    coords = []\n    forces = []\n    boxs = []\n    for atoms in traj:\n        forces.append(atoms.get_forces())\n        coords.append(atoms.get_positions())\n        boxs.append(atoms.get_cell())\n    coords = np.reshape(coords, (len(traj), -1))\n    forces = np.reshape(forces, (len(traj), -1))\n    boxs = np.reshape(boxs, (len(traj), -1))\n    type_list = atoms.get_array(\"numbers\")\n    type_list = np.array(type_list) - 1\n    return coords, forces, boxs, type_list\n</code></pre>"},{"location":"api/#toolbox.io.lammps.write_dump","title":"<code>write_dump(traj, type_map, start=0, step=1, out_file='out.lammpstrj', append=False)</code>","text":"<p>Write LAMMPS dump file from trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>Atoms or list</code> <p>Trajectory data</p> required <code>type_map</code> <code>list or dict</code> <p>Type mapping for atoms</p> required <code>start</code> <code>int</code> <p>Starting timestep, by default 0</p> <code>0</code> <code>step</code> <code>int</code> <p>Timestep interval, by default 1</p> <code>1</code> <code>out_file</code> <code>str</code> <p>Output filename, by default \"out.lammpstrj\"</p> <code>'out.lammpstrj'</code> <code>append</code> <code>bool</code> <p>Whether to append to existing file, by default False</p> <code>False</code> Source code in <code>toolbox/io/lammps.py</code> <pre><code>def write_dump(traj, type_map, start=0, step=1, out_file=\"out.lammpstrj\", append=False):\n    \"\"\"Write LAMMPS dump file from trajectory.\n\n    Parameters\n    ----------\n    traj : ase.Atoms or list\n        Trajectory data\n    type_map : list or dict\n        Type mapping for atoms\n    start : int, optional\n        Starting timestep, by default 0\n    step : int, optional\n        Timestep interval, by default 1\n    out_file : str, optional\n        Output filename, by default \"out.lammpstrj\"\n    append : bool, optional\n        Whether to append to existing file, by default False\n    \"\"\"\n    if isinstance(type_map, list):\n        atype_dict = {}\n        for ii, atype in enumerate(type_map, start=1):\n            atype_dict[atype] = {}\n            atype_dict[atype][\"type\"] = ii\n            atype_dict[atype][\"element\"] = atype\n    elif isinstance(type_map, dict):\n        atype_dict = type_map\n    else:\n        raise AttributeError(\"Unknown type of type_map\")\n\n    if isinstance(traj, Atoms):\n        _write_dump(traj, atype_dict, start, out_file, append)\n    else:\n        nframe = len(traj)\n        _ts = np.arange(start, step * nframe, step)\n        for ts, atoms in zip(_ts, traj, strict=False):\n            _write_dump(atoms, atype_dict, ts, out_file, append=True)\n</code></pre>"},{"location":"api/#plotting-module","title":"Plotting Module","text":""},{"location":"api/#core-plotting-functions","title":"Core Plotting Functions","text":""},{"location":"api/#toolbox.plot.core","title":"<code>toolbox.plot.core</code>","text":"<p>Core plotting utilities module.</p> <p>This module provides core plotting functions and utilities for creating various types of plots including learning curves, RMSE plots, binned statistics, and colored line plots.</p>"},{"location":"api/#toolbox.plot.core.ax_bin_stats","title":"<code>ax_bin_stats(ax, x, y, bins)</code>","text":"<p>Create binned statistics plot on given axes.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Matplotlib axes object</p> required <code>x</code> <code>array_like</code> <p>X values</p> required <code>y</code> <code>array_like</code> <p>Y values</p> required <code>bins</code> <code>int</code> <p>Number of bins</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing binned statistics data</p> Source code in <code>toolbox/plot/core.py</code> <pre><code>def ax_bin_stats(ax, x, y, bins):\n    \"\"\"Create binned statistics plot on given axes.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Matplotlib axes object\n    x : array_like\n        X values\n    y : array_like\n        Y values\n    bins : int\n        Number of bins\n\n    Returns\n    -------\n    dict\n        Dictionary containing binned statistics data\n    \"\"\"\n    # ref line (y = 0)\n    ax.axhline(y=0, color=\"gray\")\n    # mean\n    bin_means, bin_edges, binnumber = stats.binned_statistic(x, y, bins=bins)\n    bin_means[np.isnan(bin_means)] = 0.0\n    bin_centers = bin_edges[1:] - (bin_edges[1] - bin_edges[0]) / 2\n    ax.plot(bin_centers, bin_means, color=\"black\", lw=1.5, label=\"mean\")\n\n    # max/min\n    bin_maxs, bin_edges, binnumber = stats.binned_statistic(\n        x, y, statistic=\"max\", bins=bins\n    )\n    bin_mins, bin_edges, binnumber = stats.binned_statistic(\n        x, y, statistic=\"min\", bins=bins\n    )\n    bin_maxs[np.isnan(bin_maxs)] = 0.0\n    bin_mins[np.isnan(bin_maxs)] = 0.0\n    ax.fill_between(bin_centers, bin_mins, bin_maxs, color=\"silver\", label=\"[min, max]\")\n    # std\n    bin_stds, bin_edges, binnumber = stats.binned_statistic(\n        x, y, statistic=\"std\", bins=bins\n    )\n    bin_stds[np.isnan(bin_stds)] = 0.0\n    ax.fill_between(\n        bin_centers,\n        bin_means - bin_stds,\n        bin_means + bin_stds,\n        color=\"gray\",\n        label=\"[mean-std, mean+std]\",\n    )\n    data = {\n        \"grid\": bin_centers,\n        \"mean\": bin_means,\n        \"max\": bin_maxs,\n        \"min\": bin_mins,\n        \"std\": bin_stds,\n    }\n    return data\n</code></pre>"},{"location":"api/#toolbox.plot.core.ax_colormap_lines","title":"<code>ax_colormap_lines(ax, xs, ys, labels, scale=(0.0, 1.0), colormap='GnBu', fmt='%f', **kwargs)</code>","text":"<p>Plot multiple colored lines on axes.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Matplotlib axes object</p> required <code>xs</code> <code>list</code> <p>List of x data arrays</p> required <code>ys</code> <code>list</code> <p>List of y data arrays</p> required <code>labels</code> <code>list</code> <p>List of legend labels</p> required <code>scale</code> <code>tuple</code> <p>Scale range for normalization, by default (0.0, 1.0)</p> <code>(0.0, 1.0)</code> <code>colormap</code> <code>str</code> <p>Matplotlib colormap name, by default \"GnBu\"</p> <code>'GnBu'</code> <code>fmt</code> <code>str</code> <p>Format string for legend labels, by default \"%f\"</p> <code>'%f'</code> <code>**kwargs</code> <p>Additional keyword arguments passed to ax.plot</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>Function modifies the axes object in place</p> Source code in <code>toolbox/plot/core.py</code> <pre><code>def ax_colormap_lines(\n    ax, xs, ys, labels, scale=(0.0, 1.0), colormap=\"GnBu\", fmt=\"%f\", **kwargs\n):\n    \"\"\"Plot multiple colored lines on axes.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Matplotlib axes object\n    xs : list\n        List of x data arrays\n    ys : list\n        List of y data arrays\n    labels : list\n        List of legend labels\n    scale : tuple, optional\n        Scale range for normalization, by default (0.0, 1.0)\n    colormap : str, optional\n        Matplotlib colormap name, by default \"GnBu\"\n    fmt : str, optional\n        Format string for legend labels, by default \"%f\"\n    **kwargs\n        Additional keyword arguments passed to ax.plot\n\n    Returns\n    -------\n    None\n        Function modifies the axes object in place\n    \"\"\"\n    labels = np.array(labels)\n    # normalization\n    labels = (labels - labels.min()) / (labels.max() - labels.min())\n    cm_scales = (labels - scale[0]) / (scale[1] - scale[0])\n    for x, y, label, cm_scale in zip(xs, ys, labels, cm_scales, strict=False):\n        ax.plot(\n            x, y, color=plt.get_cmap(colormap)(cm_scale), label=fmt % label, **kwargs\n        )\n    ax.set_xlim(np.min(x), np.max(x))\n</code></pre>"},{"location":"api/#toolbox.plot.core.ax_rmse","title":"<code>ax_rmse(ax, x, y)</code>","text":"<p>Create RMSE scatter plot with reference line.</p> <p>This function creates a scatter plot of data points with a reference line (y=x) for visual comparison.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Matplotlib axes object</p> required <code>x</code> <code>array_like</code> <p>X values</p> required <code>y</code> <code>array_like</code> <p>Y values</p> required Source code in <code>toolbox/plot/core.py</code> <pre><code>def ax_rmse(ax, x, y):\n    \"\"\"Create RMSE scatter plot with reference line.\n\n    This function creates a scatter plot of data points\n    with a reference line (y=x) for visual comparison.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Matplotlib axes object\n    x : array_like\n        X values\n    y : array_like\n        Y values\n    \"\"\"\n    # scatter\n    ax.scatter(x, y, color=\"steelblue\", alpha=0.2)\n    # ref line\n    ref = np.arange(x.min(), x.max(), (x.max() - x.min()) / 100)\n    ax.plot(ref, ref, color=\"firebrick\", lw=1.5)\n</code></pre>"},{"location":"api/#toolbox.plot.core.ax_setlabel","title":"<code>ax_setlabel(ax, xlabel, ylabel, **kwargs)</code>","text":"<p>Set axis labels for matplotlib axes.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Matplotlib axes object</p> required <code>xlabel</code> <code>str</code> <p>X-axis label</p> required <code>ylabel</code> <code>str</code> <p>Y-axis label</p> required <code>**kwargs</code> <p>Additional keyword arguments passed to set_xlabel/set_ylabel</p> <code>{}</code> Source code in <code>toolbox/plot/core.py</code> <pre><code>def ax_setlabel(ax, xlabel, ylabel, **kwargs):\n    \"\"\"Set axis labels for matplotlib axes.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Matplotlib axes object\n    xlabel : str\n        X-axis label\n    ylabel : str\n        Y-axis label\n    **kwargs\n        Additional keyword arguments passed to set_xlabel/set_ylabel\n    \"\"\"\n    ax.set_xlabel(xlabel, **kwargs)\n    ax.set_ylabel(ylabel, **kwargs)\n</code></pre>"},{"location":"api/#toolbox.plot.core.plot_bin_stats","title":"<code>plot_bin_stats(x, y, xlabel, ylabel, bins=None)</code>","text":"<p>Plot binned statistics with confidence intervals.</p> <p>This function creates a plot showing mean, standard deviation, and min/max ranges for binned data.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>X values</p> required <code>y</code> <code>array_like</code> <p>Y values</p> required <code>xlabel</code> <code>str</code> <p>X-axis label</p> required <code>ylabel</code> <code>str</code> <p>Y-axis label</p> required <code>bins</code> <code>int</code> <p>Number of bins, by default len(x)//10</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (fig, ax) containing matplotlib figure and axes</p> Source code in <code>toolbox/plot/core.py</code> <pre><code>def plot_bin_stats(x, y, xlabel, ylabel, bins=None):\n    \"\"\"Plot binned statistics with confidence intervals.\n\n    This function creates a plot showing mean, standard deviation,\n    and min/max ranges for binned data.\n\n    Parameters\n    ----------\n    x : array_like\n        X values\n    y : array_like\n        Y values\n    xlabel : str\n        X-axis label\n    ylabel : str\n        Y-axis label\n    bins : int, optional\n        Number of bins, by default len(x)//10\n\n    Returns\n    -------\n    tuple\n        Tuple of (fig, ax) containing matplotlib figure and axes\n    \"\"\"\n    x = np.array(x).flatten()\n    y = np.array(y).flatten()\n    if bins is None:\n        bins = len(x) // 10\n\n    fig, ax = plt.subplots(figsize=[6, 4], dpi=200)\n    ax_bin_stats(ax, x, y, bins=bins)\n    ax_setlabel(ax, xlabel, ylabel)\n    ax.legend(loc=\"center left\", bbox_to_anchor=(1.1, 0.5))\n    return fig, ax\n</code></pre>"},{"location":"api/#toolbox.plot.core.plot_colormap_lines","title":"<code>plot_colormap_lines(xs, ys, legends, xlabel, ylabel, colormap='GnBu')</code>","text":"<p>Plot multiple lines with colormap.</p> <p>This function creates a plot with multiple lines colored according to a colormap.</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>list</code> <p>List of x data arrays</p> required <code>ys</code> <code>list</code> <p>List of y data arrays</p> required <code>legends</code> <code>list</code> <p>List of legend labels</p> required <code>xlabel</code> <code>str</code> <p>X-axis label</p> required <code>ylabel</code> <code>str</code> <p>Y-axis label</p> required <code>colormap</code> <code>str</code> <p>Matplotlib colormap name, by default \"GnBu\"</p> <code>'GnBu'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (fig, ax) containing matplotlib figure and axes</p> Source code in <code>toolbox/plot/core.py</code> <pre><code>def plot_colormap_lines(xs, ys, legends, xlabel, ylabel, colormap=\"GnBu\"):\n    \"\"\"Plot multiple lines with colormap.\n\n    This function creates a plot with multiple lines colored\n    according to a colormap.\n\n    Parameters\n    ----------\n    xs : list\n        List of x data arrays\n    ys : list\n        List of y data arrays\n    legends : list\n        List of legend labels\n    xlabel : str\n        X-axis label\n    ylabel : str\n        Y-axis label\n    colormap : str, optional\n        Matplotlib colormap name, by default \"GnBu\"\n\n    Returns\n    -------\n    tuple\n        Tuple of (fig, ax) containing matplotlib figure and axes\n    \"\"\"\n    fig, ax = plt.subplots(figsize=[6, 4], dpi=200)\n    ax_colormap_lines(ax, xs, ys, legends, colormap)\n    ax_setlabel(ax, xlabel, ylabel)\n    ax.legend(loc=\"center left\", bbox_to_anchor=(1.1, 0.5))\n    return fig, ax\n</code></pre>"},{"location":"api/#toolbox.plot.core.plot_lcurve","title":"<code>plot_lcurve(fname, col, xlabel=None, ylabel=None, **kwargs)</code>","text":"<p>Plot learning curve from data file.</p> <p>This function reads a data file and plots a learning curve from the specified column.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Path to data file</p> required <code>col</code> <code>int</code> <p>Column index to plot (0-based)</p> required <code>xlabel</code> <code>str</code> <p>X-axis label, by default None</p> <code>None</code> <code>ylabel</code> <code>str</code> <p>Y-axis label, by default None</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments passed to ax.plot()</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (fig, ax, data) containing matplotlib figure, axes object, and loaded data</p> Source code in <code>toolbox/plot/core.py</code> <pre><code>def plot_lcurve(fname, col, xlabel=None, ylabel=None, **kwargs):\n    \"\"\"Plot learning curve from data file.\n\n    This function reads a data file and plots a learning curve\n    from the specified column.\n\n    Parameters\n    ----------\n    fname : str\n        Path to data file\n    col : int\n        Column index to plot (0-based)\n    xlabel : str, optional\n        X-axis label, by default None\n    ylabel : str, optional\n        Y-axis label, by default None\n    **kwargs\n        Additional keyword arguments passed to ax.plot()\n\n    Returns\n    -------\n    tuple\n        Tuple of (fig, ax, data) containing matplotlib figure,\n        axes object, and loaded data\n    \"\"\"\n    fig, ax = plt.subplots()\n    data = np.loadtxt(fname)\n    x = data[:, 0]\n    ax.plot(x, data[:, col], **kwargs)\n    ax.set_xlim(x.min(), x.max())\n    ax.set_ylim(bottom=0.0)\n    if xlabel is not None and ylabel is not None:\n        ax_setlabel(ax, xlabel, ylabel)\n\n    return fig, ax, data\n</code></pre>"},{"location":"api/#toolbox.plot.core.plot_rmse","title":"<code>plot_rmse(x, y, xlabel, ylabel, **kwargs)</code>","text":"<p>Plot RMSE scatter plot with reference line.</p> <p>This function creates a scatter plot of data points with a reference line and calculates RMSE.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>X values</p> required <code>y</code> <code>array_like</code> <p>Y values</p> required <code>xlabel</code> <code>str</code> <p>X-axis label</p> required <code>ylabel</code> <code>str</code> <p>Y-axis label</p> required <code>**kwargs</code> <p>Additional keyword arguments passed to plotting functions</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (fig, ax, rmse) containing matplotlib figure, axes object, and calculated RMSE</p> Source code in <code>toolbox/plot/core.py</code> <pre><code>def plot_rmse(x, y, xlabel, ylabel, **kwargs):\n    \"\"\"Plot RMSE scatter plot with reference line.\n\n    This function creates a scatter plot of data points\n    with a reference line and calculates RMSE.\n\n    Parameters\n    ----------\n    x : array_like\n        X values\n    y : array_like\n        Y values\n    xlabel : str\n        X-axis label\n    ylabel : str\n        Y-axis label\n    **kwargs\n        Additional keyword arguments passed to plotting functions\n\n    Returns\n    -------\n    tuple\n        Tuple of (fig, ax, rmse) containing matplotlib figure,\n        axes object, and calculated RMSE\n    \"\"\"\n    x = np.array(x)\n    y = np.array(y)\n\n    rmse = np.sqrt(metrics.mean_squared_error(x, y))\n\n    fig, ax = plt.subplots(figsize=[4, 4])\n    ax_rmse(ax, x, y)\n    ax_setlabel(ax, xlabel, ylabel, **kwargs)\n\n    return fig, ax, rmse\n</code></pre>"},{"location":"api/#deep-potential-plotting","title":"Deep Potential Plotting","text":""},{"location":"api/#toolbox.plot.dp","title":"<code>toolbox.plot.dp</code>","text":"<p>Deep Potential plotting module.</p> <p>This module provides specialized plotting classes for visualizing Deep Potential (DP) training data and results.</p>"},{"location":"api/#toolbox.plot.dp.DPTrainFigure","title":"<code>DPTrainFigure</code>","text":"<p>               Bases: <code>Figure</code></p> <p>Figure class for DP training visualization.</p> <p>This class extends Figure to provide specific functionality for visualizing Deep Potential training data.</p> Source code in <code>toolbox/plot/dp.py</code> <pre><code>class DPTrainFigure(Figure):\n    \"\"\"Figure class for DP training visualization.\n\n    This class extends Figure to provide specific\n    functionality for visualizing Deep Potential training data.\n    \"\"\"\n\n    def __init__(self, ax) -&gt; None:\n        \"\"\"Initialize DPTrainFigure.\n\n        Parameters\n        ----------\n        ax : matplotlib.axes.Axes\n            Matplotlib axes object\n        \"\"\"\n        super().__init__(ax)\n\n    def setup(self, x, y, **kwargs):\n        \"\"\"Set up DP training plot.\n\n        Parameters\n        ----------\n        x : array_like\n            Training data features\n        y : array_like\n            Training data targets\n        **kwargs\n            Additional keyword arguments\n        \"\"\"\n        kwargs.update({\"alpha\": 0.2})\n        self.ax.set_yscale(\"log\")\n        super().setup(x, y, **kwargs)\n</code></pre>"},{"location":"api/#toolbox.plot.dp.DPTrainFigure.__init__","title":"<code>__init__(ax)</code>","text":"<p>Initialize DPTrainFigure.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Matplotlib axes object</p> required Source code in <code>toolbox/plot/dp.py</code> <pre><code>def __init__(self, ax) -&gt; None:\n    \"\"\"Initialize DPTrainFigure.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Matplotlib axes object\n    \"\"\"\n    super().__init__(ax)\n</code></pre>"},{"location":"api/#toolbox.plot.dp.DPTrainFigure.setup","title":"<code>setup(x, y, **kwargs)</code>","text":"<p>Set up DP training plot.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>Training data features</p> required <code>y</code> <code>array_like</code> <p>Training data targets</p> required <code>**kwargs</code> <p>Additional keyword arguments</p> <code>{}</code> Source code in <code>toolbox/plot/dp.py</code> <pre><code>def setup(self, x, y, **kwargs):\n    \"\"\"Set up DP training plot.\n\n    Parameters\n    ----------\n    x : array_like\n        Training data features\n    y : array_like\n        Training data targets\n    **kwargs\n        Additional keyword arguments\n    \"\"\"\n    kwargs.update({\"alpha\": 0.2})\n    self.ax.set_yscale(\"log\")\n    super().setup(x, y, **kwargs)\n</code></pre>"},{"location":"api/#figure-classes","title":"Figure Classes","text":""},{"location":"api/#toolbox.plot.figure","title":"<code>toolbox.plot.figure</code>","text":"<p>Figure classes module.</p> <p>This module provides base and specialized figure classes for creating matplotlib plots with consistent styling and layout.</p>"},{"location":"api/#toolbox.plot.figure.Figure","title":"<code>Figure</code>","text":"<p>Base class for matplotlib figure creation.</p> <p>This class provides a framework for creating matplotlib figures with consistent styling and layout.</p> Source code in <code>toolbox/plot/figure.py</code> <pre><code>class Figure:\n    \"\"\"Base class for matplotlib figure creation.\n\n    This class provides a framework for creating\n    matplotlib figures with consistent styling and layout.\n    \"\"\"\n\n    def __init__(self, **kwargs) -&gt; None:\n        \"\"\"Initialize Figure.\n\n        Parameters\n        ----------\n        **kwargs\n            Additional keyword arguments passed to plt.subplots\n        \"\"\"\n        self.fig, self.ax = plt.subplots(**kwargs)\n\n    def setup(self, x, y, xlim=None, ylim=None, **kwargs):\n        \"\"\"Set up basic plot with data.\n\n        Parameters\n        ----------\n        x : array_like\n            X data values\n        y : array_like\n            Y data values\n        xlim : tuple, optional\n            X-axis limits as (min, max), by default None\n        ylim : tuple, optional\n            Y-axis limits as (min, max), by default None\n        **kwargs\n            Additional keyword arguments passed to ax.plot\n        \"\"\"\n        self.ax.plot(x, y, **kwargs)\n        if xlim is None:\n            xlim = (np.min(x), np.max(x))\n        if ylim is None:\n            ylim = (\n                np.min(y) - (np.max(y) - np.min(y)) * 0.1,\n                np.max(y) + (np.max(y) - np.min(y)) * 0.1,\n            )\n        self.xlim = xlim\n        self.ylim = ylim\n        self.ax.set_xlim(xlim)\n        self.ax.set_ylim(ylim)\n\n    def set_labels(self, kw, xlabel=None, ylabel=None, **kwargs):\n        \"\"\"Set axis labels from keyword dictionary.\n\n        Parameters\n        ----------\n        kw : str\n            Keyword to look up in label dictionary\n        xlabel : str, optional\n            X-axis label, by default None\n        ylabel : str, optional\n            Y-axis label, by default None\n        **kwargs\n            Additional keyword arguments passed to ax_setlabel\n        \"\"\"\n        try:\n            labels = label_dict.get(kw)\n            xlabel = labels[0]\n            ylabel = labels[1]\n        except KeyError:\n            assert (xlabel is not None) and (ylabel is not None)\n            ax_setlabel(self.ax, xlabel, ylabel, **kwargs)\n</code></pre>"},{"location":"api/#toolbox.plot.figure.Figure.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize Figure.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments passed to plt.subplots</p> <code>{}</code> Source code in <code>toolbox/plot/figure.py</code> <pre><code>def __init__(self, **kwargs) -&gt; None:\n    \"\"\"Initialize Figure.\n\n    Parameters\n    ----------\n    **kwargs\n        Additional keyword arguments passed to plt.subplots\n    \"\"\"\n    self.fig, self.ax = plt.subplots(**kwargs)\n</code></pre>"},{"location":"api/#toolbox.plot.figure.Figure.set_labels","title":"<code>set_labels(kw, xlabel=None, ylabel=None, **kwargs)</code>","text":"<p>Set axis labels from keyword dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>kw</code> <code>str</code> <p>Keyword to look up in label dictionary</p> required <code>xlabel</code> <code>str</code> <p>X-axis label, by default None</p> <code>None</code> <code>ylabel</code> <code>str</code> <p>Y-axis label, by default None</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments passed to ax_setlabel</p> <code>{}</code> Source code in <code>toolbox/plot/figure.py</code> <pre><code>def set_labels(self, kw, xlabel=None, ylabel=None, **kwargs):\n    \"\"\"Set axis labels from keyword dictionary.\n\n    Parameters\n    ----------\n    kw : str\n        Keyword to look up in label dictionary\n    xlabel : str, optional\n        X-axis label, by default None\n    ylabel : str, optional\n        Y-axis label, by default None\n    **kwargs\n        Additional keyword arguments passed to ax_setlabel\n    \"\"\"\n    try:\n        labels = label_dict.get(kw)\n        xlabel = labels[0]\n        ylabel = labels[1]\n    except KeyError:\n        assert (xlabel is not None) and (ylabel is not None)\n        ax_setlabel(self.ax, xlabel, ylabel, **kwargs)\n</code></pre>"},{"location":"api/#toolbox.plot.figure.Figure.setup","title":"<code>setup(x, y, xlim=None, ylim=None, **kwargs)</code>","text":"<p>Set up basic plot with data.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>X data values</p> required <code>y</code> <code>array_like</code> <p>Y data values</p> required <code>xlim</code> <code>tuple</code> <p>X-axis limits as (min, max), by default None</p> <code>None</code> <code>ylim</code> <code>tuple</code> <p>Y-axis limits as (min, max), by default None</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments passed to ax.plot</p> <code>{}</code> Source code in <code>toolbox/plot/figure.py</code> <pre><code>def setup(self, x, y, xlim=None, ylim=None, **kwargs):\n    \"\"\"Set up basic plot with data.\n\n    Parameters\n    ----------\n    x : array_like\n        X data values\n    y : array_like\n        Y data values\n    xlim : tuple, optional\n        X-axis limits as (min, max), by default None\n    ylim : tuple, optional\n        Y-axis limits as (min, max), by default None\n    **kwargs\n        Additional keyword arguments passed to ax.plot\n    \"\"\"\n    self.ax.plot(x, y, **kwargs)\n    if xlim is None:\n        xlim = (np.min(x), np.max(x))\n    if ylim is None:\n        ylim = (\n            np.min(y) - (np.max(y) - np.min(y)) * 0.1,\n            np.max(y) + (np.max(y) - np.min(y)) * 0.1,\n        )\n    self.xlim = xlim\n    self.ylim = ylim\n    self.ax.set_xlim(xlim)\n    self.ax.set_ylim(ylim)\n</code></pre>"},{"location":"api/#toolbox.plot.figure.FullCellFigure","title":"<code>FullCellFigure</code>","text":"<p>               Bases: <code>Figure</code></p> <p>Figure class for full cell visualization.</p> <p>This class extends Figure to provide specific functionality for visualizing systems with full periodic boundary conditions.</p> Source code in <code>toolbox/plot/figure.py</code> <pre><code>class FullCellFigure(Figure):\n    \"\"\"Figure class for full cell visualization.\n\n    This class extends Figure to provide specific\n    functionality for visualizing systems with full periodic\n    boundary conditions.\n    \"\"\"\n\n    def __init__(self, **kwargs) -&gt; None:\n        \"\"\"Initialize FullCellFigure.\n\n        Parameters\n        ----------\n        **kwargs\n            Additional keyword arguments passed to parent class\n        \"\"\"\n        super().__init__(**kwargs)\n\n    def setup(self, x, y, xlim=None, ylim=None, z_surfs=None, **kwargs):\n        \"\"\"Set up full cell visualization plot.\n\n        Parameters\n        ----------\n        x : array_like\n            X data values\n        y : array_like\n            Y data values\n        xlim : tuple, optional\n            X-axis limits as (min, max), by default None\n        ylim : tuple, optional\n            Y-axis limits as (min, max), by default None\n        z_surfs : list\n            List of z-surface positions for visualization\n        **kwargs\n            Additional keyword arguments passed to parent setup method\n        \"\"\"\n        super().setup(x, y, xlim, ylim, **kwargs)\n\n        ax = self.ax\n        ax.axvline(x=z_surfs[0])\n        ax.axvline(x=z_surfs[1])\n        ax.axvline(x=(z_surfs[0] + z_surfs[1]) / 2, ls=\"--\")\n        ax.fill_between(\n            x,\n            self.ylim[0],\n            self.ylim[1],\n            where=x &lt;= z_surfs[0],\n            facecolor=\"gray\",\n            alpha=0.5,\n        )\n        ax.fill_between(\n            x,\n            self.ylim[0],\n            self.ylim[1],\n            where=x &gt;= z_surfs[1],\n            facecolor=\"gray\",\n            alpha=0.5,\n        )\n</code></pre>"},{"location":"api/#toolbox.plot.figure.FullCellFigure.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize FullCellFigure.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments passed to parent class</p> <code>{}</code> Source code in <code>toolbox/plot/figure.py</code> <pre><code>def __init__(self, **kwargs) -&gt; None:\n    \"\"\"Initialize FullCellFigure.\n\n    Parameters\n    ----------\n    **kwargs\n        Additional keyword arguments passed to parent class\n    \"\"\"\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"api/#toolbox.plot.figure.FullCellFigure.setup","title":"<code>setup(x, y, xlim=None, ylim=None, z_surfs=None, **kwargs)</code>","text":"<p>Set up full cell visualization plot.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>X data values</p> required <code>y</code> <code>array_like</code> <p>Y data values</p> required <code>xlim</code> <code>tuple</code> <p>X-axis limits as (min, max), by default None</p> <code>None</code> <code>ylim</code> <code>tuple</code> <p>Y-axis limits as (min, max), by default None</p> <code>None</code> <code>z_surfs</code> <code>list</code> <p>List of z-surface positions for visualization</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments passed to parent setup method</p> <code>{}</code> Source code in <code>toolbox/plot/figure.py</code> <pre><code>def setup(self, x, y, xlim=None, ylim=None, z_surfs=None, **kwargs):\n    \"\"\"Set up full cell visualization plot.\n\n    Parameters\n    ----------\n    x : array_like\n        X data values\n    y : array_like\n        Y data values\n    xlim : tuple, optional\n        X-axis limits as (min, max), by default None\n    ylim : tuple, optional\n        Y-axis limits as (min, max), by default None\n    z_surfs : list\n        List of z-surface positions for visualization\n    **kwargs\n        Additional keyword arguments passed to parent setup method\n    \"\"\"\n    super().setup(x, y, xlim, ylim, **kwargs)\n\n    ax = self.ax\n    ax.axvline(x=z_surfs[0])\n    ax.axvline(x=z_surfs[1])\n    ax.axvline(x=(z_surfs[0] + z_surfs[1]) / 2, ls=\"--\")\n    ax.fill_between(\n        x,\n        self.ylim[0],\n        self.ylim[1],\n        where=x &lt;= z_surfs[0],\n        facecolor=\"gray\",\n        alpha=0.5,\n    )\n    ax.fill_between(\n        x,\n        self.ylim[0],\n        self.ylim[1],\n        where=x &gt;= z_surfs[1],\n        facecolor=\"gray\",\n        alpha=0.5,\n    )\n</code></pre>"},{"location":"api/#toolbox.plot.figure.HalfCellFigure","title":"<code>HalfCellFigure</code>","text":"<p>               Bases: <code>Figure</code></p> <p>Figure class for half cell visualization.</p> <p>This class extends Figure to provide specific functionality for visualizing systems with half periodic boundary conditions (slab geometry).</p> Source code in <code>toolbox/plot/figure.py</code> <pre><code>class HalfCellFigure(Figure):\n    \"\"\"Figure class for half cell visualization.\n\n    This class extends Figure to provide specific\n    functionality for visualizing systems with half periodic\n    boundary conditions (slab geometry).\n    \"\"\"\n\n    def __init__(self, **kwargs) -&gt; None:\n        \"\"\"Initialize HalfCellFigure.\n\n        Parameters\n        ----------\n        **kwargs\n            Additional keyword arguments passed to parent class\n        \"\"\"\n        super().__init__(**kwargs)\n\n    def setup(self, x, y, xlim=None, ylim=None, z_surf=None, **kwargs):\n        \"\"\"Set up half cell visualization plot.\n\n        Parameters\n        ----------\n        x : array_like\n            X data values\n        y : array_like\n            Y data values\n        xlim : tuple, optional\n            X-axis limits as (min, max), by default None\n        ylim : tuple, optional\n            Y-axis limits as (min, max), by default None\n        z_surf : float\n            Z-surface position for visualization\n        **kwargs\n            Additional keyword arguments passed to parent setup method\n        \"\"\"\n        super().setup(x, y, xlim, ylim, **kwargs)\n\n        ax = self.ax\n        ax.axvline(x=z_surf)\n        ax.fill_between(\n            x, self.ylim[0], self.ylim[1], where=x &lt; z_surf, facecolor=\"gray\", alpha=0.5\n        )\n</code></pre>"},{"location":"api/#toolbox.plot.figure.HalfCellFigure.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize HalfCellFigure.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments passed to parent class</p> <code>{}</code> Source code in <code>toolbox/plot/figure.py</code> <pre><code>def __init__(self, **kwargs) -&gt; None:\n    \"\"\"Initialize HalfCellFigure.\n\n    Parameters\n    ----------\n    **kwargs\n        Additional keyword arguments passed to parent class\n    \"\"\"\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"api/#toolbox.plot.figure.HalfCellFigure.setup","title":"<code>setup(x, y, xlim=None, ylim=None, z_surf=None, **kwargs)</code>","text":"<p>Set up half cell visualization plot.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>X data values</p> required <code>y</code> <code>array_like</code> <p>Y data values</p> required <code>xlim</code> <code>tuple</code> <p>X-axis limits as (min, max), by default None</p> <code>None</code> <code>ylim</code> <code>tuple</code> <p>Y-axis limits as (min, max), by default None</p> <code>None</code> <code>z_surf</code> <code>float</code> <p>Z-surface position for visualization</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments passed to parent setup method</p> <code>{}</code> Source code in <code>toolbox/plot/figure.py</code> <pre><code>def setup(self, x, y, xlim=None, ylim=None, z_surf=None, **kwargs):\n    \"\"\"Set up half cell visualization plot.\n\n    Parameters\n    ----------\n    x : array_like\n        X data values\n    y : array_like\n        Y data values\n    xlim : tuple, optional\n        X-axis limits as (min, max), by default None\n    ylim : tuple, optional\n        Y-axis limits as (min, max), by default None\n    z_surf : float\n        Z-surface position for visualization\n    **kwargs\n        Additional keyword arguments passed to parent setup method\n    \"\"\"\n    super().setup(x, y, xlim, ylim, **kwargs)\n\n    ax = self.ax\n    ax.axvline(x=z_surf)\n    ax.fill_between(\n        x, self.ylim[0], self.ylim[1], where=x &lt; z_surf, facecolor=\"gray\", alpha=0.5\n    )\n</code></pre>"},{"location":"api/#statistical-plotting","title":"Statistical Plotting","text":""},{"location":"api/#toolbox.plot.stats","title":"<code>toolbox.plot.stats</code>","text":"<p>Statistical plotting module.</p> <p>This module provides classes for creating statistical plots and performing statistical tests, including finite difference method testing.</p>"},{"location":"api/#toolbox.plot.stats.FDMTest","title":"<code>FDMTest</code>","text":"<p>Finite difference method test for derivative.</p> <p>This class implements finite difference methods to test numerical derivatives against analytical solutions.</p> Source code in <code>toolbox/plot/stats.py</code> <pre><code>class FDMTest:\n    \"\"\"Finite difference method test for derivative.\n\n    This class implements finite difference methods\n    to test numerical derivatives against analytical solutions.\n    \"\"\"\n\n    def __init__(self, **kwargs) -&gt; None:\n        \"\"\"Initialize FDMTest.\n\n        Parameters\n        ----------\n        **kwargs\n            Additional keyword arguments passed to plt.subplots\n        \"\"\"\n        self.fig, self.axs = plt.subplots(\n            nrows=2, figsize=[4, 6], sharex=\"all\", **kwargs\n        )\n\n    def setup(self, x, y, dydx):\n        \"\"\"Set up finite difference test.\n\n        Parameters\n        ----------\n        x : array_like\n            X values\n        y : array_like\n            Y values\n        dydx : array_like\n            Analytical derivative values\n        \"\"\"\n        self.stats_dict = {}\n        ax = self.axs[0]\n        ax.scatter(x, dydx, color=\"blue\", label=\"original data\")\n        fit_output = stats.linregress(x, dydx)\n        ax.plot(\n            x,\n            x * fit_output.slope + fit_output.intercept,\n            \"--\",\n            color=\"red\",\n            label=\"fitted line\",\n        )\n        self.stats_dict[\"slope\"] = fit_output.slope\n        self.stats_dict[\"intercept\"] = fit_output.intercept\n        self.stats_dict[\"rvalue\"] = fit_output.rvalue\n\n        ax = self.axs[1]\n        ref_data_diff = np.diff(y, axis=0).reshape(-1)\n        test_data_diff = 0.5 * np.diff(x, axis=0) * (dydx[1:] + dydx[:-1])\n        ax.scatter(x[1:], ref_data_diff, color=\"blue\", label=\"original data\")\n        ax.plot(x[1:], test_data_diff, \"--\", color=\"red\", label=\"fitted line\")\n        self.stats_dict[\"mean error\"] = np.mean(ref_data_diff - test_data_diff)\n</code></pre>"},{"location":"api/#toolbox.plot.stats.FDMTest.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize FDMTest.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments passed to plt.subplots</p> <code>{}</code> Source code in <code>toolbox/plot/stats.py</code> <pre><code>def __init__(self, **kwargs) -&gt; None:\n    \"\"\"Initialize FDMTest.\n\n    Parameters\n    ----------\n    **kwargs\n        Additional keyword arguments passed to plt.subplots\n    \"\"\"\n    self.fig, self.axs = plt.subplots(\n        nrows=2, figsize=[4, 6], sharex=\"all\", **kwargs\n    )\n</code></pre>"},{"location":"api/#toolbox.plot.stats.FDMTest.setup","title":"<code>setup(x, y, dydx)</code>","text":"<p>Set up finite difference test.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>X values</p> required <code>y</code> <code>array_like</code> <p>Y values</p> required <code>dydx</code> <code>array_like</code> <p>Analytical derivative values</p> required Source code in <code>toolbox/plot/stats.py</code> <pre><code>def setup(self, x, y, dydx):\n    \"\"\"Set up finite difference test.\n\n    Parameters\n    ----------\n    x : array_like\n        X values\n    y : array_like\n        Y values\n    dydx : array_like\n        Analytical derivative values\n    \"\"\"\n    self.stats_dict = {}\n    ax = self.axs[0]\n    ax.scatter(x, dydx, color=\"blue\", label=\"original data\")\n    fit_output = stats.linregress(x, dydx)\n    ax.plot(\n        x,\n        x * fit_output.slope + fit_output.intercept,\n        \"--\",\n        color=\"red\",\n        label=\"fitted line\",\n    )\n    self.stats_dict[\"slope\"] = fit_output.slope\n    self.stats_dict[\"intercept\"] = fit_output.intercept\n    self.stats_dict[\"rvalue\"] = fit_output.rvalue\n\n    ax = self.axs[1]\n    ref_data_diff = np.diff(y, axis=0).reshape(-1)\n    test_data_diff = 0.5 * np.diff(x, axis=0) * (dydx[1:] + dydx[:-1])\n    ax.scatter(x[1:], ref_data_diff, color=\"blue\", label=\"original data\")\n    ax.plot(x[1:], test_data_diff, \"--\", color=\"red\", label=\"fitted line\")\n    self.stats_dict[\"mean error\"] = np.mean(ref_data_diff - test_data_diff)\n</code></pre>"},{"location":"api/#plot-styles","title":"Plot Styles","text":""},{"location":"api/#toolbox.plot.style","title":"<code>toolbox.plot.style</code>","text":"<p>Matplotlib style module.</p> <p>This module provides functionality for using custom matplotlib styles and color maps for scientific plotting.</p> References <ul> <li>https://matplotlib.org/stable/tutorials/introductory/customizing.html</li> <li>https://matplotlib.org/stable/users/prev_whats_new/dflt_style_changes.html</li> <li>https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html</li> </ul>"},{"location":"api/#toolbox.plot.style.use_style","title":"<code>use_style(style_name)</code>","text":"<p>Use custom matplotlib style.</p> <p>Parameters:</p> Name Type Description Default <code>style_name</code> <code>str</code> <p>Name of the style to use</p> required Notes <p>If the specified style is not found, falls back to fivethirtyeight style and prints a warning.</p> Source code in <code>toolbox/plot/style.py</code> <pre><code>def use_style(style_name):\n    \"\"\"Use custom matplotlib style.\n\n    Parameters\n    ----------\n    style_name : str\n        Name of the style to use\n\n    Notes\n    -----\n    If the specified style is not found, falls back to fivethirtyeight\n    style and prints a warning.\n    \"\"\"\n    plt.style.use(\"fivethirtyeight\")\n    fname = str(MODULE_DIR / (f\"mplstyle/{style_name}.mplstyle\"))\n    # print(fname)\n    try:\n        plt.style.use(fname)\n    except OSError:\n        print(\n            f\"Warning: no style {style_name} is found. Use matplotlib default style.\"\n        )\n    \"\"\"\n    Set colors:\n    https://stackoverflow.com/questions/68664116/is-there-a-way-to-change-the-color-names-color-in-mplstyle-file\n    \"\"\"\n    color_map = colors.get_named_colors_mapping()\n    color_map[\"red\"] = \"#D7422A\"\n    color_map[\"blue\"] = \"#003C88\"\n</code></pre>"},{"location":"api/#utils-module","title":"Utils Module","text":""},{"location":"api/#bibliography-tools","title":"Bibliography Tools","text":""},{"location":"api/#toolbox.utils.bibtool","title":"<code>toolbox.utils.bibtool</code>","text":"<p>Bibliography tool module.</p> <p>This module provides utilities for managing bibliography files, including extracting citations from LaTeX files and exporting selected bibliography entries.</p>"},{"location":"api/#toolbox.utils.bibtool.export","title":"<code>export(bib_in_file, tex_files=None, bib_out_file='export-ref.bib', online=True)</code>","text":"<p>Export a subset of the bib file that is used in the tex file.</p> <p>Parameters:</p> Name Type Description Default <code>bib_in_file</code> <code>str</code> <p>Path to the original bib file</p> required <code>tex_files</code> <code>Union[List[str], str]</code> <p>Path to the tex file or list of tex files</p> <code>None</code> <code>bib_out_file</code> <code>str</code> <p>Path to the output bib file</p> <code>'export-ref.bib'</code> <code>online</code> <code>bool</code> <p>If True, it will try to get the bib entry from the DOI</p> <code>True</code> Source code in <code>toolbox/utils/bibtool.py</code> <pre><code>def export(\n    bib_in_file: str,\n    tex_files: Optional[Union[List[str], str]] = None,\n    bib_out_file: str = \"export-ref.bib\",\n    online: bool = True,\n):\n    \"\"\"\n    Export a subset of the bib file that is used in the tex file.\n\n    Parameters\n    ----------\n    bib_in_file : str\n        Path to the original bib file\n    tex_files : Union[List[str], str]\n        Path to the tex file or list of tex files\n    bib_out_file : str\n        Path to the output bib file\n    online : bool\n        If True, it will try to get the bib entry from the DOI\n    \"\"\"\n    if tex_files is None:\n        tex_files = glob.glob(\"./*.tex\")\n    if isinstance(tex_files, str):\n        tex_files = [tex_files]\n\n    citation_keys = extract_citation_keys(tex_files)\n    bib_data = parse_file(bib_in_file)\n\n    new_bib_data = BibliographyData()\n    for kw in tqdm(citation_keys):\n        if kw in bib_data.entries:\n            if online:\n                try:\n                    out = get_bib_from_doi(\n                        bib_data.entries[kw].fields[\"doi\"], abbrev_journal=True\n                    )\n                    obj = parse_string(out[1], bib_format=\"bibtex\")\n                    for tmp_kw in obj.entries:\n                        print(tmp_kw)\n                    new_bib_data.entries[kw] = obj.entries[tmp_kw]\n                except KeyError:\n                    new_bib_data.entries[kw] = bib_data.entries[kw]\n                new_bib_data.entries[kw].fields[\"title\"] = bib_data.entries[kw].fields[\n                    \"title\"\n                ]\n                with contextlib.suppress(KeyError):\n                    new_bib_data.entries[kw].fields[\"journal\"] = bib_data.entries[\n                        kw\n                    ].fields[\"journal\"]\n            else:\n                new_bib_data.entries[kw] = bib_data.entries[kw]\n\n    with open(bib_out_file, \"w\") as new_bib_file:\n        new_bib_file.write(new_bib_data.to_string(\"bibtex\"))\n</code></pre>"},{"location":"api/#toolbox.utils.bibtool.extract_citation_keys","title":"<code>extract_citation_keys(fnames)</code>","text":"<p>Grep all citation keys used in the tex file.</p> <p>Parameters:</p> Name Type Description Default <code>fnames</code> <code>str</code> <p>Path to the tex file</p> required Source code in <code>toolbox/utils/bibtool.py</code> <pre><code>def extract_citation_keys(fnames: list[str]):\n    \"\"\"\n    Grep all citation keys used in the tex file.\n\n    Parameters\n    ----------\n    fnames : str\n        Path to the tex file\n    \"\"\"\n    citation_keys = set()\n    for fname in fnames:\n        with open(fname) as file:\n            tex_content = file.read()\n        _citation_keys = set(re.findall(r\"\\\\cite{([^}]+)}\", tex_content))\n        _citation_keys = {\n            key.strip() for keys in _citation_keys for key in keys.split(\",\")\n        }\n        citation_keys.update(_citation_keys)\n    return citation_keys\n</code></pre>"},{"location":"api/#data-utilities","title":"Data Utilities","text":""},{"location":"api/#toolbox.utils.data","title":"<code>toolbox.utils.data</code>","text":"<p>Data system management module.</p> <p>This module provides base classes for managing data system configurations with read and write functionality.</p>"},{"location":"api/#toolbox.utils.data.DataSystem","title":"<code>DataSystem</code>","text":"<p>Base class for data system management.</p> <p>This class provides a framework for reading and writing data system configurations.</p> Source code in <code>toolbox/utils/data.py</code> <pre><code>class DataSystem:\n    \"\"\"Base class for data system management.\n\n    This class provides a framework for reading and writing\n    data system configurations.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize DataSystem.\"\"\"\n        pass\n\n    def read(self):\n        \"\"\"Read data system configuration.\"\"\"\n        pass\n\n    def write(self):\n        \"\"\"Write data system configuration.\"\"\"\n        pass\n</code></pre>"},{"location":"api/#toolbox.utils.data.DataSystem.__init__","title":"<code>__init__()</code>","text":"<p>Initialize DataSystem.</p> Source code in <code>toolbox/utils/data.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize DataSystem.\"\"\"\n    pass\n</code></pre>"},{"location":"api/#toolbox.utils.data.DataSystem.read","title":"<code>read()</code>","text":"<p>Read data system configuration.</p> Source code in <code>toolbox/utils/data.py</code> <pre><code>def read(self):\n    \"\"\"Read data system configuration.\"\"\"\n    pass\n</code></pre>"},{"location":"api/#toolbox.utils.data.DataSystem.write","title":"<code>write()</code>","text":"<p>Write data system configuration.</p> Source code in <code>toolbox/utils/data.py</code> <pre><code>def write(self):\n    \"\"\"Write data system configuration.\"\"\"\n    pass\n</code></pre>"},{"location":"api/#mathematical-functions","title":"Mathematical Functions","text":""},{"location":"api/#toolbox.utils.math","title":"<code>toolbox.utils.math</code>","text":"<p>Mathematical utilities module.</p> <p>This module provides various mathematical functions for data analysis, including statistical functions, interpolation, integration, filtering, and error metrics.</p>"},{"location":"api/#toolbox.utils.math.block_ave","title":"<code>block_ave(_x, _y, l_block)</code>","text":"<p>Calculate block averages of data.</p> <p>Parameters:</p> Name Type Description Default <code>_x</code> <code>array_like</code> <p>Input x values</p> required <code>_y</code> <code>array_like</code> <p>Input y values</p> required <code>l_block</code> <code>int</code> <p>Block size for averaging</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (x_ave, y_ave) containing block-averaged values</p> Source code in <code>toolbox/utils/math.py</code> <pre><code>def block_ave(_x, _y, l_block):\n    \"\"\"Calculate block averages of data.\n\n    Parameters\n    ----------\n    _x : array_like\n        Input x values\n    _y : array_like\n        Input y values\n    l_block : int\n        Block size for averaging\n\n    Returns\n    -------\n    tuple\n        Tuple of (x_ave, y_ave) containing block-averaged values\n    \"\"\"\n    assert len(_x) == len(_y)\n    n_block = math.floor(len(_x) / l_block)\n    x = _x[: (n_block * l_block)]\n    y = _y[: (n_block * l_block)]\n    x = np.reshape(x, (-1, l_block)).mean(axis=-1)\n    y = np.reshape(y, (-1, l_block)).mean(axis=-1)\n    return x, y\n</code></pre>"},{"location":"api/#toolbox.utils.math.cumave","title":"<code>cumave(data)</code>","text":"<p>Calculate cumulative average of data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>array_like</code> <p>Input data</p> required <p>Returns:</p> Type Description <code>array_like</code> <p>Cumulative average values</p> Source code in <code>toolbox/utils/math.py</code> <pre><code>def cumave(data):\n    \"\"\"Calculate cumulative average of data.\n\n    Parameters\n    ----------\n    data : array_like\n        Input data\n\n    Returns\n    -------\n    array_like\n        Cumulative average values\n    \"\"\"\n    cum_sum = data.cumsum()\n    cum_ave = cum_sum / (np.arange(len(data)) + 1)\n    return cum_ave\n</code></pre>"},{"location":"api/#toolbox.utils.math.error_test","title":"<code>error_test(y_true, y_pred)</code>","text":"<p>Calculate regression error metrics.</p> <p>This function calculates various regression error metrics between true and predicted values.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>array_like</code> <p>True values</p> required <code>y_pred</code> <code>array_like</code> <p>Predicted values</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing error metrics: - max_err: Maximum error - mae: Mean absolute error - rmse: Root mean squared error - r2: R-squared score - mape: Mean absolute percentage error</p> References <p>https://scikit-learn.org/stable/modules/model_evaluation.html#regression-metrics</p> Source code in <code>toolbox/utils/math.py</code> <pre><code>def error_test(y_true, y_pred):\n    \"\"\"Calculate regression error metrics.\n\n    This function calculates various regression error metrics\n    between true and predicted values.\n\n    Parameters\n    ----------\n    y_true : array_like\n        True values\n    y_pred : array_like\n        Predicted values\n\n    Returns\n    -------\n    dict\n        Dictionary containing error metrics:\n        - max_err: Maximum error\n        - mae: Mean absolute error\n        - rmse: Root mean squared error\n        - r2: R-squared score\n        - mape: Mean absolute percentage error\n\n    References\n    ----------\n    https://scikit-learn.org/stable/modules/model_evaluation.html#regression-metrics\n    \"\"\"\n    results_dict = {}\n    y_true = np.reshape(y_true, (-1,))\n    y_pred = np.reshape(y_pred, (-1,))\n\n    results_dict[\"max_err\"] = metrics.max_error(y_true, y_pred)\n    results_dict[\"mae\"] = metrics.mean_absolute_error(y_true, y_pred)\n    results_dict[\"rmse\"] = np.sqrt(metrics.mean_squared_error(y_true, y_pred))\n    results_dict[\"r2\"] = metrics.r2_score(y_true, y_pred)\n    results_dict[\"mape\"] = metrics.mean_absolute_percentage_error(y_true, y_pred)\n    return results_dict\n</code></pre>"},{"location":"api/#toolbox.utils.math.gaussian_filter","title":"<code>gaussian_filter(data, bin_edge, sigma, weight=None)</code>","text":"<p>Apply Gaussian filter to data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>array_like</code> <p>Input data to filter</p> required <code>bin_edge</code> <code>array_like</code> <p>Bin edges for filtering</p> required <code>sigma</code> <code>float</code> <p>Gaussian standard deviation</p> required <code>weight</code> <code>array_like</code> <p>Weights for each data point</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (bins, filtered_data)</p> Source code in <code>toolbox/utils/math.py</code> <pre><code>def gaussian_filter(data, bin_edge, sigma: float, weight=None):\n    \"\"\"Apply Gaussian filter to data.\n\n    Parameters\n    ----------\n    data : array_like\n        Input data to filter\n    bin_edge : array_like\n        Bin edges for filtering\n    sigma : float\n        Gaussian standard deviation\n    weight : array_like, optional\n        Weights for each data point\n\n    Returns\n    -------\n    tuple\n        Tuple of (bins, filtered_data)\n    \"\"\"\n    data = np.reshape(data, (-1, 1))\n    bins = get_bins_from_bin_edge(bin_edge)\n    bins = np.reshape(bins, (1, -1))\n    weight = np.ones_like(data) if weight is None else np.reshape(weight, (-1, 1))\n    output = (\n        np.exp(-(((bins - data) / sigma) ** 2)) / (np.sqrt(2 * np.pi) * sigma) * weight\n    )\n    return bins, output.sum(axis=0)\n</code></pre>"},{"location":"api/#toolbox.utils.math.gaussian_func","title":"<code>gaussian_func(x, mu=0, sigma=1)</code>","text":"<p>Gaussian probability density function.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>Input values</p> required <code>mu</code> <code>float</code> <p>Mean of the distribution, by default 0</p> <code>0</code> <code>sigma</code> <code>float</code> <p>Standard deviation, by default 1</p> <code>1</code> <p>Returns:</p> Type Description <code>array_like</code> <p>Gaussian probability density values</p> Source code in <code>toolbox/utils/math.py</code> <pre><code>def gaussian_func(x, mu=0, sigma=1):\n    \"\"\"Gaussian probability density function.\n\n    Parameters\n    ----------\n    x : array_like\n        Input values\n    mu : float, optional\n        Mean of the distribution, by default 0\n    sigma : float, optional\n        Standard deviation, by default 1\n\n    Returns\n    -------\n    array_like\n        Gaussian probability density values\n    \"\"\"\n    return stats.norm.pdf(x, loc=mu, scale=sigma)\n</code></pre>"},{"location":"api/#toolbox.utils.math.gaussian_int","title":"<code>gaussian_int(x, mu, sigma)</code>","text":"<p>Gaussian cumulative distribution function.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>Input values</p> required <code>mu</code> <code>float</code> <p>Mean of the distribution</p> required <code>sigma</code> <code>float</code> <p>Standard deviation</p> required <p>Returns:</p> Type Description <code>array_like</code> <p>Gaussian cumulative distribution values</p> Source code in <code>toolbox/utils/math.py</code> <pre><code>def gaussian_int(x, mu, sigma):\n    \"\"\"Gaussian cumulative distribution function.\n\n    Parameters\n    ----------\n    x : array_like\n        Input values\n    mu : float\n        Mean of the distribution\n    sigma : float\n        Standard deviation\n\n    Returns\n    -------\n    array_like\n        Gaussian cumulative distribution values\n    \"\"\"\n    coeff = 1 / 2\n    return coeff * erf((x - mu) / (np.sqrt(2) * sigma))\n</code></pre>"},{"location":"api/#toolbox.utils.math.get_bin_ave","title":"<code>get_bin_ave(data, bin_size=10)</code>","text":"<p>Calculate binned averages of data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>array_like</code> <p>Input data to bin</p> required <code>bin_size</code> <code>int</code> <p>Size of each bin, by default 10</p> <code>10</code> <p>Returns:</p> Type Description <code>array_like</code> <p>Binned averages</p> Source code in <code>toolbox/utils/math.py</code> <pre><code>def get_bin_ave(data, bin_size=10):\n    \"\"\"Calculate binned averages of data.\n\n    Parameters\n    ----------\n    data : array_like\n        Input data to bin\n    bin_size : int, optional\n        Size of each bin, by default 10\n\n    Returns\n    -------\n    array_like\n        Binned averages\n    \"\"\"\n    total_size = len(data)\n    out_size = bin_size * total_size // bin_size\n    data = np.reshape(data[:out_size], (-1, bin_size))\n    data = np.mean(data, axis=-1)\n    return data\n</code></pre>"},{"location":"api/#toolbox.utils.math.get_dev","title":"<code>get_dev(x, y)</code>","text":"<p>Calculate derivative dy/dx.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>Input x values</p> required <code>y</code> <code>array_like</code> <p>Input y values</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (x_mid, dy/dx) where x_mid are midpoints</p> Source code in <code>toolbox/utils/math.py</code> <pre><code>def get_dev(x, y):\n    \"\"\"Calculate derivative dy/dx.\n\n    Parameters\n    ----------\n    x : array_like\n        Input x values\n    y : array_like\n        Input y values\n\n    Returns\n    -------\n    tuple\n        Tuple of (x_mid, dy/dx) where x_mid are midpoints\n    \"\"\"\n    x = np.array(x)\n    y = np.array(y)\n    delta_x = np.diff(x)\n    delta_y = np.diff(y)\n    out_x = (x[1:] + x[:-1]) / 2\n    return out_x, delta_y / delta_x\n</code></pre>"},{"location":"api/#toolbox.utils.math.get_int","title":"<code>get_int(x, y)</code>","text":"<p>Calculate numerical integral using trapezoidal rule.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>Input x values</p> required <code>y</code> <code>array_like</code> <p>Input y values</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (x_mid, integral) where x_mid are midpoints</p> Source code in <code>toolbox/utils/math.py</code> <pre><code>def get_int(x, y):\n    \"\"\"Calculate numerical integral using trapezoidal rule.\n\n    Parameters\n    ----------\n    x : array_like\n        Input x values\n    y : array_like\n        Input y values\n\n    Returns\n    -------\n    tuple\n        Tuple of (x_mid, integral) where x_mid are midpoints\n    \"\"\"\n    x = np.array(x)\n    y = np.array(y)\n    ave_y = (y[1:] + y[:-1]) / 2\n    delta_x = np.diff(x)\n    x = (x[1:] + x[:-1]) / 2\n    return x, np.cumsum(ave_y * delta_x)\n</code></pre>"},{"location":"api/#toolbox.utils.math.get_int_array","title":"<code>get_int_array(x, ys)</code>","text":"<p>Calculate numerical integrals for multiple y arrays.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>Input x values</p> required <code>ys</code> <code>array_like</code> <p>Multiple y arrays with shape (n_arrays, n_points)</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (x_mid, integrals) where x_mid are midpoints</p> Source code in <code>toolbox/utils/math.py</code> <pre><code>def get_int_array(x, ys):\n    \"\"\"Calculate numerical integrals for multiple y arrays.\n\n    Parameters\n    ----------\n    x : array_like\n        Input x values\n    ys : array_like\n        Multiple y arrays with shape (n_arrays, n_points)\n\n    Returns\n    -------\n    tuple\n        Tuple of (x_mid, integrals) where x_mid are midpoints\n    \"\"\"\n    x = np.array(x)\n    ys = np.array(ys)\n    ave_y = (ys[:, 1:] + ys[:, :-1]) / 2\n    delta_x = np.diff(x)\n    x = (x[1:] + x[:-1]) / 2\n    return x, np.cumsum(ave_y * delta_x.reshape(1, -1), axis=-1)\n</code></pre>"},{"location":"api/#toolbox.utils.math.handle_zero_division","title":"<code>handle_zero_division(x, y, threshold=None)</code>","text":"<p>Handle division by zero with optional threshold.</p> <p>This function safely divides x by y, handling zero division with optional threshold masking.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>Numerator values</p> required <code>y</code> <code>array_like</code> <p>Denominator values</p> required <code>threshold</code> <code>float</code> <p>Threshold below which y values are set to zero</p> <code>None</code> <p>Returns:</p> Type Description <code>array_like</code> <p>Result of x/y with safe division</p> Source code in <code>toolbox/utils/math.py</code> <pre><code>def handle_zero_division(x, y, threshold=None):\n    \"\"\"Handle division by zero with optional threshold.\n\n    This function safely divides x by y, handling zero\n    division with optional threshold masking.\n\n    Parameters\n    ----------\n    x : array_like\n        Numerator values\n    y : array_like\n        Denominator values\n    threshold : float, optional\n        Threshold below which y values are set to zero\n\n    Returns\n    -------\n    array_like\n        Result of x/y with safe division\n    \"\"\"\n    if threshold is not None:\n        mask = np.abs(y) &lt;= threshold\n        y[np.nonzero(mask)] = 0.0\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        result = np.true_divide(x, y)\n        # replace NaN and Inf values with 0\n        result[~np.isfinite(result)] = 0\n    return result\n</code></pre>"},{"location":"api/#toolbox.utils.math.interp","title":"<code>interp(x, dataset)</code>","text":"<p>Interpolate y values from dataset.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>X values to interpolate at</p> required <code>dataset</code> <code>array_like</code> <p>Dataset with dataset[0] = x_values, dataset[1] = y_values</p> required <p>Returns:</p> Type Description <code>array_like</code> <p>Interpolated y values</p> Source code in <code>toolbox/utils/math.py</code> <pre><code>def interp(x, dataset):\n    \"\"\"Interpolate y values from dataset.\n\n    Parameters\n    ----------\n    x : array_like\n        X values to interpolate at\n    dataset : array_like\n        Dataset with dataset[0] = x_values, dataset[1] = y_values\n\n    Returns\n    -------\n    array_like\n        Interpolated y values\n    \"\"\"\n    y = np.interp(x, xp=dataset[0], fp=dataset[1])\n    return y\n</code></pre>"},{"location":"api/#toolbox.utils.math.vec_project","title":"<code>vec_project(vec, unit_vec)</code>","text":"<p>Project vector onto unit vector.</p> <p>Parameters:</p> Name Type Description Default <code>vec</code> <code>array_like</code> <p>Vector to project</p> required <code>unit_vec</code> <code>array_like</code> <p>Unit vector to project onto</p> required <p>Returns:</p> Type Description <code>array_like</code> <p>Projected vector</p> Source code in <code>toolbox/utils/math.py</code> <pre><code>def vec_project(vec, unit_vec):\n    \"\"\"Project vector onto unit vector.\n\n    Parameters\n    ----------\n    vec : array_like\n        Vector to project\n    unit_vec : array_like\n        Unit vector to project onto\n\n    Returns\n    -------\n    array_like\n        Projected vector\n    \"\"\"\n    return np.dot(vec, unit_vec) * unit_vec\n</code></pre>"},{"location":"api/#optimizer","title":"Optimizer","text":""},{"location":"api/#toolbox.utils.optimizer","title":"<code>toolbox.utils.optimizer</code>","text":"<p>Optimizer module.</p> <p>This module provides classes and functions for optimization using various linear regression methods.</p>"},{"location":"api/#toolbox.utils.optimizer.Optimizer","title":"<code>Optimizer</code>","text":"<p>Optimizer for linear regression models.</p> <p>This class provides various optimization methods for fitting linear models to data.</p> Source code in <code>toolbox/utils/optimizer.py</code> <pre><code>class Optimizer:\n    \"\"\"Optimizer for linear regression models.\n\n    This class provides various optimization methods for\n    fitting linear models to data.\n    \"\"\"\n\n    def __init__(self, method=\"ols_cut\") -&gt; None:\n        \"\"\"Initialize Optimizer.\n\n        Parameters\n        ----------\n        method : str, optional\n            Optimization method to use, by default \"ols_cut\"\n        \"\"\"\n        self.method = method\n\n    def run(self, x, y, **kwargs):\n        \"\"\"Run optimization with specified method.\n\n        Parameters\n        ----------\n        x : array_like\n            Input features\n        y : array_like\n            Target values\n        **kwargs\n            Additional keyword arguments\n\n        Returns\n        -------\n        array_like\n            Optimization result\n        \"\"\"\n        assert len(x) == len(y)\n        output = getattr(self, f\"_run_{self.method}\")(x, y, **kwargs)\n        return output\n\n    def _run_ols(self, x, y):\n        \"\"\"Run ordinary least squares optimization.\n\n        Parameters\n        ----------\n        x : array_like\n            Input features\n        y : array_like\n            Target values\n\n        Returns\n        -------\n        array_like\n            Optimization result [-intercept/slope]\n        \"\"\"\n        result = stats.linregress(x=x, y=y)\n        output = -result.intercept / result.slope\n        return output\n\n    def _run_ols_cut(self, x, y, nstep=4):\n        \"\"\"Run OLS with cutoff on recent data.\n\n        Parameters\n        ----------\n        x : array_like\n            Input features\n        y : array_like\n            Target values\n        nstep : int, optional\n            Number of recent steps to use, by default 4\n\n        Returns\n        -------\n        array_like\n            Optimization result [-intercept/slope]\n        \"\"\"\n        l_cut = min(len(x), nstep)\n        result = stats.linregress(x=x[-l_cut:], y=y[-l_cut:])\n        output = -result.intercept / result.slope\n        return output\n\n    def _run_wls(self, X, y):\n        \"\"\"Run weighted least squares optimization.\n\n        Parameters\n        ----------\n        X : array_like\n            Input features with constant term\n        y : array_like\n            Target values\n\n        Returns\n        -------\n        array_like\n            Optimization result [-intercept/slope]\n        \"\"\"\n        # fit linear regression model\n        X = sm.add_constant(self.x)\n        wt = np.exp(-(np.array(self.y) ** 2) / 0.1)\n        fit_wls = sm.WLS(self.y, X, weights=wt).fit()\n        return -fit_wls.params[0] / fit_wls.params[1]\n\n    def _run_wls_cut(self, X, y, nstep=4):\n        \"\"\"Run WLS with cutoff on recent data.\n\n        Parameters\n        ----------\n        X : array_like\n            Input features with constant term\n        y : array_like\n            Target values\n        nstep : int, optional\n            Number of recent steps to use, by default 4\n\n        Returns\n        -------\n        array_like\n            Optimization result [-intercept/slope]\n        \"\"\"\n        l_cut = min(len(X), nstep)\n        X = X[-l_cut:]\n        y = y[-l_cut:]\n        X = sm.add_constant(X)\n        wt = np.exp(-(np.array(y) ** 2) / 0.1)\n        fit_wls = sm.WLS(y, X, weights=wt).fit()\n        return -fit_wls.params[0] / fit_wls.params[1]\n</code></pre>"},{"location":"api/#toolbox.utils.optimizer.Optimizer.__init__","title":"<code>__init__(method='ols_cut')</code>","text":"<p>Initialize Optimizer.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Optimization method to use, by default \"ols_cut\"</p> <code>'ols_cut'</code> Source code in <code>toolbox/utils/optimizer.py</code> <pre><code>def __init__(self, method=\"ols_cut\") -&gt; None:\n    \"\"\"Initialize Optimizer.\n\n    Parameters\n    ----------\n    method : str, optional\n        Optimization method to use, by default \"ols_cut\"\n    \"\"\"\n    self.method = method\n</code></pre>"},{"location":"api/#toolbox.utils.optimizer.Optimizer.run","title":"<code>run(x, y, **kwargs)</code>","text":"<p>Run optimization with specified method.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>Input features</p> required <code>y</code> <code>array_like</code> <p>Target values</p> required <code>**kwargs</code> <p>Additional keyword arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>array_like</code> <p>Optimization result</p> Source code in <code>toolbox/utils/optimizer.py</code> <pre><code>def run(self, x, y, **kwargs):\n    \"\"\"Run optimization with specified method.\n\n    Parameters\n    ----------\n    x : array_like\n        Input features\n    y : array_like\n        Target values\n    **kwargs\n        Additional keyword arguments\n\n    Returns\n    -------\n    array_like\n        Optimization result\n    \"\"\"\n    assert len(x) == len(y)\n    output = getattr(self, f\"_run_{self.method}\")(x, y, **kwargs)\n    return output\n</code></pre>"},{"location":"api/#toy-models","title":"Toy Models","text":""},{"location":"api/#toolbox.utils.toy_model","title":"<code>toolbox.utils.toy_model</code>","text":"<p>Toy model module.</p> <p>This module provides simple physics models for educational purposes, including a parallel plate capacitor model.</p>"},{"location":"api/#toolbox.utils.toy_model.ParallelPlateCapacitor","title":"<code>ParallelPlateCapacitor</code>","text":"<p>Class for parallel plate capacitor calculations.</p> <p>This class models a parallel plate capacitor system with configurable permittivity, plate distance, and capacitance.</p> <p>Parameters:</p> Name Type Description Default <code>epsilon_r</code> <code>float</code> <p>Relative permittivity</p> <code>None</code> <code>d</code> <code>float</code> <p>Distance between plates in Angstroms</p> <code>None</code> <code>capacitance</code> <code>float</code> <p>Capacitance in \u03bcF/cm\u00b2</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obj = ParallelPlateCapacitor(epsilon_r=10.0, d=4.0)\n&gt;&gt;&gt; print(obj)\n&gt;&gt;&gt; obj = ParallelPlateCapacitor(capacitance=20.0, d=4.0)\n&gt;&gt;&gt; print(obj)\n</code></pre> Source code in <code>toolbox/utils/toy_model.py</code> <pre><code>class ParallelPlateCapacitor:\n    \"\"\"Class for parallel plate capacitor calculations.\n\n    This class models a parallel plate capacitor system\n    with configurable permittivity, plate distance, and capacitance.\n\n    Parameters\n    ----------\n    epsilon_r : float\n        Relative permittivity\n    d : float\n        Distance between plates in Angstroms\n    capacitance : float\n        Capacitance in \u03bcF/cm\u00b2\n\n    Examples\n    --------\n    &gt;&gt;&gt; obj = ParallelPlateCapacitor(epsilon_r=10.0, d=4.0)\n    &gt;&gt;&gt; print(obj)\n    &gt;&gt;&gt; obj = ParallelPlateCapacitor(capacitance=20.0, d=4.0)\n    &gt;&gt;&gt; print(obj)\n    \"\"\"\n\n    def __init__(\n        self,\n        epsilon_r: Optional[float] = None,\n        d: Optional[float] = None,\n        capacitance: Optional[float] = None,\n    ):\n        \"\"\"Initialize ParallelPlateCapacitor.\n\n        Parameters\n        ----------\n        epsilon_r : Optional[float], optional\n            Relative permittivity, by default None\n        d : Optional[float], optional\n            Distance between plates in Angstroms, by default None\n        capacitance : Optional[float], optional\n            Capacitance in \u03bcF/cm\u00b2, by default None\n        \"\"\"\n        # conversion factor from F/m\u00b2 to \u03bcF/cm\u00b2\n        self._coeff = constants.centi**2 / constants.micro\n\n        if epsilon_r is not None:\n            self._epsilon_r = epsilon_r\n\n        if d is not None:\n            # d [m]\n            self._d = d * constants.angstrom\n\n        if capacitance is not None:\n            self._capacitance = capacitance\n\n    @property\n    def capacitance(self):\n        \"\"\"Get capacitance in \u03bcF/cm\u00b2.\"\"\"\n        try:\n            return self._capacitance\n        except AttributeError:\n            return self._epsilon_r * constants.epsilon_0 / self._d * self._coeff\n\n    @property\n    def epsilon_r(self):\n        \"\"\"Get relative permittivity.\"\"\"\n        try:\n            return self._epsilon_r\n        except AttributeError:\n            return self._capacitance * self._d / (constants.epsilon_0 * self._coeff)\n\n    @property\n    def d_angstrom(self):\n        \"\"\"Get plate distance in Angstroms.\"\"\"\n        return self._d / constants.angstrom\n\n    def __repr__(self):\n        \"\"\"Return string representation of the capacitor.\n\n        Returns\n        -------\n        str\n            String representation showing key parameters\n        \"\"\"\n        return f\"ParallelPlateCapacitor(epsilon_r={self.epsilon_r}, d={self.d_angstrom} angstrom, capacitance={self.capacitance} muF/cm^2)\"\n</code></pre>"},{"location":"api/#toolbox.utils.toy_model.ParallelPlateCapacitor.capacitance","title":"<code>capacitance</code>  <code>property</code>","text":"<p>Get capacitance in \u03bcF/cm\u00b2.</p>"},{"location":"api/#toolbox.utils.toy_model.ParallelPlateCapacitor.d_angstrom","title":"<code>d_angstrom</code>  <code>property</code>","text":"<p>Get plate distance in Angstroms.</p>"},{"location":"api/#toolbox.utils.toy_model.ParallelPlateCapacitor.epsilon_r","title":"<code>epsilon_r</code>  <code>property</code>","text":"<p>Get relative permittivity.</p>"},{"location":"api/#toolbox.utils.toy_model.ParallelPlateCapacitor.__init__","title":"<code>__init__(epsilon_r=None, d=None, capacitance=None)</code>","text":"<p>Initialize ParallelPlateCapacitor.</p> <p>Parameters:</p> Name Type Description Default <code>epsilon_r</code> <code>Optional[float]</code> <p>Relative permittivity, by default None</p> <code>None</code> <code>d</code> <code>Optional[float]</code> <p>Distance between plates in Angstroms, by default None</p> <code>None</code> <code>capacitance</code> <code>Optional[float]</code> <p>Capacitance in \u03bcF/cm\u00b2, by default None</p> <code>None</code> Source code in <code>toolbox/utils/toy_model.py</code> <pre><code>def __init__(\n    self,\n    epsilon_r: Optional[float] = None,\n    d: Optional[float] = None,\n    capacitance: Optional[float] = None,\n):\n    \"\"\"Initialize ParallelPlateCapacitor.\n\n    Parameters\n    ----------\n    epsilon_r : Optional[float], optional\n        Relative permittivity, by default None\n    d : Optional[float], optional\n        Distance between plates in Angstroms, by default None\n    capacitance : Optional[float], optional\n        Capacitance in \u03bcF/cm\u00b2, by default None\n    \"\"\"\n    # conversion factor from F/m\u00b2 to \u03bcF/cm\u00b2\n    self._coeff = constants.centi**2 / constants.micro\n\n    if epsilon_r is not None:\n        self._epsilon_r = epsilon_r\n\n    if d is not None:\n        # d [m]\n        self._d = d * constants.angstrom\n\n    if capacitance is not None:\n        self._capacitance = capacitance\n</code></pre>"},{"location":"api/#toolbox.utils.toy_model.ParallelPlateCapacitor.__repr__","title":"<code>__repr__()</code>","text":"<p>Return string representation of the capacitor.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation showing key parameters</p> Source code in <code>toolbox/utils/toy_model.py</code> <pre><code>def __repr__(self):\n    \"\"\"Return string representation of the capacitor.\n\n    Returns\n    -------\n    str\n        String representation showing key parameters\n    \"\"\"\n    return f\"ParallelPlateCapacitor(epsilon_r={self.epsilon_r}, d={self.d_angstrom} angstrom, capacitance={self.capacitance} muF/cm^2)\"\n</code></pre>"},{"location":"api/#unit-conversion","title":"Unit Conversion","text":""},{"location":"api/#toolbox.utils.unit","title":"<code>toolbox.utils.unit</code>","text":"<p>Physical constants and unit conversions.</p> References <p>https://docs.scipy.org/doc/scipy/reference/constants.html</p>"},{"location":"api/#general-utilities","title":"General Utilities","text":""},{"location":"api/#toolbox.utils.utils","title":"<code>toolbox.utils.utils</code>","text":"<p>Utility functions for computational chemistry and materials science.</p> <p>This module provides a collection of utility functions for various tasks including: - Dictionary manipulation and file I/O operations - CP2K input file generation - Density and concentration calculations - Water molecule analysis and manipulation - Lennard-Jones parameter calculations - Coordinate number calculations</p> <p>The functions are designed to work with common scientific computing libraries such as NumPy, ASE, and MDAnalysis.</p>"},{"location":"api/#toolbox.utils.utils.calc_coord_number","title":"<code>calc_coord_number(atoms, c_ids, neigh_ids, cutoff=None, voronoi=False)</code>","text":"<p>Calculate coordination numbers for specified atoms.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object</p> required <code>c_ids</code> <code>ndarray</code> <p>Indices of central atoms</p> required <code>neigh_ids</code> <code>ndarray</code> <p>Indices of neighbor atoms</p> required <code>cutoff</code> <code>Optional[float]</code> <p>Distance cutoff for coordination calculation</p> <code>None</code> <code>voronoi</code> <code>bool</code> <p>If True, use Voronoi method instead of cutoff</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of coordination numbers</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def calc_coord_number(\n    atoms: Atoms,\n    c_ids: np.ndarray,\n    neigh_ids: np.ndarray,\n    cutoff: Optional[float] = None,\n    voronoi: bool = False,\n) -&gt; np.ndarray:\n    \"\"\"\n    Calculate coordination numbers for specified atoms.\n\n    Parameters\n    ----------\n    atoms : Atoms\n        ASE Atoms object\n    c_ids : np.ndarray\n        Indices of central atoms\n    neigh_ids : np.ndarray\n        Indices of neighbor atoms\n    cutoff : Optional[float], optional\n        Distance cutoff for coordination calculation\n    voronoi : bool, optional\n        If True, use Voronoi method instead of cutoff\n\n    Returns\n    -------\n    np.ndarray\n        Array of coordination numbers\n    \"\"\"\n    p = atoms.get_positions()\n    p_c = p[c_ids]\n    p_n = p[neigh_ids]\n    results = np.empty((len(c_ids), len(neigh_ids)), dtype=np.float64)\n    distance_array(p_c, p_n, box=atoms.cell.cellpar(), result=results)\n    if cutoff is None and voronoi:\n        # use voronoi method\n        out = np.unique(np.argmin(results, axis=0), return_counts=True)\n        cns = np.zeros(len(p_c), dtype=np.int32)\n        cns[out[0]] = out[1]\n    else:\n        # use cutoff method\n        cns = np.count_nonzero(results &lt;= cutoff, axis=1)\n    return cns\n</code></pre>"},{"location":"api/#toolbox.utils.utils.calc_density","title":"<code>calc_density(n, v, mol_mass)</code>","text":"<p>Calculate density (g/cm\u00b3) from the number of particles.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int or ndarray</code> <p>Number of particles</p> required <code>v</code> <code>float or ndarray</code> <p>Volume in \u00c5\u00b3</p> required <code>mol_mass</code> <code>float</code> <p>Molar mass in g/mol</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Density in g/cm\u00b3</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def calc_density(\n    n: Union[int, np.ndarray], v: Union[float, np.ndarray], mol_mass: float\n) -&gt; Union[float, np.ndarray]:\n    \"\"\"\n    Calculate density (g/cm\u00b3) from the number of particles.\n\n    Parameters\n    ----------\n    n : int or np.ndarray\n        Number of particles\n    v : float or np.ndarray\n        Volume in \u00c5\u00b3\n    mol_mass : float\n        Molar mass in g/mol\n\n    Returns\n    -------\n    float or np.ndarray\n        Density in g/cm\u00b3\n    \"\"\"\n    rho = (n / constants.Avogadro * mol_mass) / (\n        v * (constants.angstrom / constants.centi) ** 3\n    )\n    return rho\n</code></pre>"},{"location":"api/#toolbox.utils.utils.calc_lj_params","title":"<code>calc_lj_params(ks)</code>","text":"<p>Calculate and print Lennard-Jones parameters for element pairs.</p> <p>This function calculates mixed Lennard-Jones parameters using the Lorentz-Berthelot combining rules and prints them to stdout.</p> <p>Parameters:</p> Name Type Description Default <code>ks</code> <code>List[str]</code> <p>List of element symbols</p> required Source code in <code>toolbox/utils/utils.py</code> <pre><code>def calc_lj_params(ks: list[str]) -&gt; None:\n    \"\"\"\n    Calculate and print Lennard-Jones parameters for element pairs.\n\n    This function calculates mixed Lennard-Jones parameters using the\n    Lorentz-Berthelot combining rules and prints them to stdout.\n\n    Parameters\n    ----------\n    ks : List[str]\n        List of element symbols\n    \"\"\"\n    n_elements = len(ks)\n    _sigma = []\n    _epsilon = []\n    for i in range(n_elements):\n        try:\n            sigma_i = lj_params[ks[i]][\"sigma\"]\n            epsilon_i = lj_params[ks[i]][\"epsilon\"]\n            _sigma.append(sigma_i)\n        except KeyError as exc:\n            raise KeyError(f\"sigma for {ks[i]} not found\") from exc\n        for j in range(i, n_elements):\n            try:\n                sigma_j = lj_params[ks[j]][\"sigma\"]\n                epsilon_j = lj_params[ks[j]][\"epsilon\"]\n            except KeyError as exc:\n                raise KeyError(f\"sigma for {ks[j]} not found\") from exc\n            print(ks[i], ks[j], (sigma_i + sigma_j) / 2, np.sqrt(epsilon_i * epsilon_j))\n</code></pre>"},{"location":"api/#toolbox.utils.utils.calc_molar_concentration","title":"<code>calc_molar_concentration(number_density, grid_volume)</code>","text":"<p>Calculate molar concentration from number density.</p> <p>Parameters:</p> Name Type Description Default <code>number_density</code> <code>int, float, or np.ndarray</code> <p>Number of particles per grid</p> required <code>grid_volume</code> <code>float or ndarray</code> <p>Volume of each grid in \u00c5\u00b3 (angstrom cubed)</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Molar concentration in mol/L (moles of ions per liter of solution)</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def calc_molar_concentration(\n    number_density: Union[int, float, np.ndarray], grid_volume: Union[float, np.ndarray]\n) -&gt; Union[float, np.ndarray]:\n    \"\"\"\n    Calculate molar concentration from number density.\n\n    Parameters\n    ----------\n    number_density : int, float, or np.ndarray\n        Number of particles per grid\n    grid_volume : float or np.ndarray\n        Volume of each grid in \u00c5\u00b3 (angstrom cubed)\n\n    Returns\n    -------\n    float or np.ndarray\n        Molar concentration in mol/L (moles of ions per liter of solution)\n    \"\"\"\n    # Convert grid volume from \u00c5\u00b3 to cm\u00b3 (1 \u00c5\u00b3 = 1e-24 cm\u00b3)\n    volume_cm3 = grid_volume * 1e-24\n\n    # Convert volume from cm\u00b3 to liters (1 L = 1000 cm\u00b3)\n    volume_liters = volume_cm3 / 1000.0\n\n    # Calculate moles of ions in each grid\n    moles = number_density / constants.Avogadro\n\n    # Calculate molar concentration (mol/L)\n    molar_concentration = moles / volume_liters\n\n    return molar_concentration\n</code></pre>"},{"location":"api/#toolbox.utils.utils.calc_number","title":"<code>calc_number(rho, v, mol_mass)</code>","text":"<p>Calculate number of particles from density and volume.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>float or ndarray</code> <p>Density in g/cm\u00b3</p> required <code>v</code> <code>float or ndarray</code> <p>Volume in \u00c5\u00b3</p> required <code>mol_mass</code> <code>float</code> <p>Molar mass in g/mol</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of particles (rounded to integer)</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def calc_number(rho: Union[float, np.ndarray], v: Union[float, np.ndarray], mol_mass: float) -&gt; int:\n    \"\"\"\n    Calculate number of particles from density and volume.\n\n    Parameters\n    ----------\n    rho : float or np.ndarray\n        Density in g/cm\u00b3\n    v : float or np.ndarray\n        Volume in \u00c5\u00b3\n    mol_mass : float\n        Molar mass in g/mol\n\n    Returns\n    -------\n    int\n        Number of particles (rounded to integer)\n    \"\"\"\n    n = (\n        rho\n        * (v * (constants.angstrom / constants.centi) ** 3)\n        * constants.Avogadro\n        / mol_mass\n    )\n    return int(n)\n</code></pre>"},{"location":"api/#toolbox.utils.utils.calc_water_coord_number","title":"<code>calc_water_coord_number(atoms)</code>","text":"<p>Calculate coordination numbers for water molecules (O-H coordination).</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object containing water molecules</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of coordination numbers for oxygen atoms</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def calc_water_coord_number(atoms: Atoms) -&gt; np.ndarray:\n    \"\"\"\n    Calculate coordination numbers for water molecules (O-H coordination).\n\n    Parameters\n    ----------\n    atoms : Atoms\n        ASE Atoms object containing water molecules\n\n    Returns\n    -------\n    np.ndarray\n        Array of coordination numbers for oxygen atoms\n    \"\"\"\n    atype = np.array(atoms.get_chemical_symbols())\n    c_ids = np.where(atype == \"O\")[0]\n    neigh_ids = np.where(atype == \"H\")[0]\n    return calc_coord_number(atoms, c_ids, neigh_ids, 1.3)\n</code></pre>"},{"location":"api/#toolbox.utils.utils.calc_water_density","title":"<code>calc_water_density(n, v)</code>","text":"<p>Calculate water density using water molar mass (18.015 g/mol).</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int or ndarray</code> <p>Number of water molecules</p> required <code>v</code> <code>float or ndarray</code> <p>Volume in \u00c5\u00b3</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Water density in g/cm\u00b3</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def calc_water_density(\n    n: Union[int, np.ndarray], v: Union[float, np.ndarray]\n) -&gt; Union[float, np.ndarray]:\n    \"\"\"\n    Calculate water density using water molar mass (18.015 g/mol).\n\n    Parameters\n    ----------\n    n : int or np.ndarray\n        Number of water molecules\n    v : float or np.ndarray\n        Volume in \u00c5\u00b3\n\n    Returns\n    -------\n    float or np.ndarray\n        Water density in g/cm\u00b3\n    \"\"\"\n    return calc_density(n, v, 18.015)\n</code></pre>"},{"location":"api/#toolbox.utils.utils.calc_water_number","title":"<code>calc_water_number(rho, v)</code>","text":"<p>Calculate number of water molecules from density and volume.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>float or ndarray</code> <p>Water density in g/cm\u00b3</p> required <code>v</code> <code>float or ndarray</code> <p>Volume in \u00c5\u00b3</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of water molecules</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def calc_water_number(rho: Union[float, np.ndarray], v: Union[float, np.ndarray]) -&gt; int:\n    \"\"\"\n    Calculate number of water molecules from density and volume.\n\n    Parameters\n    ----------\n    rho : float or np.ndarray\n        Water density in g/cm\u00b3\n    v : float or np.ndarray\n        Volume in \u00c5\u00b3\n\n    Returns\n    -------\n    int\n        Number of water molecules\n    \"\"\"\n    return calc_number(rho, v, 18.015)\n</code></pre>"},{"location":"api/#toolbox.utils.utils.check_water","title":"<code>check_water(atoms)</code>","text":"<p>Check if all water molecules have correct coordination (2 H per O).</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object containing water molecules</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if all water molecules are correct, False otherwise</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def check_water(atoms: Atoms) -&gt; bool:\n    \"\"\"\n    Check if all water molecules have correct coordination (2 H per O).\n\n    Parameters\n    ----------\n    atoms : Atoms\n        ASE Atoms object containing water molecules\n\n    Returns\n    -------\n    bool\n        True if all water molecules are correct, False otherwise\n    \"\"\"\n    cns = calc_water_coord_number(atoms)\n    flags = cns == 2\n    return False not in flags\n</code></pre>"},{"location":"api/#toolbox.utils.utils.dict_to_cp2k_input","title":"<code>dict_to_cp2k_input(input_dict)</code>","text":"<p>Convert a dictionary to CP2K input file format.</p> <p>Parameters:</p> Name Type Description Default <code>input_dict</code> <code>Dict[str, Any]</code> <p>Dictionary containing CP2K input parameters</p> required <p>Returns:</p> Type Description <code>str</code> <p>Formatted CP2K input string</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def dict_to_cp2k_input(input_dict: dict[str, Any]) -&gt; str:\n    \"\"\"\n    Convert a dictionary to CP2K input file format.\n\n    Parameters\n    ----------\n    input_dict : Dict[str, Any]\n        Dictionary containing CP2K input parameters\n\n    Returns\n    -------\n    str\n        Formatted CP2K input string\n    \"\"\"\n    input_str = iterdict(input_dict, out_list=[\"\\n\"], loop_idx=0)\n    s = \"\\n\".join(input_str)\n    s = s.strip(\"\\n\")\n    return s\n</code></pre>"},{"location":"api/#toolbox.utils.utils.get_bins_from_bin_edge","title":"<code>get_bins_from_bin_edge(bin_edges)</code>","text":"<p>Get bin centers from bin edges.</p> <p>Parameters:</p> Name Type Description Default <code>bin_edges</code> <code>ndarray or List[float]</code> <p>Array of bin edges</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of bin centers</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def get_bins_from_bin_edge(bin_edges: Union[np.ndarray, List[float]]) -&gt; np.ndarray:\n    \"\"\"\n    Get bin centers from bin edges.\n\n    Parameters\n    ----------\n    bin_edges : np.ndarray or List[float]\n        Array of bin edges\n\n    Returns\n    -------\n    np.ndarray\n        Array of bin centers\n    \"\"\"\n    bin_edges = np.reshape(bin_edges, (-1,))\n    bins = bin_edges[:-1] + np.diff(bin_edges) / 2\n    return bins\n</code></pre>"},{"location":"api/#toolbox.utils.utils.get_efields","title":"<code>get_efields(delta_v, layer_thicknesses, eps)</code>","text":"<p>Calculate electric fields from voltage differences and dielectric properties.</p> <p>Parameters:</p> Name Type Description Default <code>delta_v</code> <code>float</code> <p>Voltage difference</p> required <code>layer_thicknesses</code> <code>List[float]</code> <p>List of layer thicknesses</p> required <code>eps</code> <code>List[float]</code> <p>List of dielectric constants</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of electric field values</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def get_efields(delta_v: float, layer_thicknesses: list[float], eps: list[float]) -&gt; np.ndarray:\n    \"\"\"\n    Calculate electric fields from voltage differences and dielectric properties.\n\n    Parameters\n    ----------\n    delta_v : float\n        Voltage difference\n    layer_thicknesses : List[float]\n        List of layer thicknesses\n    eps : List[float]\n        List of dielectric constants\n\n    Returns\n    -------\n    np.ndarray\n        Array of electric field values\n    \"\"\"\n    r_field = 1.0 / np.array(eps)\n    _delta_v = np.sum(np.array(layer_thicknesses) * r_field)\n    v_coeff = delta_v / _delta_v\n    return r_field * v_coeff\n</code></pre>"},{"location":"api/#toolbox.utils.utils.iterdict","title":"<code>iterdict(input_dict, out_list, loop_idx)</code>","text":"<p>Recursively generate a list of strings for CP2K input file formatting.</p> <p>This function processes a nested dictionary structure and converts it into a formatted list of strings suitable for generating CP2K input files.</p> <p>Parameters:</p> Name Type Description Default <code>input_dict</code> <code>Dict[str, Any]</code> <p>Dictionary containing CP2K input parameters</p> required <code>out_list</code> <code>List[str]</code> <p>List of strings for printing (modified in-place)</p> required <code>loop_idx</code> <code>int</code> <p>Record of loop levels in recursion</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>Formatted list of strings for CP2K input file</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def iterdict(\n    input_dict: dict[str, Any], out_list: list[str], loop_idx: int\n) -&gt; list[str]:\n    \"\"\"\n    Recursively generate a list of strings for CP2K input file formatting.\n\n    This function processes a nested dictionary structure and converts it into\n    a formatted list of strings suitable for generating CP2K input files.\n\n    Parameters\n    ----------\n    input_dict : Dict[str, Any]\n        Dictionary containing CP2K input parameters\n    out_list : List[str]\n        List of strings for printing (modified in-place)\n    loop_idx : int\n        Record of loop levels in recursion\n\n    Returns\n    -------\n    List[str]\n        Formatted list of strings for CP2K input file\n    \"\"\"\n    if len(out_list) == 0:\n        out_list.append(\"\\n\")\n    start_idx = len(out_list) - loop_idx - 2\n    for k, v in input_dict.items():\n        k = str(k)  # cast key into string\n        # if value is dictionary\n        if isinstance(v, dict):\n            out_list.insert(-1 - loop_idx, \"  \" * loop_idx + \"&amp;\" + k)\n            out_list.insert(-1 - loop_idx, \"  \" * loop_idx + \"&amp;END \" + k)\n            iterdict(v, out_list, loop_idx + 1)\n        # if value is list\n        elif isinstance(v, list):\n            if isinstance(v[0], dict):\n                for _v in v:\n                    out_list.insert(-1 - loop_idx, \"  \" * loop_idx + \"&amp;\" + k)\n                    out_list.insert(-1 - loop_idx, \"  \" * loop_idx + \"&amp;END \" + k)\n                    iterdict(_v, out_list, loop_idx + 1)\n            else:\n                for _v in v:\n                    _v = str(_v)\n                    out_list.insert(-1 - loop_idx, \"  \" * loop_idx + k + \" \" + _v)\n        # if value is other type, e.g., int/float/str\n        else:\n            v = str(v)\n            if k == \"_\":\n                out_list[start_idx] = out_list[start_idx] + \" \" + v\n            else:\n                out_list.insert(-1 - loop_idx, \"  \" * loop_idx + k + \" \" + v)\n    return out_list\n</code></pre>"},{"location":"api/#toolbox.utils.utils.load_dict","title":"<code>load_dict(fname, fmt=None)</code>","text":"<p>Load a dictionary from a file in various formats.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Input filename</p> required <code>fmt</code> <code>Optional[str]</code> <p>File format (json, csv, pkl, hdf5, yaml). If None, inferred from extension.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Loaded dictionary</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the format is not supported</p> <code>NotImplementedError</code> <p>If HDF5 format is requested (not implemented)</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def load_dict(fname: str, fmt: Optional[str] = None) -&gt; dict[str, Any]:\n    \"\"\"\n    Load a dictionary from a file in various formats.\n\n    Parameters\n    ----------\n    fname : str\n        Input filename\n    fmt : Optional[str], optional\n        File format (json, csv, pkl, hdf5, yaml). If None, inferred from extension.\n\n    Returns\n    -------\n    Dict[str, Any]\n        Loaded dictionary\n\n    Raises\n    ------\n    KeyError\n        If the format is not supported\n    NotImplementedError\n        If HDF5 format is requested (not implemented)\n    \"\"\"\n    if fmt is None:\n        fmt = os.path.splitext(fname)[1][1:]\n    try:\n        return globals()[f\"load_dict_{fmt}\"](fname)\n    except KeyError as exc:\n        raise KeyError(f\"Unknown format {fmt}\") from exc\n</code></pre>"},{"location":"api/#toolbox.utils.utils.load_dict_csv","title":"<code>load_dict_csv(fname)</code>","text":"<p>Load dictionary from CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Input filename</p> required <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Loaded dictionary</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def load_dict_csv(fname: str) -&gt; dict[str, str]:\n    \"\"\"\n    Load dictionary from CSV file.\n\n    Parameters\n    ----------\n    fname : str\n        Input filename\n\n    Returns\n    -------\n    Dict[str, str]\n        Loaded dictionary\n    \"\"\"\n    with open(fname, encoding=\"UTF-8\") as f:\n        data = csv.reader(f)\n        d = {rows[0]: rows[1] for rows in data}\n    return d\n</code></pre>"},{"location":"api/#toolbox.utils.utils.load_dict_hdf5","title":"<code>load_dict_hdf5(fname)</code>","text":"<p>Load dictionary from HDF5 file (not implemented).</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Input filename</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This function is not implemented</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def load_dict_hdf5(fname: str) -&gt; dict[str, Any]:\n    \"\"\"\n    Load dictionary from HDF5 file (not implemented).\n\n    Parameters\n    ----------\n    fname : str\n        Input filename\n\n    Raises\n    ------\n    NotImplementedError\n        This function is not implemented\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#toolbox.utils.utils.load_dict_json","title":"<code>load_dict_json(fname)</code>","text":"<p>Load dictionary from JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Input filename</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Loaded dictionary</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def load_dict_json(fname: str) -&gt; dict[str, Any]:\n    \"\"\"\n    Load dictionary from JSON file.\n\n    Parameters\n    ----------\n    fname : str\n        Input filename\n\n    Returns\n    -------\n    Dict[str, Any]\n        Loaded dictionary\n    \"\"\"\n    with open(fname, encoding=\"UTF-8\") as f:\n        d = json.load(f)\n    return d\n</code></pre>"},{"location":"api/#toolbox.utils.utils.load_dict_pkl","title":"<code>load_dict_pkl(fname)</code>","text":"<p>Load dictionary from pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Input filename</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Loaded dictionary</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def load_dict_pkl(fname: str) -&gt; dict[str, Any]:\n    \"\"\"\n    Load dictionary from pickle file.\n\n    Parameters\n    ----------\n    fname : str\n        Input filename\n\n    Returns\n    -------\n    Dict[str, Any]\n        Loaded dictionary\n    \"\"\"\n    with open(fname, \"rb\") as f:\n        d = pickle.load(f)\n    return d\n</code></pre>"},{"location":"api/#toolbox.utils.utils.load_dict_yaml","title":"<code>load_dict_yaml(fname)</code>","text":"<p>Load dictionary from YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Input filename</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Loaded dictionary</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def load_dict_yaml(fname: str) -&gt; dict[str, Any]:\n    \"\"\"\n    Load dictionary from YAML file.\n\n    Parameters\n    ----------\n    fname : str\n        Input filename\n\n    Returns\n    -------\n    Dict[str, Any]\n        Loaded dictionary\n    \"\"\"\n    with open(fname, encoding=\"UTF-8\") as f:\n        return yaml.safe_load(f)\n</code></pre>"},{"location":"api/#toolbox.utils.utils.safe_makedirs","title":"<code>safe_makedirs(dname)</code>","text":"<p>Create directory if it doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>dname</code> <code>str</code> <p>Directory path to create</p> required Source code in <code>toolbox/utils/utils.py</code> <pre><code>def safe_makedirs(dname: str) -&gt; None:\n    \"\"\"\n    Create directory if it doesn't exist.\n\n    Parameters\n    ----------\n    dname : str\n        Directory path to create\n    \"\"\"\n    if not os.path.exists(dname):\n        os.makedirs(dname)\n</code></pre>"},{"location":"api/#toolbox.utils.utils.safe_symlink","title":"<code>safe_symlink(src, dst, **kwargs)</code>","text":"<p>Create symbolic link if it doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>Source file path</p> required <code>dst</code> <code>str</code> <p>Destination path</p> required <code>**kwargs</code> <p>Additional arguments for os.symlink</p> <code>{}</code> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def safe_symlink(src: str, dst: str, **kwargs) -&gt; None:\n    \"\"\"\n    Create symbolic link if it doesn't exist.\n\n    Parameters\n    ----------\n    src : str\n        Source file path\n    dst : str\n        Destination path\n    **kwargs\n        Additional arguments for os.symlink\n    \"\"\"\n    with contextlib.suppress(OSError):\n        os.symlink(src, dst, **kwargs)\n</code></pre>"},{"location":"api/#toolbox.utils.utils.save_dict","title":"<code>save_dict(d, fname, fmt=None)</code>","text":"<p>Save a dictionary to a file in various formats.</p> <p>Args:     d: Dictionary to save     fname: Output filename     fmt: File format (json, csv, pkl, hdf5, yaml). If None, inferred from extension.</p> <p>Raises:</p> Type Description <code>    KeyError: If the format is not supported</code> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def save_dict(d: dict[str, Any], fname: str, fmt: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Save a dictionary to a file in various formats.\n\n    Args:\n        d: Dictionary to save\n        fname: Output filename\n        fmt: File format (json, csv, pkl, hdf5, yaml). If None, inferred from extension.\n\n    Raises\n    ------\n        KeyError: If the format is not supported\n    \"\"\"\n    if fmt is None:\n        fmt = os.path.splitext(fname)[1][1:]\n    try:\n        globals()[f\"save_dict_{fmt}\"](d, fname)\n    except KeyError as exc:\n        raise KeyError(f\"Unknown format {fmt}\") from exc\n</code></pre>"},{"location":"api/#toolbox.utils.utils.save_dict_csv","title":"<code>save_dict_csv(d, fname)</code>","text":"<p>Save dictionary to CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Dict[str, Any]</code> <p>Dictionary to save</p> required <code>fname</code> <code>str</code> <p>Output filename</p> required Source code in <code>toolbox/utils/utils.py</code> <pre><code>def save_dict_csv(d: dict[str, Any], fname: str) -&gt; None:\n    \"\"\"\n    Save dictionary to CSV file.\n\n    Parameters\n    ----------\n    d : Dict[str, Any]\n        Dictionary to save\n    fname : str\n        Output filename\n    \"\"\"\n    with open(fname, \"w\", newline=\"\", encoding=\"UTF-8\") as f:\n        writer = csv.DictWriter(f, fieldnames=d.keys())\n        writer.writeheader()\n        writer.writerow(d)\n</code></pre>"},{"location":"api/#toolbox.utils.utils.save_dict_hdf5","title":"<code>save_dict_hdf5(d, fname)</code>","text":"<p>Save dictionary to HDF5 file.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Dict[str, Any]</code> <p>Dictionary to save</p> required <code>fname</code> <code>str</code> <p>Output filename</p> required Source code in <code>toolbox/utils/utils.py</code> <pre><code>def save_dict_hdf5(d: dict[str, Any], fname: str) -&gt; None:\n    \"\"\"\n    Save dictionary to HDF5 file.\n\n    Parameters\n    ----------\n    d : Dict[str, Any]\n        Dictionary to save\n    fname : str\n        Output filename\n    \"\"\"\n    with h5py.File(fname, \"a\") as f:\n        n = len(f)\n        dts = f.create_group(f\"{n:02d}\")\n        for k, v in d.items():\n            dts.create_dataset(k, data=v)\n</code></pre>"},{"location":"api/#toolbox.utils.utils.save_dict_json","title":"<code>save_dict_json(d, fname)</code>","text":"<p>Save dictionary to JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Dict[str, Any]</code> <p>Dictionary to save</p> required <code>fname</code> <code>str</code> <p>Output filename</p> required Source code in <code>toolbox/utils/utils.py</code> <pre><code>def save_dict_json(d: dict[str, Any], fname: str) -&gt; None:\n    \"\"\"\n    Save dictionary to JSON file.\n\n    Parameters\n    ----------\n    d : Dict[str, Any]\n        Dictionary to save\n    fname : str\n        Output filename\n    \"\"\"\n    with open(fname, \"w\", encoding=\"UTF-8\") as f:\n        json.dump(d, f, indent=4)\n</code></pre>"},{"location":"api/#toolbox.utils.utils.save_dict_pkl","title":"<code>save_dict_pkl(d, fname)</code>","text":"<p>Save dictionary to pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Dict[str, Any]</code> <p>Dictionary to save</p> required <code>fname</code> <code>str</code> <p>Output filename</p> required Source code in <code>toolbox/utils/utils.py</code> <pre><code>def save_dict_pkl(d: dict[str, Any], fname: str) -&gt; None:\n    \"\"\"\n    Save dictionary to pickle file.\n\n    Parameters\n    ----------\n    d : Dict[str, Any]\n        Dictionary to save\n    fname : str\n        Output filename\n    \"\"\"\n    with open(fname, \"wb\") as f:\n        pickle.dump(d, f)\n</code></pre>"},{"location":"api/#toolbox.utils.utils.save_dict_yaml","title":"<code>save_dict_yaml(d, fname)</code>","text":"<p>Save dictionary to YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Dict[str, Any]</code> <p>Dictionary to save</p> required <code>fname</code> <code>str</code> <p>Output filename</p> required Source code in <code>toolbox/utils/utils.py</code> <pre><code>def save_dict_yaml(d: dict[str, Any], fname: str) -&gt; None:\n    \"\"\"\n    Save dictionary to YAML file.\n\n    Parameters\n    ----------\n    d : Dict[str, Any]\n        Dictionary to save\n    fname : str\n        Output filename\n    \"\"\"\n    with open(fname, \"w\", encoding=\"UTF-8\") as f:\n        yaml.safe_dump(d, f)\n</code></pre>"},{"location":"api/#toolbox.utils.utils.symlink","title":"<code>symlink(src, _dst)</code>","text":"<p>Create a symbolic link.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>Source file path</p> required <code>_dst</code> <code>str</code> <p>Destination path</p> required Source code in <code>toolbox/utils/utils.py</code> <pre><code>def symlink(src: str, _dst: str) -&gt; None:\n    \"\"\"\n    Create a symbolic link.\n\n    Parameters\n    ----------\n    src : str\n        Source file path\n    _dst : str\n        Destination path\n    \"\"\"\n    dst = os.path.abspath(_dst)\n    os.symlink(src, dst)\n</code></pre>"},{"location":"api/#toolbox.utils.utils.update_dict","title":"<code>update_dict(old_d, update_d)</code>","text":"<p>Recursively update a dictionary with values from another dictionary.</p> <p>Source: dpgen.generator.lib.cp2k</p> <p>Parameters:</p> Name Type Description Default <code>old_d</code> <code>Dict[str, Any]</code> <p>Original dictionary to be updated</p> required <code>update_d</code> <code>Dict[str, Any]</code> <p>Dictionary containing update values</p> required Source code in <code>toolbox/utils/utils.py</code> <pre><code>def update_dict(old_d: dict[str, Any], update_d: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Recursively update a dictionary with values from another dictionary.\n\n    Source: dpgen.generator.lib.cp2k\n\n    Parameters\n    ----------\n    old_d : Dict[str, Any]\n        Original dictionary to be updated\n    update_d : Dict[str, Any]\n        Dictionary containing update values\n    \"\"\"\n    for k in update_d:\n        if (\n            k in old_d\n            and isinstance(old_d[k], dict)\n            and isinstance(update_d[k], collections.abc.Mapping)\n        ):\n            update_dict(old_d[k], update_d[k])\n        else:\n            old_d[k] = update_d[k]\n</code></pre>"},{"location":"api/#toolbox.utils.utils.wrap_water","title":"<code>wrap_water(atoms)</code>","text":"<p>Make water molecules whole (keep O and H atoms together).</p> <p>This function ensures that water molecules are not split across periodic boundaries. Works for pure water systems.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object containing water molecules</p> required <p>Returns:</p> Type Description <code>Atoms</code> <p>New Atoms object with wrapped water molecules</p> Source code in <code>toolbox/utils/utils.py</code> <pre><code>def wrap_water(atoms: Atoms) -&gt; Atoms:\n    \"\"\"\n    Make water molecules whole (keep O and H atoms together).\n\n    This function ensures that water molecules are not split across periodic\n    boundaries. Works for pure water systems.\n\n    Parameters\n    ----------\n    atoms : Atoms\n        ASE Atoms object containing water molecules\n\n    Returns\n    -------\n    Atoms\n        New Atoms object with wrapped water molecules\n    \"\"\"\n    atoms = atoms.copy()\n    oxygen_mask = atoms.symbols == \"O\"\n    hydrogen_mask = atoms.symbols == \"H\"\n    other_mask = np.logical_not(np.logical_or(oxygen_mask, hydrogen_mask))\n\n    coords = wrap_positions(atoms.get_positions(), atoms.get_cell())\n    cellpar = atoms.cell.cellpar()\n    oxygen_coords = coords[oxygen_mask]\n    hydrogen_coords = coords[hydrogen_mask]\n    new_atoms = Atoms(cell=atoms.cell, pbc=atoms.pbc)\n    for oxygen_coord in oxygen_coords:\n        oxygen_coord = np.reshape(oxygen_coord, (1, 3))\n        ds = distance_array(oxygen_coord, hydrogen_coords, box=cellpar)\n        mask = ds.reshape(-1) &lt; 1.3\n        cn = np.sum(mask)\n        coords_rel = hydrogen_coords[mask].reshape(-1, 3) - oxygen_coord\n        coords_rel = minimize_vectors(coords_rel, box=cellpar)\n        _coords = np.concatenate(\n            (\n                oxygen_coord,\n                oxygen_coord + coords_rel,\n            ),\n            axis=0,\n        )\n        new_atoms.extend(Atoms(f\"OH{cn}\", positions=_coords))\n        # remove selected hydrogen atoms\n        hydrogen_coords = hydrogen_coords[~mask]\n    assert len(hydrogen_coords) == 0\n    new_atoms.extend(atoms[other_mask])\n    return new_atoms\n</code></pre>"},{"location":"api/#machine-learning-module","title":"Machine Learning Module","text":""},{"location":"api/#tensorflow-graph","title":"TensorFlow Graph","text":""},{"location":"api/#toolbox.ml.tf_graph","title":"<code>toolbox.ml.tf_graph</code>","text":"<p>TensorFlow graph module.</p> <p>This module provides functionality for loading and visualizing TensorFlow graphs from DeepMD models.</p>"},{"location":"api/#toolbox.ml.tf_graph.Graph","title":"<code>Graph</code>","text":"<p>from toolbox.ml import Graph.</p> <p>Graph(\"graph.pb\").run()</p>"},{"location":"api/#toolbox.ml.tf_graph.Graph--then-you-can-access-the-graph-with-localhost6006","title":"then you can access the graph with localhost:6006","text":"Source code in <code>toolbox/ml/tf_graph.py</code> <pre><code>class Graph:\n    \"\"\"\n    from toolbox.ml import Graph.\n\n    Graph(\"graph.pb\").run()\n    # then you can access the graph with localhost:6006\n    \"\"\"\n\n    def __init__(self, dp_model=\"graph.pb\") -&gt; None:\n        \"\"\"Initialize Graph.\n\n        Parameters\n        ----------\n        dp_model : str, optional\n            Path to Deep MD model file, by default \"graph.pb\"\n        \"\"\"\n        self.model = dp_model\n\n    def run(self, port=6006):\n        \"\"\"Run graph with TensorBoard visualization.\n\n        Parameters\n        ----------\n        port : int, optional\n            Port for TensorBoard server, by default 6006\n        \"\"\"\n        graph = self._load_graph(self.model)\n        with tf.Session(graph=graph) as sess:\n            writer = tf.summary.FileWriter(\"dp_logs\", sess.graph)\n            writer.close()\n        os.system(f\"tensorboard --logdir=dp_logs --port={port:d}\")\n\n    @staticmethod\n    def _load_graph(\n        frozen_graph_filename, prefix: str = \"load\", default_tf_graph: bool = False\n    ):\n        \"\"\"deepmd.infer.DeepEval._load_graph.\"\"\"\n        # We load the protobuf file from the disk and parse it to retrieve the\n        # unserialized graph_def\n        with tf.gfile.GFile(str(frozen_graph_filename), \"rb\") as f:\n            graph_def = tf.GraphDef()\n            graph_def.ParseFromString(f.read())\n\n            if default_tf_graph:\n                tf.import_graph_def(\n                    graph_def,\n                    input_map=None,\n                    return_elements=None,\n                    name=prefix,\n                    producer_op_list=None,\n                )\n                graph = tf.get_default_graph()\n            else:\n                # Then, we can use again a convenient built-in function to import\n                # a graph_def into the  current default Graph\n                with tf.Graph().as_default() as graph:\n                    tf.import_graph_def(\n                        graph_def,\n                        input_map=None,\n                        return_elements=None,\n                        name=prefix,\n                        producer_op_list=None,\n                    )\n\n            return graph\n</code></pre>"},{"location":"api/#toolbox.ml.tf_graph.Graph.__init__","title":"<code>__init__(dp_model='graph.pb')</code>","text":"<p>Initialize Graph.</p> <p>Parameters:</p> Name Type Description Default <code>dp_model</code> <code>str</code> <p>Path to Deep MD model file, by default \"graph.pb\"</p> <code>'graph.pb'</code> Source code in <code>toolbox/ml/tf_graph.py</code> <pre><code>def __init__(self, dp_model=\"graph.pb\") -&gt; None:\n    \"\"\"Initialize Graph.\n\n    Parameters\n    ----------\n    dp_model : str, optional\n        Path to Deep MD model file, by default \"graph.pb\"\n    \"\"\"\n    self.model = dp_model\n</code></pre>"},{"location":"api/#toolbox.ml.tf_graph.Graph.run","title":"<code>run(port=6006)</code>","text":"<p>Run graph with TensorBoard visualization.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port for TensorBoard server, by default 6006</p> <code>6006</code> Source code in <code>toolbox/ml/tf_graph.py</code> <pre><code>def run(self, port=6006):\n    \"\"\"Run graph with TensorBoard visualization.\n\n    Parameters\n    ----------\n    port : int, optional\n        Port for TensorBoard server, by default 6006\n    \"\"\"\n    graph = self._load_graph(self.model)\n    with tf.Session(graph=graph) as sess:\n        writer = tf.summary.FileWriter(\"dp_logs\", sess.graph)\n        writer.close()\n    os.system(f\"tensorboard --logdir=dp_logs --port={port:d}\")\n</code></pre>"},{"location":"calculator/","title":"Calculator","text":""},{"location":"calculator/#cp2k-cp2kcalculator","title":"CP2K: <code>Cp2kCalculator</code>","text":"<pre><code>from toolbox.calculator import Cp2kCalculator\n\nCp2kCalculator(\"work_dir\").run()\n</code></pre>"},{"location":"calculator/#lammps-lammpscalculator","title":"LAMMPS: <code>LammpsCalculator</code>","text":"<pre><code>from toolbox.calculator import LammpsCalculator\n\nLammpsCalculator(\"work_dir\").run()\n</code></pre>"},{"location":"cp2k/","title":"CP2K","text":"<p>For pre-/post-processing of CP2K, you might also be interested in pycp2k and cp2kdata.</p>"},{"location":"cp2k/#generate-input-files-cp2kinput","title":"Generate input files: <code>Cp2kInput</code>","text":"<p>Create cp2k input files.</p> <pre><code>from toolbox.utils import *\nfrom toolbox.io.cp2k import Cp2kInput\n\natoms = io.read(\"coord.xyz\")\n# remember to set cell parameters and pbc!\ncp2k_inp = Cp2kInput(atoms=atoms, input_type=\"energy\", cutoff=1000)\nfp_params = {\n    \"FORCE_EVAL\": {\n        \"DFT\": {\n            \"SCF\": {\n                \"MAX_SCF\": 3,\n                \"EPS_DIIS\": 1e-15,\n                \"DIAGONALIZATION\": {\"_\": \".FALSE.\"},\n                \"MIXING\": {\"ALPHA\": 0.0, \"METHOD\": \"DIRECT_P_MIXING\"},\n            }\n        }\n    }\n}\ncp2k_inp.write(output_dir=\"test\", fp_params=fp_params)\n</code></pre> <p>You can modify the internal template by setting the variables when initializing the <code>Cp2kInput</code> or via the dict <code>fp_params</code>.</p>"},{"location":"cp2k/#run-cp2k-calculation-in-python","title":"Run CP2K calculation in python","text":"<p>You can perform CP2K calculations in python script via <code>Cp2kCalculator</code>.</p>"},{"location":"cp2k/#post-processing-of-output-files","title":"Post-processing of output files","text":""},{"location":"cp2k/#cp2koutput","title":"<code>Cp2kOutput</code>","text":"<p>Read data from cp2k standard output (for single frame). All output values have been converted to eV (from Hartree).</p> <pre><code>from toolbox.io.cp2k import Cp2kOutput\n\ncp2k_out = Cp2kOutput(\"output.out\")\nprint(cp2k_out.fermi)\nprint(cp2k_out.energy)\n</code></pre>"},{"location":"cp2k/#cp2kcube-and-cp2khartreecube","title":"<code>Cp2kCube</code> and <code>Cp2kHartreeCube</code>","text":"<p>Read and do the average of cp2k cube file. In <code>Cp2kCube</code>, no unit conversion is taken. In <code>Cp2kHartreeCube</code>, atmoic unit of energy (i.e. Hartree) is converted to electron volt (eV).</p> <pre><code>from toolbox.utils import *\nfrom toolbox.io.cp2k import Cp2kCube, Cp2kHartreeCube\n\ne_cube = Cp2kCube(\"cp2k-TOTAL_DENSITY-1_0.cube\")\noutput = e_cube.get_ave_cube(axis=2, gaussian_sigma=0.0)\nplt.plot(output[0], output[1])\n\nv_cube = Cp2kHartreeCube(\"cp2k-v_hartree-1_0.cube\")\noutput = v_cube.get_ave_cube(axis=2, gaussian_sigma=0.0)\nplt.plot(output[0], output[1])\n\nplt.show()\n</code></pre>"},{"location":"lammps/","title":"LAMMPS","text":"<p>The functions/classes in this package are supplementary for the relevant functions in ASE. There are also some other packages, such as moltemplate.</p>"},{"location":"lammps/#generate-input-files","title":"Generate input files","text":""},{"location":"lammps/#run-lammps-calculation-in-python","title":"Run LAMMPS calculation in python","text":"<p>You can perform LAMMPS calculations in python script via <code>LammpsCalculator</code>.</p>"},{"location":"lammps/#post-processing-of-output-files","title":"Post-processing of output files","text":""},{"location":"plot/","title":"make plots","text":""},{"location":"plot/#set-style","title":"set style","text":"<pre><code>from toolbox import plot\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nplt.plot(np.arange(10), np.arange(10), color=\"blue\")\nplot.use_style(\"pub\")\nplt.plot(np.arange(10), np.arange(10), color=\"blue\")\n\nplt.savefig(\"mpl_style_example.png\")\n\nplt.show()\n</code></pre> <p>Output: </p>"},{"location":"unittest/","title":"Unittest list","text":"<ul> <li> io.cp2k</li> <li> io.lammps</li> <li> calculator.bash</li> <li> calculator.cp2k</li> <li> calculator.lammps</li> <li> calculator.dpgen</li> <li> calculator.elecpot</li> </ul>"}]}